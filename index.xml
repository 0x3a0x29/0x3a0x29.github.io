<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>0x3a0x29的博客</title>
        <link>https://0x3a0x29.github.io/</link>
        <description>Recent content on 0x3a0x29的博客</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>0x3a0x29的博客</copyright>
        <lastBuildDate>Fri, 10 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://0x3a0x29.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>文章</title>
        <link>https://0x3a0x29.github.io/%E6%96%87%E7%AB%A0/</link>
        <pubDate>Fri, 10 Jan 2025 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/%E6%96%87%E7%AB%A0/</guid>
        <description></description>
        </item>
        <item>
        <title>下推自动机PDA及上下文无关语言CFL</title>
        <link>https://0x3a0x29.github.io/p/contextfree/</link>
        <pubDate>Fri, 12 Jul 2024 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/p/contextfree/</guid>
        <description>&lt;img src="https://0x3a0x29.github.io/p/contextfree/image.png" alt="Featured image of post 下推自动机PDA及上下文无关语言CFL" /&gt;&lt;h1 id=&#34;下推自动机pda及上下文无关语言cfl&#34;&gt;下推自动机PDA及上下文无关语言CFL
&lt;/h1&gt;&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;阅读本文需要集合论、图论和数据结构的相关知识，在此不作有关相关知识的赘述。&lt;/p&gt;
&lt;p&gt;笔者水平有限，存在的错误和不足请大家指正。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;文法&#34;&gt;文法
&lt;/h2&gt;&lt;h3 id=&#34;文法的形式化定义&#34;&gt;文法的形式化定义
&lt;/h3&gt;&lt;p&gt;语言学家们在研究自然语言的理解的过程中完成了对 &lt;strong&gt;文法（grammar）&lt;/strong&gt; 这一概念的形式化，通过找到一种自然语言的形式化的文法，可以有助于对这个语言的自动理解。例如可以用来帮助实现语言的机器翻译、文章摘要的提取、文稿的校对与更正等。现在给出文法的形式化定义：&lt;/p&gt;
&lt;p&gt;文法$G$是一个四元组$G=(V,T,P,S)$，其中：&lt;/p&gt;
&lt;p&gt;$V$是 &lt;strong&gt;变量（variable）&lt;/strong&gt; 的非空有穷集，$\forall A\in V,A$被称为 &lt;strong&gt;语法变量（syntactic variable）&lt;/strong&gt; ，简称变量，或称 &lt;strong&gt;终极符号（nonterminal）&lt;/strong&gt; ，他表示一个 &lt;strong&gt;语法范畴（syntactic category）&lt;/strong&gt; ，记作$L(A)$。&lt;/p&gt;
&lt;p&gt;$T$是 &lt;strong&gt;终极符（terminal）&lt;/strong&gt; 的非空有穷集，$\forall a\in T,a$被称为终极符，由于$V$中的符号表示语法范畴，所以有$V\cap T=\varnothing$。&lt;/p&gt;
&lt;p&gt;$P$是 &lt;strong&gt;产生式（production）&lt;/strong&gt; （或者称为 &lt;strong&gt;替换规则（substitution）&lt;/strong&gt; ）的非空有穷集，$P$中的元素均有形式$\alpha\rightarrow\beta$，称为产生式，读作$\alpha$定义为$\beta$，其中$\alpha\in(V\cup T)^+$，且$\alpha$中至少有$V$中的一个元素出现，$\beta\in (V\cup T)^ { * }$。其中$\alpha$被称为产生式$\alpha\rightarrow\beta$的 &lt;strong&gt;左部&lt;/strong&gt; ，而$\beta$称为产生式$\alpha\rightarrow\beta$的 &lt;strong&gt;右部&lt;/strong&gt; 。产生式也被称为定义式或者语法规则。&lt;/p&gt;
&lt;p&gt;$S\in V$被称作$G$的 &lt;strong&gt;开始符号（start symbol）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;可以说文法的形式定义实际上给出了语言描述的一种模型。&lt;/p&gt;
&lt;p&gt;为了方便描述，对于拥有相同左部的产生式$\alpha\rightarrow\beta_1,\alpha\rightarrow\beta_2,\cdots,\alpha\rightarrow\beta_n$，可以用更加简便的方式去描述它，写作$\alpha\rightarrow\beta_1|\beta_2|\cdots|\beta_n$，其中的$\beta_1,\cdots,\beta_n$被称作 &lt;strong&gt;候选式（candidate）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;对于文法$G=(V,T,P,S)$，如果$\alpha\rightarrow\beta\in P,\gamma,\delta\in(V\cup T)^{ * }$，则称$\gamma\alpha\delta$在$G$中直接推导出$\gamma\beta\delta$，记作$\gamma\alpha\delta\Rightarrow_G\gamma\beta\delta$，读作$\gamma\alpha\delta$在文法$G$中直接推导出$\gamma\beta\delta$，可以简称直接推导为 &lt;strong&gt;推导（derivation）&lt;/strong&gt; ，有时候也称作 &lt;strong&gt;派生&lt;/strong&gt; 。与之对应的，也有 &lt;strong&gt;归约（reduction）&lt;/strong&gt; 的概念，即指$\gamma\beta\delta$在文法$G$中直接归约成$\gamma\alpha\delta$，这是因为有产生式$\alpha\rightarrow\beta$。&lt;/p&gt;
&lt;p&gt;很明显$\Rightarrow_G$是$(V\cup T)^{ * }$上的一个二元关系，那么可以对其作集合的相关运算，为了方便，我们用$\Rightarrow^+_G$表示正闭包$(\Rightarrow_G)^+$，用$\Rightarrow^ { * }_G$表示克林闭包$(\Rightarrow_G) ^ { * }$，用$\Rightarrow^n_G$表示幂运算$(\Rightarrow_G)^n$。在意义清楚的情况下也可以简写成$\Rightarrow,\Rightarrow^+,\Rightarrow^ { * },\Rightarrow^n$。类似的，对于归约的过程可以记作$\mapsto$表示，也有类似的简写记号。&lt;/p&gt;
&lt;p&gt;从二元关系的合成的意义上来看，不难看出：&lt;/p&gt;
&lt;p&gt;$\alpha\Rightarrow^n\beta$表示$\beta$在$G$中经过$n$步推导出$\beta$，也就是说存在$\alpha_1,\alpha_2,\cdots,\alpha_{n-1}\in(V\cup T)^{ * }$使得$\alpha\Rightarrow\alpha_1\Rightarrow\alpha_2\Rightarrow\cdots\Rightarrow\alpha_{n-1}\Rightarrow\beta$（这里是一种简写的表示，也可以称这样一个替换序列为 &lt;strong&gt;派生(derivation)&lt;/strong&gt; ），对于归约而言也有相应的含义。当$n=0$时也就是说有$\alpha=\beta$。&lt;/p&gt;
&lt;p&gt;$\alpha\Rightarrow^ +\beta$表示$\beta$在$G$中经过至少$1$步推导出$\beta$，对于归约而言也有相应的含义。&lt;/p&gt;
&lt;p&gt;$\alpha\Rightarrow^ { * }\beta$表示$\beta$在$G$中经过若干步推导出$\beta$，对于归约而言也有相应的含义。&lt;/p&gt;
&lt;p&gt;现在给出一个文法的案例以供理解：&lt;/p&gt;
&lt;p&gt;设有文法$G=(${$S,A,B$}$,${$0,1$},{$S\rightarrow A|AB,A\rightarrow 0|0A,B\rightarrow 1|11,S$}$)$，那么$S$在$G$中可以推导出$00011$：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$S\Rightarrow AB$，使用产生式$S\rightarrow AB$&lt;/li&gt;
&lt;li&gt;$AB\Rightarrow 0AB$，使用产生式$A\rightarrow 0A$&lt;/li&gt;
&lt;li&gt;$0AB\Rightarrow 00AB$，使用产生式$A\rightarrow 0A$&lt;/li&gt;
&lt;li&gt;$00AB\Rightarrow 000B$，使用产生式$A\rightarrow 0$&lt;/li&gt;
&lt;li&gt;$000B\Rightarrow 00011$，使用产生式$B\rightarrow 11$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;上文使用文法得到了一个句子，这说明文法可以用于产生语言，现在给出定义：&lt;/p&gt;
&lt;p&gt;设有文法$G=(V,T,P,S)$，则称$L(G)=${$w|w\in T^ { * },S\Rightarrow^{ * }w$}为$G$产生的 &lt;strong&gt;语言&lt;/strong&gt; ，$\forall w\in L(G),w$称为$G$产生的一个 &lt;strong&gt;句子（sentence）&lt;/strong&gt; 。而对于$\forall\alpha\in(V\cup T)^{ * }$，如果有$S\Rightarrow^ { * }$，那么称$\alpha$是$G$产生的一个 &lt;strong&gt;句型（sentential form）&lt;/strong&gt; 。不难发现句子不能含有语法变量，而句型可以含有语法变量。&lt;/p&gt;
&lt;p&gt;关于文法也可以由此引入 &lt;strong&gt;等价（equivalence）&lt;/strong&gt; 的概念，也就是说对于文法$G_1,G_2$，如果有$L(G_1)=L(G_2)$，那么称它们等价。&lt;/p&gt;
&lt;p&gt;上面的这个案例文法所产生的语言$L(G)=L(0^ { * }(\epsilon+1+11))$（这里使用了正则表达式），也就是说$L(G)$是一个$RL$，但不能说文法产生的语言都是$RL$，很容易可以举出文法$G=(${$A$},{$0,1$},{$A\rightarrow 01|0A1$}$,A)$，它所产生的语言是{$0^n1^n|n\geq 1$}，根据正则语言的泵引理，可以发现它不是一个$RL$，为了更好地分析形式文法，可以引入文法的 &lt;strong&gt;乔姆斯基体系（Chomsky hierarchy）&lt;/strong&gt; 。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;乔姆斯基体系&#34;&gt;乔姆斯基体系
&lt;/h3&gt;&lt;p&gt;设有文法$G=(V,T,P,S)$，那么有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$G$被称为 &lt;strong&gt;0型文法（type 0 grammar）&lt;/strong&gt; ，或者 &lt;strong&gt;短语结构文法（phrase structure grammar,PSG）&lt;/strong&gt; 。对应地，$L(G)$也被称为 &lt;strong&gt;0型语言&lt;/strong&gt; 或者 &lt;strong&gt;短语结构语言（PSL）&lt;/strong&gt; 、 &lt;strong&gt;递归可枚举集（recursively enumerable set,r.e.）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;如果对于$\forall\alpha\rightarrow\beta\in P$，均有$|\beta|\geq|\alpha|$成立，则称$G$为 &lt;strong&gt;1型文法（type 1 grammar）&lt;/strong&gt; ，或者 &lt;strong&gt;上下文有关文法（context sensitive grammar,CSG）&lt;/strong&gt; 。对应地，$L(G)$也被称为 &lt;strong&gt;1型语言（type 1 language）&lt;/strong&gt; 或者 &lt;strong&gt;上下文有关语言（context sensitive language,CSL）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;如果对于$\forall\alpha\rightarrow\beta\in P$，均有$|\beta|\geq|\alpha|$，并且有$\alpha\in V$成立，则称$G$为 &lt;strong&gt;2型文法（type 2 grammar）&lt;/strong&gt; ，或者 &lt;strong&gt;上下文无关文法（context free grammar,CFG）&lt;/strong&gt; 。对应地，$L(G)$也被称为 &lt;strong&gt;2型语言（type 2 language）&lt;/strong&gt; 或者 &lt;strong&gt;上下文无关语言（context free language,CFL）&lt;/strong&gt; 。&lt;/li&gt;
&lt;li&gt;如果对于$\forall\alpha\rightarrow\beta\in P$，$\alpha\rightarrow\beta$均有形式$A\rightarrow w,A\rightarrow wB$，这里的$A\rightarrow wB$也可以都换成$A\rightarrow Bw$的形式（符合前者的被称为 &lt;strong&gt;右线性文法（right liner grammar）&lt;/strong&gt; ，符合后者的被称为 &lt;strong&gt;左线性文法（left liner grammar）&lt;/strong&gt; ，两者混用可以生成3型语言以外的语言），其中$A,B\in V,w\in T^ { + }$，则称$G$为 &lt;strong&gt;3型文法（type 3 grammar）&lt;/strong&gt; ，或者 &lt;strong&gt;正则文法（regular grammar,RG）&lt;/strong&gt; 、 &lt;strong&gt;正规文法&lt;/strong&gt; 。对应地，$L(G)$也被称为 &lt;strong&gt;3型语言（type 3 language）&lt;/strong&gt; ，而它产生的语言正好是 &lt;strong&gt;正则语言（regular language,RL）&lt;/strong&gt; ，或者称为 &lt;strong&gt;正规语言&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是先前已经定义RL是DFA识别的语言，为了解释这个矛盾，现在对这个事实进行证明：&lt;/p&gt;
&lt;p&gt;RL能被RG产生：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有$DFA$：$M=(Q,\Sigma,\delta,q_0,F)$，可以构造$G$使得它是一个RG且有$L(G)=L(M)-${$\epsilon$}，考虑$G=(Q,\Sigma,${$q\rightarrow ap| \delta(q,a)=p$}$\cup${$q\rightarrow a| \delta(q,a)=p\in F$}$)$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RG产生的语言是RL：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个RG：$G=(V,T,P,S)$，假设$Z\notin V$，它表示$FA$的终止状态，可以作一个$FA$：$M=(V\cup${$Z$}$,T,\delta,S,${$Z$}$)$，其中$\delta的$定义为：&lt;/p&gt;
&lt;p&gt;对于$\forall(A,a)\in V\times T$，如果$A\rightarrow a\in P$那么有$\delta(A,a)=${$B|A\rightarrow aB\in P$}$\cup${$Z$}；如果$A\rightarrow a\notin P$那么有$\delta(A,a)=${$B|A\rightarrow aB\in P$}。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综上所述，RG产生的语言就是RL。&lt;/p&gt;
&lt;p&gt;显然，按照PSG、CSG、CFG、RG的顺序一直往后，文法的限制条件也就越多，后面的文法类型中的文法一定也属于前面的文法类型，可以用韦恩图表示（部分语言类之间的关系在后文中将会进一步探究）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/1.png&#34;
	width=&#34;696&#34;
	height=&#34;402&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/1_hu2890162635644186955.png 480w, https://0x3a0x29.github.io/p/contextfree/1_hu367066596247872397.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;乔姆斯基体系&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;173&#34;
		data-flex-basis=&#34;415px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;前文中给出了两个文法，由定义可以知道它们分别为RG和CFG，现在给出其他两种类型的文法的例子：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$G=(${$S,A,B,C$},{$a,b,c$},{$S\rightarrow aBC|aSBC,CB\rightarrow BC,aB\rightarrow ab,bB\rightarrow bb,bC\rightarrow bc,cC\rightarrow cc$}$,S)$，这是一个CSG，可以证明$L(G)=${$a^nb^nc^n|n\geq 1$}。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;$G=(${$S$},{$0$},{$S\rightarrow ABC,ABC\rightarrow 0$}$,S)$，这是一个PSG，$L(G)=${$0$}，显而易见的可以构造出一个RG：$G&amp;rsquo;=(${$S$},{$0$},{$S\rightarrow 0$}$,S)$使得$L(G&amp;rsquo;)=${$0$}，也就是说不同类型的文法之间也可以等价。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;按照上述的对四种文法的定义，不难发现RG、CFG和CSG生成的语言都不含有$\epsilon$。为了方便研究，称形如$A\rightarrow\epsilon$的产生式为 &lt;strong&gt;空产生式&lt;/strong&gt; ，或者称为$\epsilon$产生式，在RG、CFG和CSG的限制中允许出现空产生式，这样就允许它们产生的语言中也含有$\epsilon$。&lt;/p&gt;
&lt;p&gt;在引入了空产生式的概念后，不难发现如果$L$是RL、CFL或者CSL，那么$L\cup${$\epsilon$}依旧是RL、CFL、CSL。同时如果$L$是RL、CFL或者CSL，那么$L-${$\epsilon$}依旧是RL、CFL、CSL。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;上下文无关文法&#34;&gt;上下文无关文法
&lt;/h2&gt;&lt;h3 id=&#34;上下文无关文法的相关概念&#34;&gt;上下文无关文法的相关概念
&lt;/h3&gt;&lt;p&gt;上下文无关文法在程序设计语言的规范化及编译中有重要应用。程序设计语言的文法犹如外语语法参考书，设计人员在编写程序设计语言的编译器和解释器时，常需要先获取该语言的文法。大多数编译器和解释器都包含一个 &lt;strong&gt;语法分析器（parser）&lt;/strong&gt; ，它在生成编译代码或解释程序执行前，提取出程序的语义。上下文无关语言使得构造语法分析器的工作变得容易，某些工具甚至能根据文法自动地生成语法分析器。&lt;/p&gt;
&lt;p&gt;CFL之所以被称作上下文无关，是指在文法派生的每一步$\alpha A\beta\Rightarrow\alpha\gamma\beta$中$\gamma$仅根据$A$的产生式派生，而无需依赖$A$的上下文$\alpha$和$\beta$。&lt;/p&gt;
&lt;p&gt;为了更好地理解CFL，首先给出一个CFG的例子：&lt;/p&gt;
&lt;p&gt;有文法$G=(${$A,B$},{$0,1,$#},{$A\rightarrow 0A1|B,B\rightarrow$#}$)$，它生成字符串$0000$#$111$的派生过程如下：&lt;/p&gt;
&lt;p&gt;$A\Rightarrow 0A1\Rightarrow 00A11\Rightarrow 000A111\Rightarrow 000B111\Rightarrow 000$#$111$，为了生动形象地描述派生过程，可以使用 &lt;strong&gt;语法分析树（parse tree）&lt;/strong&gt; ，这样便可以从树中看出整个派生过程和最终产生的字符串：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/2.png&#34;
	width=&#34;436&#34;
	height=&#34;360&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/2_hu17124414190849649853.png 480w, https://0x3a0x29.github.io/p/contextfree/2_hu11409195392724358550.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;对应的语法分析树&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;121&#34;
		data-flex-basis=&#34;290px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;现在给出语法分析树的形式化定义，对于一个CFG：$G=(V,T,P,S)$而言，它的语法分析树是这样的一棵树：它的每一个内节点的标记是$V$中的变元符号；每一个叶节点的标记是$V\cup T\cup${$\epsilon$}中的符号；如果内结点的标记是$A$，它的子节点从左至右分别为$X_1,X_2,\cdots,X_n$，那么$A\rightarrow X_1X_2\cdots X_n$肯定是$P$的一个产生式，如果某个$X_i$是$\epsilon$，那么$X_i$一定是$A$唯一的子节点，且$A\rightarrow\epsilon$是一个产生式。&lt;/p&gt;
&lt;p&gt;将语法分析树的全部叶节点从左到右连接起来，称为该树的 &lt;strong&gt;产物（yield）&lt;/strong&gt; 或结果。如果树根节点是初始符号$S$，叶节点是终结符，显然该树的产物属于$L(G)$。&lt;/p&gt;
&lt;p&gt;语法分析树种标记为$A$的内节点及其全部子孙节点构成的子树，称为$A$子树。&lt;/p&gt;
&lt;p&gt;利用数学归纳法可以证明这样一个定理：设有CFG：$G=(V,T,P,S)$且$A\in V$，那么文法$G$中有$A\Rightarrow^{ * }$当且仅当在文法$G$中存在以$A$为根节点、产物为$\alpha$的语法分析树。&lt;/p&gt;
&lt;p&gt;有时候在一个文法中能够用多种不同的方式产生出同一个字符串，在此提供一个案例：&lt;/p&gt;
&lt;p&gt;设有文法$G_{exp}=(${$E,I$},{$a,b,+,* ,(,)$},{$E\rightarrow I|E+E|E *E|(E),I\rightarrow a$}$,E)$，这个文法可以用于生成一个含有加法和乘法的代数表达式。但是如果使用这个文法生成字符串$a+a *a$可以发现有多种派生：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/3.png&#34;
	width=&#34;1780&#34;
	height=&#34;824&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/3_hu11192200980409372488.png 480w, https://0x3a0x29.github.io/p/contextfree/3_hu1597969973713093379.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;同一个字符串的多种派生&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;216&#34;
		data-flex-basis=&#34;518px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;右边的派生很明显不符合数学运算的优先级要求，通过语法分析树可以很明显地看出在派生的过程中产生了歧义，为了形式化歧义的概念，首先给出最左派生的概念：&lt;/p&gt;
&lt;p&gt;对于文法$G$中的一个字符串$w$的派生，如果在每一步都是替换最左边剩下的变元，则称这个派生是 &lt;strong&gt;最左派生（leftmost derivation）&lt;/strong&gt; ，类似的也有最右派生。分别记为$\Rightarrow_{lm}^{ * },\Rightarrow_{rm}^{ * }$，显然任何派生都有等价的最左派生和最右派生，也就是说$A\Rightarrow^{ * }w$当且仅当$A\Rightarrow_{lm}^{ * }w$当且仅当$A\Rightarrow_{rm}^{ * }w$。&lt;/p&gt;
&lt;p&gt;结合先前介绍的语法分析树，实际上可以证明如果$\alpha$是某个CFG的句型，那么$\alpha$的派生树与最右派生和最左派生是一一对应的，但是这棵语法分析树可以对应多个不同的派生。&lt;/p&gt;
&lt;p&gt;现在给出歧义的形式概念：&lt;/p&gt;
&lt;p&gt;如果字符串$w$在上下文无关文法$G$中有两个或两个以上不同的最左派生，则称$G$ &lt;strong&gt;歧义地（ambiguously）&lt;/strong&gt; 产生字符串$w$，如果文法$G$歧义地产生某个字符串，则称$G$是 &lt;strong&gt;歧义的（ambiguous）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;上文作出的文法$G_{exp}$有两个不同的语法分析树，所以它是一个歧义的文法，但是实际上可以作出等价的非歧义文法，现在给出等价的非歧义文法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$G_{exp&amp;rsquo;}=(${$E,F,I,T$},{$a,b,+,* ,(,)$},{$E\rightarrow E+T|T,T\rightarrow T* F|F,F\rightarrow (E)|I,I\rightarrow a$}$,E)$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是并非是所有歧义文法都能找到等价的非歧义文法，这样的文法被称为是&lt;strong&gt;固有歧义的（inherently ambiguous）&lt;/strong&gt; 。例如{$a^ib^jc^k|i=j或j=k且i,j,k\geq 0$}便是固有歧义的，在后文会对这一定理进行证明。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;cfg的化简&#34;&gt;CFG的化简
&lt;/h3&gt;&lt;p&gt;在构造CFG的过程中，有时由于某种原因，文法中出现的符号以及使用的产生式并不一定是恰当的，比如下列两个文法实际上是等价的：&lt;/p&gt;
&lt;p&gt;$G_1=(${$S,A,B,C,D,E$},{$0,1,2,$&lt;em&gt;},{$S\rightarrow 0|0A|E,A\rightarrow\epsilon|0A|1A|B,B\rightarrow $&lt;/em&gt;$ C,C\rightarrow 0|1|0C|1C,D\rightarrow 1|1D|2D,E\rightarrow 0E2|E02$}$,S)$&lt;/p&gt;
&lt;p&gt;$G_2=(${$S,A,C$},{$0,1,$&lt;em&gt;},{$S\rightarrow 0|0A,A\rightarrow 0|1|0A|1A|$&lt;/em&gt;$ C,C\rightarrow 0|1|0C|1C$}$,S)$&lt;/p&gt;
&lt;p&gt;为了便于便于分析和解决问题，以不改变语言为前提，化简文法和限制文法的格式，现在介绍化简上下文无关语言的三个组成部分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;消除无用符号（useless symbols）：对文法定义的语言没有贡献的符号（不出现在任何由开始符号在任何由开始符号推导出一个终结符串的过程中的变元或终结符）&lt;/li&gt;
&lt;li&gt;消除$\epsilon$产生式：也就是消除$A\rightarrow\epsilon$，这样得到的语言将会是$L-${$\epsilon$}&lt;/li&gt;
&lt;li&gt;消除单元产生式（unit productions）：$A\rightarrow B$，其中$A$和$B$都是变量。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于CFG：$G=(V,T,P,S),X\in V\cup T$：&lt;/p&gt;
&lt;p&gt;如果$S\Rightarrow^{ * }\alpha X\beta$，则称$X$是可达的（reachable）。&lt;/p&gt;
&lt;p&gt;如果$X\Rightarrow^{ * }w,w\in T^{ * }$，称$X$是产生的（generating）。&lt;/p&gt;
&lt;p&gt;如果$X$同时是产生的和可达的，也就是说$S\Rightarrow^{ * }\alpha X\beta\Rightarrow^{ * }w,w\in T^{ * }$，则称$X$是有用的，否则称$X$为无用符号。&lt;/p&gt;
&lt;p&gt;存在一种方法得到产生的符号的集合和可达的符号的集合：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;产生的：每一个$T$中的符号都是产生的；如果$A\rightarrow\alpha\in P$且$\alpha$中的符号都是产生的，那么$A$也是产生的。&lt;/li&gt;
&lt;li&gt;可达的：$S$是可达的；如果$A\rightarrow\alpha\in P$且$A$是可达的，则$\alpha$中的符号都是可达的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;结论是显然的，在此不作证明。在得到了这两个集合后删掉全部含有“非产生的”和“非可达的”符号的产生式即可。&lt;/p&gt;
&lt;p&gt;可以证明，每一个非空的CFL都可以用一个不带无用符号的CFG定义。&lt;/p&gt;
&lt;p&gt;注意：在消除无用符号的过程中要先寻找并消除全部非“产生的”符号，再寻找并消除全部非“可达的”符号，否则可能会出现消除不完整的情况，下面给出一个例子：&lt;/p&gt;
&lt;p&gt;设有文法$G=(${$S,A,B$},{$a,b$},{$S\rightarrow AB|a,A\rightarrow b$}$,S)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先消除非可达的：可达的符号集为{$S,A,B,a,b$}，故无消除符号。&lt;/li&gt;
&lt;li&gt;再消除非产生的：产生的符号集为{$a,b,S,A$}，消除$B$得到$G&amp;rsquo;=(${$S,A,B$},{$a,b$},{$S\rightarrow a,A\rightarrow b$}$,S)$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;显然依旧存在无用符号。&lt;/p&gt;
&lt;p&gt;如果按照相反的顺序可以发现不会存在无用符号：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;先消除非产生的：产生的符号集为${a,b,S,A}$，消除$B$得到$P={S\rightarrow a,A\rightarrow b}$。&lt;/li&gt;
&lt;li&gt;再消除非可达的：可达的符号集为${S,a}$，消除${b,A}$得到$P={S\rightarrow a}$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;实际上可以证明先消除全部非“产生的”符号，再寻找并消除全部非“可达的”符号可以得到不存在无用符号的文法，在此不作证明。&lt;/p&gt;
&lt;p&gt;如果变元$A$满足$A\Rightarrow^{ * }\epsilon$，则称$A$是可空的。现在给出一个确定可空变量的方法：&lt;/p&gt;
&lt;p&gt;如果$A\rightarrow\epsilon\in P$，那么$A$是可空的；如果$B\rightarrow\alpha\in P$且$\alpha$中的每一个符号都是可空的，则$B$是可空的。&lt;/p&gt;
&lt;p&gt;在确定了可空变量后，给出一种替代方案：&lt;/p&gt;
&lt;p&gt;将含有可空变量的一条产生式$A\rightarrow X_1X_2\cdots X_n$用一组产生式$A\rightarrow Y_1Y_2\cdots Y_n$代替，其中：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;若$X_i$不是可空的，那么$Y_i$为$X_i$。&lt;/li&gt;
&lt;li&gt;若$X_i$是可空的，$Y_i$为$X_i$或者$\epsilon$（也就是说对于每一个可空变量，它可以出现或不出现在替换后的产生式中）。&lt;/li&gt;
&lt;li&gt;但是不能出现$Y_i$全为$\epsilon$的情况。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;满足这样的替代方案的情况下，再消除文法中的$\epsilon$产生式，便可以得到语言$L-${$\epsilon$}，下面给出一个例子作为说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有文法$G=(${$S,A,B$},{$a,b$},{$S\rightarrow AB,A\rightarrow AaA|\epsilon,B\rightarrow BbB|\epsilon$}$)$。&lt;/p&gt;
&lt;p&gt;首先可以确定可空的变量是{$S,A,B$}。&lt;/p&gt;
&lt;p&gt;替换全部带有可空变量的表达式：$S\rightarrow AB$替换成$S\rightarrow AB|A|B$，$A\rightarrow AaA|\epsilon$替换成$A\rightarrow AaA|Aa|aA|a$，$B\rightarrow BbB|\epsilon$替换成$B\rightarrow BbB|Bb|bB|b$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果两个变量满足$A\Rightarrow^{ * }B$，则称$[A,B]$为单元对，现在给出一种确定单元对的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;如果$A\rightarrow B\in P$，则$[A,B]$是单元对。&lt;/li&gt;
&lt;li&gt;如果$[A,B],[B,C]$都是单元对，那么$[A,C]$也是单元对。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;消除单元产生式的过程要求删除全部形如$A\rightarrow B$的单元产生式，并且对每一个单元对$[A,B]$，将$B$的产生式的右部复制给$A$作为产生式。&lt;/p&gt;
&lt;p&gt;下面给出一个例子作为说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有文法$G=(${$S,A,B$},{$0,1$},{$S\rightarrow A|B|0S1,A\rightarrow 0A|0.B\rightarrow 1B|1$}$,S)$&lt;/p&gt;
&lt;p&gt;确定单元产生式：$S\rightarrow A,S\rightarrow B$，非单元产生式$S\rightarrow 0S1.A\rightarrow 0A|0,B\rightarrow 1B|1$。&lt;/p&gt;
&lt;p&gt;将单元产生式代入非单元产生式：$A\rightarrow 0A|0$代入$S\rightarrow A$得到$S\rightarrow 0A|0$，$B\rightarrow 1B|1$代入$S\rightarrow B$得到$S\rightarrow 1B|1$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以证明化简CFG有一个可靠的顺序是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;消除$\epsilon$产生式。&lt;/li&gt;
&lt;li&gt;消除单元产生式。&lt;/li&gt;
&lt;li&gt;消除非产生的无用符号。&lt;/li&gt;
&lt;li&gt;消除非可达的无用符号。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是说每一个不带$\epsilon$的CFL都可以由一个不带无用符号、$\epsilon$产生式和单元产生式的文法来定义，在此不对这一定理进行证明。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;乔姆斯基范式和格雷巴赫范式&#34;&gt;乔姆斯基范式和格雷巴赫范式
&lt;/h3&gt;&lt;p&gt;不难发现，RG是相当规范的，CFG的形式相较于RG而言并没有这样规范，在完成了对CFG的化简后，还需要进一步找到与之等价的规范文法，这里将要介绍两种规范的文法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;乔姆斯基范式（Chomsky normal form,CNF）&lt;/strong&gt; ：一个CFG：$G=(V,T,P,S)$的每一个产生式的形式都为$A\rightarrow BC$或$A\rightarrow a$，其中$A,B,C\in V,a\in T$。不难发现利用CNF派生长度为$m$的字符串，刚好需要$m+(m-1)=2m-1$步。&lt;/p&gt;
&lt;p&gt;现在给出将一个不带$\epsilon$的CFG转换成CNF的方法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先前已经介绍了如何得到不带无用符号、$\epsilon$产生式和单元产生式的CFG的方法，这里已经事先进行了化简。&lt;/p&gt;
&lt;p&gt;考虑文法中每一个形式为$A\rightarrow X_1X_2\cdots X_m,m\geq 2$的产生式，若$X_i$为终结符$a$，则引进新变量$C_a$替换$X_i$并增加新产生式$C_a\rightarrow a$。&lt;/p&gt;
&lt;p&gt;现在需要进行替换的产生式的形式将会变为$A\rightarrow B_1B_2\cdots B_m,m\geq 3$和$B_i\rightarrow a$。&lt;/p&gt;
&lt;p&gt;对于$A\rightarrow B_1B_2\cdots B_m,m\geq 3$，可以引入新变量$D_1,D_2,\cdots,D_{m-2}$将其替换成一组产生式$A\rightarrow B_1D_1,D_1\rightarrow B_2D_2,\cdots,D_{m-2}\rightarrow B_{m-1}B_m$，这样就把CFG变成了CNF的形式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在这里给出一个例子以供理解：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有CFG：$G=(${$S,A,B$},{$a,b$}$,P,S)$，其中$P=${$S\rightarrow bA|aB,A\rightarrow bAA|aS|a,B\rightarrow aBB|bS|b$}，可以得到与其等价的CNF：$G&amp;rsquo;=(${$S,A,B,D_a,C_b,D_1,D_2$},{$a,b$}$,P&amp;rsquo;,S)$，其中$P&amp;rsquo;=${$S\rightarrow C_bA|C_aB,A\rightarrow C_bD_1|C_aS|a,B\rightarrow C_aD_2|C_bS|b,D_1\rightarrow AA,D_2\rightarrow BB,C_a\rightarrow a,C_b\rightarrow b$}。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;格雷巴赫范式（Greibach normal form,GNF）&lt;/strong&gt; ：一个CFG：$G=(V,T,P,S)$的每一个产生式的形式都为$A\rightarrow a\alpha$，其中$A\in V,a\in T,\alpha\in V^{ * }$。不难发现GNF每个产生式都会引入一个终结符，利用GNF派生长度为$m$的字符串，刚好需要$m$步。&lt;/p&gt;
&lt;p&gt;先前已经证明了不带$\epsilon$的CFG可以转换成CNF，作出与CNF等价的GNF是非常简单的，在此不作说明。也就是说由一个不带$\epsilon$的CFG可以转换成GNF。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;下推自动机&#34;&gt;下推自动机
&lt;/h2&gt;&lt;h3 id=&#34;下推自动机的引入&#34;&gt;下推自动机的引入
&lt;/h3&gt;&lt;p&gt;先前已经介绍了FA，它识别的语言是RL，有着重要的作用，但是在现实中存在着不少只使用FA无法解决的问题，考虑这样一个问题：&lt;/p&gt;
&lt;p&gt;括号匹配问题：要求设计一台自动机识别字母表为$(,),[,],{,}的字符串，当它是合法的括号匹配的时候就接受这个字符串，例如[&lt;a class=&#34;link&#34; href=&#34;%7b%7d&#34; &gt;&lt;/a&gt;[]]就是一个合法的括号匹配，而[(])是一个非法的括号匹配。&lt;/p&gt;
&lt;p&gt;但是使用FA是没有办法解决这个问题的，设这个语言是$L_1$，考虑语言$L_2={(^{ * })^{ * }}$，可知$L_1\cap L_2=${$(^n)^n|n\geq 0$}，利用正则语言的泵引理可以知道它不是一个RL，所以无法设计一个FA满足问题需求。&lt;/p&gt;
&lt;p&gt;在现实中很容易使用C语言编写程序解决这个问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdlib.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;stdbool.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;string.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#define MaxSize 100 &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//定义栈中元素最大个数
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MaxSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//初始化栈
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;InitStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//判断栈是否为空
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IsEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//新元素入栈
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MaxSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;栈已满&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//栈已满
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//栈顶元素出栈，用x返回
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;栈已满&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;//匹配算法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bracketCheck&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;SqStack&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;InitStack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//初始化栈
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;||&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;nf&#34;&gt;Push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//扫描到左括号就入栈
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)){&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//扫描到右括号，当前栈为空，即右括号单身情况
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//匹配失败
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;topElem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//用来保存弹出栈的栈顶元素
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nf&#34;&gt;Pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;topElem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//栈顶元素出栈
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;)&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;topElem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;(&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;}&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;topElem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;{&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;]&amp;#39;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;topElem&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;sc&#34;&gt;&amp;#39;[&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IsEmpty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;S&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MaxSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;请输入需要判断的括号：&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;scanf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;当前输入的括号个数为：%d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;--------现在开始进行判断--------&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;bracketCheck&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)){&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;匹配成功！&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		&lt;span class=&#34;nf&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;匹配失败！&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在上述的程序中，使用了 &lt;strong&gt;栈(stack)&lt;/strong&gt; 这一结构，如果给FA添加上一个栈会发生什么呢？这就引出了 &lt;strong&gt;下推自动机（pushdown automata,PDA）&lt;/strong&gt; 这一计算模型，相较于FA，它还有一个栈作为额外设备，栈在控制器的有限存储量之外提供了附加的存储，使得下推自动机能够识别某些非正则语言，实际上下推自动机在能力上和CFG是等价的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/4.png&#34;
	width=&#34;1006&#34;
	height=&#34;356&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/4_hu3570547193532784126.png 480w, https://0x3a0x29.github.io/p/contextfree/4_hu8882670659221237458.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PDA的示意图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;282&#34;
		data-flex-basis=&#34;678px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;简单地说，下推自动机可以看成是$\epsilon-NFA$和栈的结合，它的下一步动作由三个要素决定：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;当前$\epsilon-NFA$的状态&lt;/li&gt;
&lt;li&gt;当前的输入符号（或者是$\epsilon$）&lt;/li&gt;
&lt;li&gt;当前的栈顶符号&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$\epsilon-NFA$有着有限状态、非确定性、空转移的性质；栈是一种先进后出（First In Last Out,FILO）的结构，在这里只使用栈顶且栈的长度是无限的，栈有两种操作：弹栈（Pop）也就是仅弹出栈顶的一个符号，压栈（Push）也就是压入一串符号。&lt;/p&gt;
&lt;p&gt;运转过程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;控制器从输入带读入一个符号$a$，控制栈弹出一个栈顶符号$Z$。&lt;/p&gt;
&lt;p&gt;根据符号$a,Z$和当前所处的状态进行状态的转移并对栈压入$0$个符号（也就相当于是Pop）或者压入一个符号串（也就相当于是Push）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;下推自动机的形式化定义&#34;&gt;下推自动机的形式化定义
&lt;/h3&gt;&lt;p&gt;现在给出PDA的形式化定义：&lt;/p&gt;
&lt;p&gt;下推自动机$P$是一个七元组$(Q,\Sigma,\delta,q_0,Z_0,F)$，其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$Q$是有穷状态集，相应的有状态的概念。&lt;/li&gt;
&lt;li&gt;$\Sigma$是有穷输入符号集（input alphabet），要求$M$的输入字符串都是$\Sigma$上的字符串，常使用小写字母表示输入的字符串。&lt;/li&gt;
&lt;li&gt;$\Gamma$是有穷栈符号集（stack alphabet），里面的符号被称为栈符号（stack symbols），常使用大写字母表示栈中的符号，用希腊字母表示栈字符串。&lt;/li&gt;
&lt;li&gt;$\delta:Q\times(\Sigma\cup{\epsilon})\times\Gamma\rightarrow 2^{Q\times\Gamma^{ * }}$是状态转移函数。可知对于$(q,a,X)\in Q\times(\Sigma\cup\epsilon)\times\Gamma,\delta(q,a,X)={(p_1,\gamma_1),(p_2,\gamma_2),\cdots,(p_m,\gamma_m)}$，根据当前的$a$和$X$，可以将当前状态由$q$转移到$p_1$，再用$\gamma_1$代替栈顶的$X$。如果$\gamma_1=\epsilon$则弹出$X$，如果$\gamma_1=\epsilon$则弹出$X$，如果$\gamma_1=X$那么栈顶符号依旧为$X$，如果$\gamma_1=Z_1Z_2\cdots Z_k$那么弹出$X$再依次压入$Z_k,Z_{k-1},\cdots,Z_1$。&lt;/li&gt;
&lt;li&gt;$_0\in Q$是初始状态。&lt;/li&gt;
&lt;li&gt;$Z_0\in\Gamma$是初始栈底符号（start stack symbol），是中国自动机启动的时候栈内唯一的一个符号，用来标志栈底。&lt;/li&gt;
&lt;li&gt;$F\subseteq Q$是接受状态集。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也可以使用状态转移图来表示PDA：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/5.png&#34;
	width=&#34;1450&#34;
	height=&#34;394&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/5_hu13930472457247230954.png 480w, https://0x3a0x29.github.io/p/contextfree/5_hu13825988648906875471.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;PDA的状态转移图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;368&#34;
		data-flex-basis=&#34;883px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由正则语言的泵引理可知{$0^n1^n|n\geq 1$}不能被FA识别，但是可以构造一个PDA识别它：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/6.png&#34;
	width=&#34;1186&#34;
	height=&#34;304&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/6_hu14152425805684415861.png 480w, https://0x3a0x29.github.io/p/contextfree/6_hu3919661708708313443.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;能识别这个语言的PDA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;390&#34;
		data-flex-basis=&#34;936px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为了方便说明，现在引入一些概念：&lt;/p&gt;
&lt;p&gt;设有PDA：$M=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，$\forall(q,w,\gamma)\in Q\times\Sigma^{ * }\times\Gamma^{ * }$称为是$M$的一个 &lt;strong&gt;即时描述（instantaneous descriptin,ID）&lt;/strong&gt; 。它表示：$M$处于状态$q$；$w$是剩余的未处理的输入字符串，而且此时$M$正在注视$w$的首字符；栈中的符号串为$\gamma$，$\gamma$的最左符号为栈顶符号，越靠右越在栈的较下面。&lt;/p&gt;
&lt;p&gt;在PDA的一个动作下，会发生从ID$\ I$到ID$\ J$的变化，称之为ID的转移。&lt;/p&gt;
&lt;p&gt;具体的，如果$(p,\beta)\in\delta(q,a,Z)$，由$(q,aw,Z\alpha)$到$(p,w,\beta\alpha)$的变化称为ID的转移$\vdash_P$，在不引发混淆的情况下可以记作$\vdash$，这样ID的转移就可以写为$(q,aw,Z\alpha)\vdash(p,w,\beta\alpha)$，这是一个二元关系，相应地也可以作出它的克林闭包，为了方便，使用$I\vdash^{ * }J$表示$I(\vdash)^{ * }J$&lt;/p&gt;
&lt;p&gt;显然在PDA的ID的转移过程中可以会存在多条转移路径，但是最终只有一条正确的路径可以进入接受状态。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;pda接受的语言&#34;&gt;PDA接受的语言
&lt;/h3&gt;&lt;p&gt;下推自动机接受一个语言有着不同的方式，现在对此进行介绍：&lt;/p&gt;
&lt;p&gt;设有PDA：$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，要求$F\neq\varnothing$，称通过终态方式接受的语言$L(P)=${$w|(q_0,w,Z_0)\vdash^{ * }(p,\epsilon,\gamma),p\in F$}，即能够使PDA到达终态的符号串的集合。&lt;/p&gt;
&lt;p&gt;设有PDA：$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，要求$F=\varnothing$，称通过空栈方式接受的语言$N(P)=${$w|(q_0,w,Z_0)\vdash^{ * }(p,\epsilon,\epsilon)$}，即能够使PDA的栈变空的符号串的集合。&lt;/p&gt;
&lt;p&gt;现在证明这两种接受方式的下推自动机是可以相互转换的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先证明对于任意PDA$\ M_1$，存在PDA$\ M_2$使得$N(M_2)=L(M_1)$：&lt;/p&gt;
&lt;p&gt;设有PDA$\ M_1=(Q,\Sigma,\Gamma,\delta_1,q_{01},Z_{01},F)$，考虑构造PDA$\ M_2=(Q\cup${$q_{02},q_e$}$,\Sigma,\Gamma\cup${$Z_{02}$}$,\delta,q_{02},Z_{02},F)$，其中要求$Q\cap{q_{02},q_e}=\Gamma\cap${$Z_{02}$}$=\varnothing$，而具体地，$\delta_2$的定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在$M_2$启动后立马进入$M_1$的初始ID，也就是说$\delta_2(q_{02},\epsilon,Z_{02})={q_{01},Z_{01}Z_{02}}$。&lt;/li&gt;
&lt;li&gt;让$M_2$完全模拟$M_1$的非空移动：$\forall (q,a,Z)\in Q\times\Sigma\times\Gamma$有$\delta_2(q,a,Z)=\delta_1(q,a,Z)$。&lt;/li&gt;
&lt;li&gt;当$M_2$在非终止状态下完全模拟$M_1$的空移动：$\forall (q,Z)\in(Q-F)\times\Gamma$有$\delta_2(q,\epsilon,Z)=\delta_1(q,\epsilon,Z)$。&lt;/li&gt;
&lt;li&gt;在$M_1$的终止状态下，$M_2$除了模拟$M_1$的空移动外，还需要模拟$M_1$的“接受动作”，由于在此动作后栈可能不是空的，进入清栈状态：$\forall(q,Z)\in F\times\Gamma,\delta_2(q,\epsilon,Z)=\delta_1(q,\epsilon,Z)\cup${$(q_e,\epsilon)$}。&lt;/li&gt;
&lt;li&gt;$M_1$的栈已空，并且已经进入了终止状态，所以$M_2$进入清栈状态$q_e$并将栈清空：$\forall q\in F,\delta_2(q,\epsilon,Z_{02})\rightarrow${$(q_e,\epsilon)$}。&lt;/li&gt;
&lt;li&gt;$M_2$进行清栈工作：$\forall Z\in\Gamma\cup${$Z_{02}$}$,\delta_2(q_e,\epsilon)=${$(q_e,\epsilon)$}。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再证明对于任意PDA$\ M_1$，存在PDA$\ M_2$使得$L(M_2)=N(M_1)$：&lt;/p&gt;
&lt;p&gt;设有PDA$\ M_1=(Q,\Sigma,\Gamma,\delta_1,q_{01},Z_{01},F)$，考虑构造PDA$\ M_2=(Q\cup${$q_{02},q_f$}$,\Sigma,\Gamma\cup${$Z_{02}$}$,\delta,q_{02},Z_{02},${$q_{02}$}$)$，其中要求$Q\cap${$q_{02},q_e$}$=\Gamma\cap${$Z_{02}$}$=\varnothing$，而具体地，$\delta_2$的定义如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在$M_2$启动后立马进入$M_1$的初始ID，也就是说$\delta_2(q_{02},\epsilon,Z_{02})={q_{01},Z_{01}Z_{02}}$。&lt;/li&gt;
&lt;li&gt;让$M_2$完全模拟$M_1$的移动：$\forall(q,a,Z)\in Q\times(\Sigma\cup${$\epsilon$}$)\times\Gamma$有$\delta_2(q,a,Z)=\delta_1(q,a,Z)$。&lt;/li&gt;
&lt;li&gt;当$M_1$的栈已空时，$M_2$的栈底符号成为栈中唯一的符号。因此要让$M_2$进入终止状态：$\delta_2(q,\epsilon,Z_{02})=${$(q_f,\epsilon)$}。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;pda与cfg的等价性&#34;&gt;PDA与CFG的等价性
&lt;/h3&gt;&lt;p&gt;实际上PDA和CFG是等价的，现在对这一定理作出证明。&lt;/p&gt;
&lt;p&gt;对于任何CFL$\ L$，一定存在PDA$\ P$使$L=N(P)$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：对于一个CFG$\ G=(V,T,P&amp;rsquo;,S)$，可以构造这样的PDA$\ P_N=(${$q$}$,T,V\cup T,\delta,q,S,\varnothing)$，其中对于$\forall A\in V,\delta(q,\epsilon,A)=${$(q,\beta)|A\rightarrow\beta\in P&amp;rsquo;$}，对于$\forall a\in T,\delta(q,a,a)=${$(q,\epsilon)$}。&lt;/p&gt;
&lt;p&gt;可以证明$S\Rightarrow^{ * }\Leftrightarrow(q,w,S)\vdash^{ * }(q,\epsilon,\epsilon)$，也就是说$L(G)=N(P)$，在此不作详细证明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于任何PDA$\ P$，一定存在CFL$ L$使$L=L(P)$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：了方便讨论，通过添加中间状态很容易对$P$作出修改使得$P$有唯一的接受状态$q_{accept}$，在$P$接受的时候空栈，每一个转移把一个符号压入栈或者把一个符号弹出栈，但是不能同时做出这两个动作。&lt;/p&gt;
&lt;p&gt;为了找到生成$L$的文法$G$，先考虑设置这样的变量$A_{pq}$，它能产生所有能够让$P$从ID$(p,aw,Z_0)$转移到ID$(q,w,Z_0)$的字符串$a$，这样的字符串自然在栈中还有其他内容的时候也能让$P$实现从状态$p$到状态$q$的转移。&lt;/p&gt;
&lt;p&gt;为了知道$A_{pq}$的产生式，首先要考虑它所产生的字符串$x$输入$P$后它所执行的动作。&lt;/p&gt;
&lt;p&gt;可以知道$P$对$x$的第一个动作一定是压栈、最后一个动作一定是弹栈，那么$P$输入$x$后有两种情况：仅在运算开始和结束的时候$P$存在栈空的情况，在计算的中间过程中存在栈空的情况，很容易想到两个产生式用来模拟这两种情况：$A_{pq}\rightarrow aA_{rs}b$，其中$a,b$就是在开头和结束时读到的输入符号，$r$是紧跟$p$的状态、$s$是$q$前面的那个状态；$A_{pq}\rightarrow A_{pr}A_{rs}$，其中$r$就是中间过程中栈空的状态。下面给出具体的构造方式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设$P=(Q,\Sigma,\Gamma,\delta,q_0,${$q_{accept}$}$)$，那么可以构造CFG：$G=(${$A_{pq}|p,q\in Q$}$,\Sigma,P&amp;rsquo;,A_{q_0,q_{accept}})$,其中$P&amp;rsquo;$满足以下要求：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;对于$\forall p,q,r,s\in Q,\ u\in\Gamma,\ a,b\in\Sigma\cup${$\epsilon$}，如果$(r,s)\in\delta(p,a\epsilon),(q,\epsilon)\in\delta(s,b,u)$，那么$A_{pq}\rightarrow aA_{rs}b\in P&amp;rsquo;$。&lt;/li&gt;
&lt;li&gt;对于$\forall p,q,r\in Q$，有$A_{pq}\rightarrow A_{pr}A_{rq}\in P&amp;rsquo;$。&lt;/li&gt;
&lt;li&gt;对于$\forall p\in Q$，有$A_{pp}\rightarrow\epsilon$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/7.png&#34;
	width=&#34;1200&#34;
	height=&#34;362&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/7_hu7399858537133768089.png 480w, https://0x3a0x29.github.io/p/contextfree/7_hu15453047067267196336.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;第一种情况下的PDA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;331&#34;
		data-flex-basis=&#34;795px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/8.png&#34;
	width=&#34;1188&#34;
	height=&#34;370&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/8_hu1535525838431436785.png 480w, https://0x3a0x29.github.io/p/contextfree/8_hu7532487774693242291.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;第二种情况下的PDA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;321&#34;
		data-flex-basis=&#34;770px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以证明$A_{pq}$产生$x$当且仅当$x$能够让$P$从ID$(p,xw,Z_0)$转移到ID$(q,w,Z_0)$，也就是说对于任何PDA$\ P$，一定存在CFL$ L$使$L=L(P)$，在此不作详细的证明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综上所述：PDA和CFG是等价的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;cfl的性质&#34;&gt;CFL的性质
&lt;/h2&gt;&lt;h3 id=&#34;cfl的泵引理&#34;&gt;CFL的泵引理
&lt;/h3&gt;&lt;p&gt;按照先前对乔姆斯基文法体系的介绍可以知道，CFL是CSL的子类，但是不能证明CFL是CSL的真子类。为此需要找到一个语言并且判定它属于CSL而不属于CFL。为了确定一个语言是否不属于某个语言类，很容易想到之前介绍的RL的泵引理，而实际上也有CFL的泵引理，类似于RL的泵引理，它也可以对字符串进行“抽取”而保证字符串在语言当中：&lt;/p&gt;
&lt;p&gt;对于任意CFL：$L$，存在仅仅依赖于$L$的正整数$N$（一样也称其为是泵长度），对于$\forall z\in L$，只要$|z|\geq N$时就可以将其分为五部分$z=uvwxy$，满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$|vwx|\leq N$&lt;/li&gt;
&lt;li&gt;$|vx|&amp;gt;0$&lt;/li&gt;
&lt;li&gt;$\forall i\geq 0,uv^iwx^iy\in L$&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设CFG：$G=(V,T,P,S)$是接受$L-${$\epsilon$}的CNF，那么在文法$G$的派生树中，如果最长路径为$k$，那么派生出的句子的长度最多为$2^{k-1}$，取$N=2^m,m=|V|$，那么若有$z\in L(G),|z|\geq G$，则$z$的派生树中最长路径长度至少也是$m+1$，同时在这条路径上至少有$m+2$个节点，这条路径经过了$m+1$个内节点，也就是至少有两个节点标记了相同的变量，不妨设这两个节点是$v_1,v_2$，其中前者比后者更加解决树根，以$v_1$为根的子树为$T_1$，以$v_2$为根的子树为$T_2$，设$T_2$的产物是$w$，由于$T_2$是$T_1$的子树，不妨设$T_1$的产物$Z_1=vwx$，那么有$A\Rightarrow^{ * }vAx$和$A\Rightarrow^{ * }w$，也就是说$\forall i\geq 0,A\Rightarrow^{ * }v^iwx^i$，不妨设整棵树的产物$z=uvwxy$，那么有$S\Rightarrow^{ * } uAy\Rightarrow^{ * }uv^iwx^iy\in L$，又知道$T_1$的路径长度不超过$m+1$，也就是说$|vwx|\leq 2^m=N$，最后$T_2$一定处在$B$的树或者$C$的树中，但是$B$和$C$至少产生了一个终结符（这个文法是CNF），也就有$|vx|&amp;gt;0$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/9.png&#34;
	width=&#34;1289&#34;
	height=&#34;584&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/9_hu13190843807581119432.png 480w, https://0x3a0x29.github.io/p/contextfree/9_hu3423653494825139261.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;文法G的派生树&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;220&#34;
		data-flex-basis=&#34;529px&#34;
	
&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个有趣的事实是，泵引理其实还可以加强，只要取更大的$N=2^{2m}$，也就是说在它的最长路径上有三个节点标记了相同的变量，利用这三个节点对整个派生树进行划分，通过恰当的选取$u,v,w,x,y$就可以让泵引理的第二个条件更改为$v\neq\epsilon,x\neq\epsilon$。这样就得到了”加强“的泵引理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文给出了一个CSG：$G=(${$S,A,B,C$},{$a,b,c$},{$S\rightarrow aBC|aSBC,CB\rightarrow BC,aB\rightarrow ab,bB\rightarrow bb,bC\rightarrow bc,cC\rightarrow cc$}$,S)$，它生成的语言$L(G)=${$a^nb^nc^n|n\geq 1$}，利用泵引理可以证明它不是CFL，也就是说CFL类是CSL类的真子类。&lt;/p&gt;
&lt;p&gt;前文中提到了一个固有歧义的CFL：$A=${$a^ib^jc^k|i=j或j=k\ i,j,k\geq 0$}，在介绍了CFL的泵引理后，现在可以对这一定理进行证明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：一个文法$G$生成了这个语言$A$，$p$是仅依赖于$G$的泵长度，令$k=p!=p(p-1)(p-2)\cdots 1,s=a^kb^kc^k$，现在尝试证明$s$始终有两棵不同的派生树。&lt;/p&gt;
&lt;p&gt;令$s_1=a^kb^pc^p,s_2=a^pb^pc^k$，它们是$A$中的字符串，生成它们的派生树是$T_1,T_2$，先考虑$T_1$：&lt;/p&gt;
&lt;p&gt;考虑将$T_1$中子节点中叶节点只包含$a$的节点去除，现在证明这样得到的子树必然是只有$2p$个叶子节点的树，而不包含任何$a$作为叶节点：因为$p+p&amp;gt;p$，所以这个子树中有一条路径经过了重复的变量$R$，可以用变量$R$将字符串分成$s=uvxyz$，并且有$|vxy|\leq p$，所以$v$和$y$都只能包含一种字符，否则$uv^2xy^2z\notin A$。同时$y$不可能包含$a$，因为$R$在一条能够生成$a$或$b$或$c$的路径上。因此$v$必须是$b$的字符串、$y$必须是$c$的字符串，并且它们有相同的长度$l$，考虑字符串$vu^dxy^d,d=\frac{k}{l}$，那么这样的字符串的派生树便是要求的子树。
$T_2$也可以同样证明类似的事实，这就说明$s$有两棵不同的派生树，那么生成$A$的文法$G$必须是歧义的文法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CFL的泵引理只是CFL的必要条件，一个满足CFL的泵引理的语言也可能不是CFL，可以找到这样一个语言$F=${$a^ib^jc^kd^m|i,j,k,m\geq 0且当i=1时有j=k=m$}，可以构造$L=${$ab^ic^jd^k|i,j,k\geq 0$}，只是一个RL，可知$F\cap L=${$ab^ic^id^i|i\geq 0$}，在后文中会证明一个定理：一个CFL和RL的交是CFL，也就是说如果$F$是CFL，那么$F\cap L$也是CFL，而根据泵引理它显然不是CFL，故而$F$并不是CFL。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;ogden引理&#34;&gt;Ogden引理
&lt;/h3&gt;&lt;p&gt;有的时候在使用CFL的泵引理时，希望在$v,x$中至少有一个含有某一个“感兴趣”的字符$a$，称这样的字符为&lt;strong&gt;特异点（distinguished position）&lt;/strong&gt; ，为了实现这样的想法，引入Ogden引理：&lt;/p&gt;
&lt;p&gt;对于任意CFL$\ L$，存在仅仅依赖于$L$的正整数$N$，对于任意$z\in L$，当$z$中至少含有$N$的特异点时，存在$u,v,w,x,y$使得$z=uvwxy$，并且有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$|vwx|$中特异点的个数小于或等于$N$&lt;/li&gt;
&lt;li&gt;$|vx|$中特异点的个数大于或等于$1$&lt;/li&gt;
&lt;li&gt;$\forall i\geq 0,uv^iwx^iy\in L$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;证明：设有CFL$\ L$且有$\epsilon\notin L$，从而存在CNF：$G=(V,T,P,S)$使得$L=L(G)$，取$N=2^{|V|}+1$，设$z\in L$，并且$z$中的特异点个数不少于$N$。定义$z$的语法分析树中这样的非叶子节点为 &lt;strong&gt;分支点（branch point）&lt;/strong&gt; ：两个儿子的后代均有特异点的节点。&lt;/p&gt;
&lt;p&gt;现在构造一条从根节点到叶节点的路径$p$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将根结点放入路径中&lt;/li&gt;
&lt;li&gt;如果路径上的最后一个点只有一个儿子的后代中有特异点，则将这个儿子放入路径&lt;/li&gt;
&lt;li&gt;如果路径上的最后一个点的两个儿子的后代中都有特异点，则将特异点多的那个儿子放入路径（相等则任取一个）&lt;/li&gt;
&lt;li&gt;直到将叶子放入路径为止&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然$p$中至少含有$|V|+1$个分支点，至少有两个不同的分支点标记了相同的变量，选取两个距离叶节点最近的节点$v_1,v_2$并且前者是后者的祖先节点，类似于泵引理证明那样，这两个节点将派生的句子$z$分成了$z=uvwxy$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意到路径$p$在$v_1$子树部分所含的分支点的个数小于或等于$|V|+1$，所以$v_1$的结果$vwx$所含的特异点最多为$N$个。再注意到$v_1$是分支点，并且$v_2$是它的后代之一，所以$vx$中至少有一个特异点。那么有$S\Rightarrow^{ * }uAy\Rightarrow^{ + }uvAxy\Rightarrow^{ + }uvwxy$，显然$\forall i\geq 0,S\Rightarrow^{ * }uAy\Rightarrow^{ + }uv^iAx^iy\Rightarrow^{ + }uv^iwx^iy$，也就是说$\forall i\geq 0,uv^iwx^iy\in L$。&lt;/p&gt;
&lt;p&gt;证毕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;读者可以尝试使用Ogden引理证明之前提到的语言是固有歧义语言。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;cfl的封闭性&#34;&gt;CFL的封闭性
&lt;/h3&gt;&lt;p&gt;为了方便研究CFL类的封闭性问题，先证明CFL类对部分代换的封闭性：&lt;/p&gt;
&lt;p&gt;如果有$\Sigma$上的CFL：$L$和代换$s$，且每个$a\in\Sigma$的$s(a)$都是CFL，那么$s(L)$也是CFL。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$L=L(G),G=(V,T,P,S)$，每一个$s(a)$的文法$G_a=(V_a,T_a,P_a,S_a)$，那么$s(L)$的文法可以构造为$G&amp;rsquo;=(V\cup(\cup_{a\in T}V_a),\cup_{a\in T}T_a,P&amp;rsquo;,S)$，其中$P&amp;rsquo;$包含每一个$P_a$中的产生式和$P$的产生式（但是要替换产生式中的每一个终结符$a$为$S_a$），可以证明$s(L)=L(G&amp;rsquo;)$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明了这一定理后，可以进一步证明CFL类对并、连接、克林闭包、正闭包、同态运算是封闭的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$\Sigma={1,2},L_1,L_2$为任意CFL，定义代换$s(1)=L_1,s(2)=L_2$，那么{$1,2$},{$12$},$1^{ * }$和$1^{ + }$显然是CFL，那么就有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$s(${$1,2$}$)=s(1)\cup s(2)=L_1\cup L_2$，所以并运算封闭。&lt;/li&gt;
&lt;li&gt;$s(${$12$}$)=s(12)=s(1)s(2)=L_1L_2$，所以连接运算封闭。&lt;/li&gt;
&lt;li&gt;$s(1^{ * })=s(${$\epsilon,1,11,\cdots$}$)=s(\epsilon)\cup s(1)\cup s(11)\cup\cdots=s(\epsilon)\cup s(1)\cup s(1)s(1)\cup\cdots=${$\epsilon$}$\cup L_1\cup L_1L_1\cup\cdots=L_1^{ * }$，所以克林闭包运算封闭。&lt;/li&gt;
&lt;li&gt;$s(1^{ + })=s(${$1,11,\cdots$}$)=s(1)\cup s(11)\cup\cdots=s(1)\cup s(1)s(1)\cup\cdots=L_1\cup L_1L_1\cup\cdots=L_1^{ + }$，所以正闭包运算封闭。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;也可以通过构造相应的文法来证明CFL类对并/连接/闭包/反转运算的封闭性：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设CFL$\ L_1,L_2$的文法分别为$G_1=(V_1,T_1,P_1,S_1),G_2=(V_2,T_2,P_2,S_2)$，那么可以构造文法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$G_{union}=(V_1\cup V_2\cup${$S$}$,T_1\cup T_2,P_1\cup P_2\cup${$S\rightarrow S_1|S_2$}$,S)$，则$L(G_{union})=L_1\cup L_2$。&lt;/li&gt;
&lt;li&gt;$G_{concat}=(V_1\cup V_2\cup${$S$}$,T_1\cup T_2,P_1\cup P_2\cup${$S\rightarrow S_1S_2$}$,S)$，则$L(G_{concat})=L_1L_2$。&lt;/li&gt;
&lt;li&gt;$G_{closure}=(V_1\cup${$S$}$,T_1,P_1\cup${$S\rightarrow S_1S|\epsilon$}$,S)$，则$L(G_{closure})=L_1^{ * }$。&lt;/li&gt;
&lt;li&gt;$G_R=(V,T,${$A\rightarrow\alpha^R|A\rightarrow\alpha\in P$}$,S)$，则$L(G_R)=L^R$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;CFL类对同态运算封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：若$h$是$\Sigma$上的同态，$L$是$\Sigma$上的CFL，对于$\forall a\in\Sigma$，令代换$s&amp;rsquo;(a)=${$h(a)$}，则$h(L)=${$h(w)|w\in L$}$=\cup_{w\in L}${$h(w)$}$=\cup_{w\in L}s&amp;rsquo;(w)=s&amp;rsquo;(L)$，所以同态运算封闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;CFL类对逆同态运算封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：如果$L$是字母表$\Delta$上的CFL，$h$是字母表$\Sigma$到$\Delta^{ * }$的同态，那么$h^{-1}(L)$也是CFL。&lt;/p&gt;
&lt;p&gt;设有PDA：$P=(Q,\Delta,\Gamma,\delta,q_0,Z_0,F),L(P)=L$，可以构造PDA满足$L(P&amp;rsquo;)=h^{-1}(L)$，在构造中可以利用设置状态以模拟缓冲（Buffer）用于暂存字符$a\in\Sigma$的同态串$h(a)$：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/10.png&#34;
	width=&#34;1686&#34;
	height=&#34;650&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/10_hu11422500207659730231.png 480w, https://0x3a0x29.github.io/p/contextfree/10_hu6332686783380977023.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;对应的PDA构造&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;259&#34;
		data-flex-basis=&#34;622px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以构造这样的PDA：$P&amp;rsquo;=(Q&amp;rsquo;,\Sigma,\Gamma,\delta&amp;rsquo;,[q_0,\epsilon],Z_0,F\times${$\epsilon$}$)$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$Q&amp;rsquo;$中的状态为$[q,x],q\in Q$，即$P$的状态和缓冲中还未被消耗的串$x$，也即某个$h(a)$的后缀。&lt;/li&gt;
&lt;li&gt;设$q\in Q$，那么$\forall [q,\epsilon]\in Q\times${$\epsilon$}$,\forall a\in\Sigma,\forall X\in\Gamma,\delta&amp;rsquo;([q,\epsilon],a,X)=${$([q,h(a)],X)$}，也就是将$h(a)$装载到缓冲中的过程。&lt;/li&gt;
&lt;li&gt;模拟$P$处理在缓冲中储存的$h(a)$的过程：$\forall b\in\Delta\cup${$\epsilon$}，如果有$\delta(q,b,X)=${$(p_1,\beta_1),\cdots,(p_k,\beta_k)$}，则有$\delta&amp;rsquo;([q,bx],\epsilon,X)=${$([p_1,x],\beta_1),\cdots,([p_k,x],\beta_k)$}，这里的$x$是某个$h(a)$的后缀。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和RL类不同，CFL类在交运算下不是封闭的，证明如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：考虑$L_1={0^n1^n2^i|i,n\geq 1}$，$L_2={0^i1^n2^n|i,n\geq 1}$，它们显然是CFL，但是$L_1\cap L_2={0^n1^n2^n|n\geq 1}$，这不是一个CFL，同样地CFL类在补运算下也不封闭（考虑$L_1\cap L_2=\overline{\overline{L_1}\cup\overline{L_2}}$）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是如果$L$是CFL且$R$是正则语言，则$L\cap R$是CFL，证明如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有DFA：$D=(Q_1,\Sigma,\delta_1,q_1,F_1)$和PDA：$P=(Q_2,\Sigma,\Gamma,\delta_2,q_2,Z_0,F_2)$，同时有$L(D)=R,L(P)=L$，那么可以构造接受$L\cap R$的PDA：$P&amp;rsquo;=(Q_1\times Q_2,\Sigma,\Gamma,\delta,(q_1,q_2),Z_0,F_1\times F_2)$，其中$\delta$满足下列条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\delta((p,q),a,Z)={((p,s),\beta)|(s,\beta)\in\delta_2(q,a,Z)}$，若有$a=\epsilon$。&lt;/li&gt;
&lt;li&gt;$\delta((p,q),a,Z)={((r,s),\beta)|r=\delta_1(p,a)且(s,\beta)\in\delta_2(q,a,Z)}$，若有$a\neq\epsilon$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;cfl的判定性质&#34;&gt;CFL的判定性质
&lt;/h3&gt;&lt;p&gt;关于CFL的判定性质，在此进行简单的说明：&lt;/p&gt;
&lt;p&gt;判定一个CFL是否为空就是看生成它的文法的起始符号是否为无用符号，如果起始符号为无用符号，那么语言为空。&lt;/p&gt;
&lt;p&gt;判定一个CFL是否为无穷语言，先作出CFL$\ L$对应的文法$G=(V,T,P,S)$，并且去除$G$的无用符号，再用一张有向图来表示$G$，其中图的顶点为$G$中的变量，如果$A\rightarrow B\in P$，那么在图中增加一条从$A$到$B$的边，图的源点为$S$，如果图中存在可以从源点出发到达的环，那么这个CFL是一个无穷语言。&lt;/p&gt;
&lt;p&gt;判定一个字符串是否属于CFL可以使用CYK算法，在这里不对CYK算法进行说明。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;确定性上下文无关语言&#34;&gt;确定性上下文无关语言
&lt;/h2&gt;&lt;h3 id=&#34;确定性下推自动机的形式化定义&#34;&gt;确定性下推自动机的形式化定义
&lt;/h3&gt;&lt;p&gt;在程序设计语言编译器中要设计语法分析器，而通常来说，与CFL相比，对 &lt;strong&gt;确定型上下文无关语言（Deterministic context free languague,DCFL）&lt;/strong&gt; 进行语法分析要更加容易，能够被 &lt;strong&gt;确定性下推自动机（Deterministic pushdown automata,DPDA）&lt;/strong&gt; 识别的语言就是DCFL，构造DPDA也就要在PDA的基础上遵循确定性的基本原则：在计算的每一步，根据其转移函数，DPDA只有一种继续的方式，但是定义DPDA比定义DFA更加复杂，因为DPDA可能在不弹出栈符号的情况下读入输入符号，反之也是这样。同样在DPDA的转移函数中存在$\epsilon$-转移：$\epsilon$-输入转移（$\epsilon$-in-put move）对应于$\delta(q,\epsilon,x)$，$\epsilon$-栈转移（$\epsilon$-stack move）对应于$\delta(q,a,\epsilon)$，当然也允许$\delta(q,\epsilon,\epsilon)$。但是一台DPDA不能同时做出多个动作，现在给出DPDA的形式化定义：&lt;/p&gt;
&lt;p&gt;DPDA是一个七元组$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，它在满足PDA的形式化定义的前提下还要求满足下列条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于$\forall q\in Q,a\in\Sigma\cup${$\epsilon$}$,x\in\Gamma,\delta(q,a,x)$至多只能含有一个元素。&lt;/li&gt;
&lt;li&gt;对于$\forall q\in Q,x\in\Gamma$，如果有$\delta(q,\epsilon,x)\neq\varnothing$，那么对于$\forall a\in\Sigma$都有$\delta(q,a,x)=\varnothing$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DPDA接受一个语言有两种标准：以空栈形式接受和以最终状态接受，这两种方式接受的语言都是非固有歧义的CFL，但是并非所有非固有歧义的CFL都可以被DPDA接受，例如$L(G)$，其中$G=${{$S$},{$0,1$},{$S\rightarrow 0S0|1S1|\epsilon$}$,S$}。&lt;/p&gt;
&lt;p&gt;不同于PDA，对于DPDA而言这两种接受方式是不等价的（以空栈形式接受的语言是以最终状态接受的并且满足无前缀性质的语言），故而使用最终状态作为接受标准来定义DCFL。&lt;/p&gt;
&lt;p&gt;如果DPDA在读入字符串的最后一个符号后进入接受状态则接受这个字符串，在其他任何情况下都拒绝这个字符串，也就意味着有两种情况会发生拒绝：要么DPDA读完了全部输入但是无法进入接受状态，要么DPDA没有成功读完全部输入字符串。&lt;/p&gt;
&lt;p&gt;两种特殊情况会导致DPDA无法成功读完全部输入字符串：DPDA试图弹出空栈（hanging）和DPDA执行无尽的$\epsilon$-转移序列，通过对DPDA进行适当的修改，可以让可能发生这两种情况的DPDA都转为能够读完整个输入字符串的等价DPDA。&lt;/p&gt;
&lt;p&gt;为了简化讨论，可以将一个特定标记符号$\dashv$放到输入字符串的末尾，称其为 &lt;strong&gt;输入结束标记（endmarked input）&lt;/strong&gt; ，可以证明添加这一个标记不会改变DPDA的能力（也就是说接受的语言依旧是DCFL），然而这为简化设计DPDA提供了帮助，使用结束标记语言$A\dashv$表示字符串$w\dashv,w\in A$的集合。&lt;/p&gt;
&lt;p&gt;很容易构造出DPDA接受语言{$0^n1^n|n\geq 0$}，也就是说RL类是DCFL类的真子类。但是现在还无法判断DCFL类是否是CFL类的真子类，为此不妨考虑DCFL的封闭性，现在说明DCFL对运算的封闭性。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dcfl的封闭性&#34;&gt;DCFL的封闭性
&lt;/h3&gt;&lt;p&gt;DCFL类在补运算下封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：简单地类比DFA交换接受状态和非接受状态的证明是错误的，因为在输入字符串的末端，DPDA进入转移序列的接受和非接受状态都可能接受输入，在这种情况下，交换接受状态和非接受状态依旧会发生接受。不妨将DPDA：$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$修改为总是读入全部输入字符串、同时一旦进入一个接受状态它将会停留在接受状态直到读入下一个输入符号。现在给出一种可行的构造：如果DPDA读入字符并且没有弹栈（$\delta(q,a,\epsilon)\neq\varnothing$），可以称这样一个状态$q$是一个“读入状态”，倘若弹栈了，也就是说$\delta(q,a,x)=(r,w_1w_2\cdots w_n)$，那么不妨新增状态并修改$\delta$使得$\delta(q,\epsilon,x)=\delta(q_{w_1},\epsilon),\delta(q_{w_1},\epsilon)=(q_{w_2},w_1),\cdots,\delta(q_{w_n},\epsilon)=(r,w_n)$，那么认定$q_{w_1},q_{w_2},\cdots,q_{w_n}$都是“读入状态”，如果又有$q\in F$，则认定它们都是接受状态。最后从所有非读入状态中移除接受状态的认定，这样再将接受状态和非接受状态互换就可以得到接受DCFL的补的DPDA。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个事实说明一些CFL并不是DCFL，如果CFL的补不是一个CFL，那么它就不是一个DCFL，例如$A=${$a^ib^jc^k|i,j,k\geq 0,i\neq j或j\neq k$}便不是一个DCFL但它是一个CFL，否则$\overline{A}\cap${$a^ib^jc^k|a,b,c\geq 0$}={$a^nb^nc^n|n\geq 0$}将是一个CFL。&lt;/p&gt;
&lt;p&gt;DCFL类在并运算下不封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：可以构造$L_1=${$a^ib^c^k|i,j,k\geq 0且i\neq j$}$,L_2=${$a^ib^jc^k|i,j,k\geq 0且j\neq k$}，可以构造DPDA识别这两个语言，故而它们都是DCFL，但是有$L_1\cup L_2=${$a^ib^jc^k|i,j,k\geq 0,i\neq j或j\neq k$}，在先前已经证明了它不是一个DCFL，故DCFL类在并运算下不封闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DCFL类在交运算下不封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：考虑$L_1\cup L_2=\overline{(\overline{L_1}\cap\overline{L_2})}$，由于DCFL类在补运算下封闭、在并运算下封闭，所以DCFL类在交运算下不封闭。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然DCFL类在交运算下不封闭，但是类似于CFL类，DCFL与RL的交是一个DCFL，证明如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：考虑有DFA：$D=(Q_1,\Sigma_1,\delta_1,q_{s1},F_1)$和DPDA：$P=(Q_2,\Sigma,\Gamma,\delta_2,q_{s2},Z_0,F_2)$，那么可以构造DPDA：$P&amp;rsquo;=(Q_1\times Q_2,\Sigma,\Gamma,\delta_3,(q_{s1},q_{s2}),Z_0,F_1\times F_2)$，其中$\delta_3$为$(Q_1\times Q_2)\times\Sigma\times\Gamma\rightarrow(Q_1\times Q_2)\times\Gamma^{ * }$的函数，并且满足$\forall q_1\in Q_1,\forall q_2\in Q_2,\delta_3((q_1,q_2),a,b)=(\delta_1(q_1,a),\delta_2(q_2,a,b))$，这样一个DPDA识别的语言是$L_1\cap L_2$，也就说明DCFL与RL的交是一个DCFL。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DCFL类在连接运算下不封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$L_1=${$a^ib^jc^k|i,j,l\geq 0,i\neq j$},$L_2=${$a^ib^jc^k|i,j,k\geq 0,i\neq k$},$L_3=({d}L_1)\cup L_2$，很容易构造识别$L_3$的DPDA，也就是说$L_3$是DCFL，已知$d^{ * }$为DCFL，不妨设DCFL类在连接运算下封闭，也就是说$d^{ * }L_3$是DCFL，已知$L_4=${$da^ib^jc^k|i,j,k\geq 0$}，它是一个RL，也就是说$d^{ * }L_3\cap L_4$是一个DCFL，但是有$d^{ * }L_3\cap L_4=dL_1\cup dL_2=d(L_1\cup L_2)$，$L_1\cup L_2$不是DCFL，显然$d(L_1\cup L_2)$不是DCFL，矛盾，得证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DCFL类在克林闭包运算下不封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$L_1=${$a^ib^jc^k|i,j,l\geq 0,i\neq j$},$L_2=${$a^ib^jc^k|i,j,k\geq 0,i\neq k$},$L_3={$d$}\cup${$d$}$L_1\cup L_2$，考虑$L_3^{ * }\cap${$d^{ * }$}$(${$a^{ * }$}{$b^{ * }$}{$c^{ * }$}-{$\epsilon$}$)=${$d$}$(L_1\cup L_2)$，如果DCFL类在克林闭包运算下封闭，则导出矛盾，得证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DCFL类在反转运算下不封闭。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$L_1=(a+b+c)^{ * }wcw^R,L_2=wcw^R(a+b+c)^{ * },w\in(a+b)^{ + }$，前者不是DCFL，但是反转后得到后者却是DCFL，得证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;确定性上下文无关文法&#34;&gt;确定性上下文无关文法
&lt;/h3&gt;&lt;p&gt;在先前的分析中，多考虑的是派生的过程，而为了引出确定性上下文无关文法，要考虑的是归约的过程。&lt;/p&gt;
&lt;p&gt;对以$S$为起始变元的CFG，串$w$属于它的语言，设$w$的最左归约为：$w=u_1\mapsto u_2\mapsto\cdots\mapsto u_k=S$，如果要确保“确定性”，规定$u_i$决定了下一个步骤$u_{i+1}$，因此$w$决定了整个归约过程，但这只能说明无歧义，因而要进一步要求对于每一个$u_i$，下一个归约步骤必须由$u_i$的前缀唯一确定，且此前缀从头开始并且包含了归约步骤中的归约串（也就是被替换的串，reducing string）$h$。&lt;/p&gt;
&lt;p&gt;令$w$是属于CFG：$G$的一个字符串，$u_i$出现在$w$的最左归约中，在归约步骤$u_i\mapsto u_{i+1}$中称产生式$T\rightarrow h$被反向运用。也就是说可以记作$u_i=xhy,u_{i+1}=xTy$，其中$h$是归约串，$x$是$u_i$的一部分并且出现在$h$的左侧，$y$是$u_i$的一部分并且出现在$h$的右侧，也就是有$u_i=x_1\cdots x_jh_1\cdots h_jy_1\cdots y_l\mapsto x_1\cdots x_jTy_1\cdots y_l=u_{i+1}$，现在定义$h$和和它相关的产生式$T\rightarrow h$称为是$u_i$的一个 &lt;strong&gt;句柄（handle）&lt;/strong&gt; ，在不关注产生式的情况下也可以特指归约串，为方便起见，定义句柄的时候只需要考虑$L(G)$中的句子的最左归约，称归约过程中出现的字符串为 &lt;strong&gt;有效串（valid string）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;考虑文法$G_1=(${$R,S,T$},{$a,b$},{$R\rightarrow S|T,S\rightarrow aSb|ab,T\rightarrow aTbb|abb$}$)$，很明显它识别的语言是$A\cup B,A=${$a^mb^m|m\geq 1$}$,B=${$a^mb^{2m}|m\geq 1$}，很容易利用PDA的不确定性来识别$L(G_1)$，它将会猜测输入是$B$中的字符串亦或者是$C$中的字符串，它在将$a$压入栈中后将弹出句柄并尝试用句柄匹配$b$或者$bb$。但是对于DPDA而言它不能预先知道输入属于哪个集合，自然不知道如何匹配句柄，实际上可以证明$L(G_1)$不是DCFL。&lt;/p&gt;
&lt;p&gt;从这样一个例子可以发现句柄起着非常重要的作用，为了让DCFG和DPDA相对应，自然要对句柄作出限制。某个串可能有多个句柄的歧义性语法，选择一个特定的句柄可能需要预先知道语法分析树产生了这个串，以及那些对于DPDA一定是无法获得的信息。很明显DCFG理应是非歧义性的，因而句柄是独一无二的，然而独一无二的句柄并不够定义DCFG，考虑刚刚定义的文法$G_1$产生的句子$aabb,aabbbb$，确定这样两个字符串的句柄还需要读完整个输入。&lt;/p&gt;
&lt;p&gt;所以要对句柄施加一个额外的要求：一个有效串的初始部分必须足以决定句柄，也就是说读入有效串的过程中一旦读入了句柄就可以确定获得了句柄，因此，在每一个有效串$xh\hat{y},\hat{y}\in\Sigma^{ * }$中$h$是独一无二的句柄时，那么称$h$是有效串$v=xhy$的一个 &lt;strong&gt;强制句柄（forced handle）&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;现在可以给出DCFG的定义了： &lt;strong&gt;确定性上下文无关文法（deterministic context free grammar,DCFG）&lt;/strong&gt; 是能够让每一个有效串都有一个强制句柄的上下文无关文法。&lt;/p&gt;
&lt;p&gt;已经有了DCFG在数学上的精确定义，但是却无法判断一个CFG是否是DCFG，下文将提供一个能够准确实现整个目的的过程，称之为$DK$-测试，它依赖于一个简单但令人惊讶的定理：对于任意CFG：$G$都能够构造一个可以识别句柄的关联DFA：$DK$，如果满足以下条件，$DK$将接受它的输入：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$z$是某个有效串$v=zy$的前缀。&lt;/li&gt;
&lt;li&gt;$z$以$v$的一个句柄作为结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先考虑这样一个NFA：$J$，它接受每一个以任何产生式的右部作为结束的输入串，构造$J$是相当容易的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$J$将猜测哪个产生式可以适用，也能猜测从何处开始将输入和产生式的右部相匹配，随着匹配输入，$J$通过已经选好的产生式的右部来追踪它的进程，在这个产生式的右部的对应位置放置句点以表示这个进程，称为&lt;strong&gt;加点规则（dotted rule）&lt;/strong&gt;/项（item），对于$B\rightarrow u_1u_2\cdots u_k$将会产生$k+1$个加点规则：$B\rightarrow.u_1u_2\cdots u_k,B\rightarrow u_1.u_2\cdots u_k,B\rightarrow u_1u_2\cdots.u_k,B\rightarrow u_1u_2\cdots u_k.$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每一个加点规则都对应于$J$的一个状态，句点到产生式末尾时称为是&lt;strong&gt;完整规则（completed rule）&lt;/strong&gt;，它对应着$J$的接受状态，它没有向外的转换。&lt;/p&gt;
&lt;p&gt;对于每一个规则$B\rightarrow u$，为$B\rightarrow.u$添加一个单独的由所有符号的自循环构成的起始状态和从起始状态到这个状态的$\epsilon$-转移，这样便完成了$J$的构造。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;现在引入NFA：$K$，它以相似但简捷的方式选择匹配规则，只有可能的归约规则才会被允许。和$J$一样它的状态对应于所有加点规则，接受状态对应着完整规则，它没有向外的转换。它有一个特殊的起始状态$S_1$，该状态对所有包含起始变元$S_1$的规则来说都有到$S_1\rightarrow.u$的$\epsilon$-转移，$K$的转移函数$\delta$满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果有产生式$B\rightarrow uav$，那么{$B\rightarrow ua.v$}$\subseteq\delta(B\rightarrow u.av,a)$。&lt;/li&gt;
&lt;li&gt;如果有产生式$B\rightarrow uCv,C\rightarrow r$，那么{$C\rightarrow.r$}$\subseteq\delta(B\rightarrow u.Cv,\epsilon)$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以证明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在输入$z$上$K$可能进入状态$T\rightarrow u.v$当且仅当对于某些$y\in\Sigma^{ * },z=xu$且$xuvy$是一个句柄为$uv$、归约规则为$T\rightarrow uv$的有效串。也就是说在输入$z$上$K$可能进入接受状态$T\rightarrow h.$当且仅当$z=xh$且$h$是遵循归约规则$T\rightarrow h$的有效串$xhy$的一个句柄。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前已经证明了可以利用子集构造法的方式将一个NFA转换成DFA，现在用子集构造法将$K$转换成$DK$，每一个$DK$的状态包含若干个加点规则，每一个接受状态包含至少一个完整规则，上面的定理依旧可以被应用。现在给出$DK$-测试：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从一个CFG：$G$开始构造关联的DFA：$DK$，通过检查$DK$的接受状态，判定$G$是否是DCFG，通过$DK$-测试要求每一个接受状态包含：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;有且仅有一个完整规则。&lt;/li&gt;
&lt;li&gt;所有加点规则中句点不会紧跟着一个终结符，即没有形如$B\rightarrow u.av,a\in\Sigma^{ * }$的加点规则。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以证明$G$通过$DK$-测试当且仅当$G$是一个DCFG。&lt;/p&gt;
&lt;p&gt;在实际运用中直接构建$DK$会比事先构造$K$再将其转为NFA更快，下面给出对$G_1=(${$S,E,T$},{$a,+,\times,\dashv$},{$S\rightarrow E\dashv,E\rightarrow E+T|T,T\rightarrow T\times a|a$}$,S)$使用$DK$-测试的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/11.png&#34;
	width=&#34;1188&#34;
	height=&#34;498&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/11_hu13241582633909935294.png 480w, https://0x3a0x29.github.io/p/contextfree/11_hu1512996351287712187.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;G1的DK-测试&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;238&#34;
		data-flex-basis=&#34;572px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以看到左下侧和右上侧这两个接受状态不符合$DK$-测试的要求，也就是说这个文法不是DCFG。&lt;/p&gt;
&lt;p&gt;再对文法$G_2=${{$S,T$},{$\dashv,(,)$},{$S\rightarrow T\dashv,T\rightarrow T(T)|\epsilon$}$,S$}使用$DK$-测试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/12.png&#34;
	width=&#34;1182&#34;
	height=&#34;400&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/12_hu7535339384706616100.png 480w, https://0x3a0x29.github.io/p/contextfree/12_hu15196677391087125457.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;G2的DK-测试&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;295&#34;
		data-flex-basis=&#34;709px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这个文法对应的$DK$的所有接受状态都满足$DK$-测试的条件，也就是说这个文法是DCFG。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dpda和dcfg的等价性&#34;&gt;DPDA和DCFG的等价性
&lt;/h3&gt;&lt;p&gt;之前已经证明了结束标记不会影响DPDA识别的语言类，但是它会影响DCFG产生的语言类。如果没有结束标记，DCFG只会产生DCFL的一个子类————它们都是前缀无关的，值得注意的是所有结束标记语言都是前缀无关的。&lt;/p&gt;
&lt;p&gt;每一个DCFG都有一个等价的DPDA。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：考虑这样的$P$，它将利用之前构造的$DK$进行操作，对于从输入中所读取的符号，它模拟$DK$直到$DK$接受，$DK$的接受状态指明一个特定的加点规则，因为$G$是确定性的，并且这个规则为扩展了目前已知输入的有效串确定一个句柄。此外，因为$G$是确定性的，这个句柄适用于每一个有效扩展，特别地如果输入属于$L(G)$，那么这个句柄适用于对$P$的全部输入。所以$P$能使用这个句柄为它的输入串确定第一个归约步骤，尽管在此时它只是读入了它输入的一部分。为了让$P$执行接下来的归约步骤，可以在栈中存储所有$DK$的状态，当$P$读入一个输入符号并模拟一个在$DK$中的转移时，它通过将其压入栈来记录$DK$的状态。当其使用归约规则$T\rightarrow u$来执行一个归约步骤时，它从栈中弹出$|u|$个状态，展现在读入$u$之前$DK$的状态。它将$DK$重置为该状态，接下来在输入$T$上模拟$DK$，并将产生的状态压入栈，之后$P$像之前读取和处理输入符号那样继续进行。当$P$将起始变元压入栈时，表明它已经找到了一个输入到起始变元的归约，那么进入一个接受状态。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于每一个能够识别结束标记语言的DPDA都有一个等价的DCFG。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设DPDA：$P=(Q,\Sigma,\Gamma,\delta,q_0,Z_0,${$q_a$}$)$，构造CFG：$G$，其起始变元为$A_{q_0,q_a}$，其产生式按照以下规则产生：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于$\forall p,q,r,s,t\in Q,\forall u\in\Gamma,\forall a,b\in\Sigma_{\epsilon}$，如果$\delta(r,a,\epsilon)=(s,u)$且$\delta(t,b,u)=(q,\epsilon)$，则$A_{pq}\rightarrow A_{pr}aA_{st}b$是$G$的产生式。&lt;/li&gt;
&lt;li&gt;对于$\forall p\in Q$，$A_{pp}\rightarrow\epsilon$是$G$的产生式。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以证明如果$P$读入包含一个变量$A_{pq}$的$v_i$，那么它正好在读入$A_{pq}$之前进入状态$p$，从而可以证明$G$可以通过$DK$-测试，也就是说这样构造的CFG是一个DCFG。&lt;/p&gt;
&lt;p&gt;可以得到这样的结论：一个结束标记语言是DCFL当且仅当它可以由一个DCFG产生。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;lrk文法&#34;&gt;LR(k)文法
&lt;/h3&gt;&lt;p&gt;DCFG有时在表达特殊的DCFL时并不方便，其要求所有句柄都是强制句柄，这限制了设计直观的DCFG，解决这一问题可以考虑一个叫做LR(k)的宽泛文法类（首字母的缩略词表示Left to right input processing,Rightmost derivation），它和DCFG非常相似，都允许到DPDA的直接转变，这个文法的赛诺菲引入了前瞻性（lookahead），它的句柄也可能依赖于该句柄后的前$k$个符号。&lt;/p&gt;
&lt;p&gt;令$h$是有效串$v=xhy$的一个句柄，如果$h$对每一个有效串$x\hat{h}y$（$xh\hat{y}$满足$\hat{y}\in\Sigma^{ * }$且$y$和$\hat{y}$在它们的前$k$个符号上是一致的）来说是独一无二的句柄，那么称$h$是 &lt;strong&gt;被前瞻k所强制的（forced by lookahead k）&lt;/strong&gt; 。（如果其中某个串的长度小于$k$，那么一致的长度和这个短串的长度相同）&lt;/p&gt;
&lt;p&gt;现在给出对LR(k)文法的定义：LR(k)文法是一种每一个有效串的句柄都是被前瞻$k$所强制的上下文无关语法。&lt;/p&gt;
&lt;p&gt;LR(0)文法实际上就是DCFG，同时也能证明对于任何一个$k$，都能将文法LR(k)转换为DPDA，也就是说LR(k)文法对所有$k$和所有DCFL的准确描述在能力上是等价的。&lt;/p&gt;
&lt;p&gt;类似于DCFG，现在给出$DK_1$-测试（前瞻为1的$DK$-测试）的定义，先构造一个NFA：$K_1$并将其转换成DFA：$DK_1$。$K_1$的每一个状态是一个加点规则$T\rightarrow u.v$和称为 &lt;strong&gt;前瞻符号（lookahead symbol）&lt;/strong&gt; 的终结符$a$构成的二元组，这说明$K_1$最近读入了串$u$，如果$v$在$u$后出现并且$a$在$v$之后出现，那么$u$可能为句柄$uv$的一部分。&lt;/p&gt;
&lt;p&gt;对每一个包括起始变元$S_1$和所有$a\in\Sigma$的产生式，开始状态有个到$(S_1\rightarrow.u,a)$的$\epsilon$-转移，同样也有{$(T\rightarrow ux.v,a)$}$\subseteq\delta((T\rightarrow u.xv,a),x)$和{$(C\rightarrow.r,b)$}$\subseteq\delta((T\rightarrow u.Cv,a),\epsilon)$，这里的$b$是能从$v$中派生出来的任意终结符串的第一个符号。如果$v$派生出$\epsilon$，那么添加$b=a$。对完整规则$B\rightarrow u.$和$a\in\Sigma$，所有的接受状态都是$(B\rightarrow u.,a)$。&lt;/p&gt;
&lt;p&gt;令$R_1$是带前瞻符号$a_1$的完整规则，$R_2$是带前瞻符号$a_2$的加点规则，满足以下其中任意一个条件则称$R_1,R_2$是 &lt;strong&gt;一致的（consistent）&lt;/strong&gt; ，如果有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$R_2$是完整的且$a_1=a_2$。&lt;/li&gt;
&lt;li&gt;$R_2$不是完整的且$a_1$紧跟在句点后面。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么$DK_1$-测试就是将$K_1$转换成DFA并且要求每一个接受状态一定不包含任意两个一致的加点规则。可以证明文法$G$通过$DK_1$测试当且仅当$G$是一个LR(1)文法。考虑文法$G_1=(${$S,E,T$},{$a,+,\times,\dashv$},{$S\rightarrow E\dashv,E\rightarrow E+T|T,T\rightarrow T\times a|a$}$,S)$，对它使用$DK_1$-测试，那么有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/contextfree/13.png&#34;
	width=&#34;1172&#34;
	height=&#34;504&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/contextfree/13_hu18220713317754870802.png 480w, https://0x3a0x29.github.io/p/contextfree/13_hu10876213305414258798.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;G1的DK1-测试&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;232&#34;
		data-flex-basis=&#34;558px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以知道它是一个LR(1)文法而非DCFG。&lt;/p&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>有穷自动机FA及正则语言RL</title>
        <link>https://0x3a0x29.github.io/p/regular/</link>
        <pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/p/regular/</guid>
        <description>&lt;img src="https://0x3a0x29.github.io/p/regular/image.png" alt="Featured image of post 有穷自动机FA及正则语言RL" /&gt;&lt;h1 id=&#34;有穷自动机fa及正则语言rl&#34;&gt;有穷自动机FA及正则语言RL
&lt;/h1&gt;&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;阅读本文需要集合论和图论的相关知识，在此不作有关集合论和图论相关知识的赘述。
笔者水平有限，存在的错误和不足请大家指正。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;字符串和语言&#34;&gt;字符串和语言
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;字母表（alphabet）&lt;/strong&gt;：一个非空有穷集合，其成员被称为该字母表的&lt;strong&gt;符号（symbol）&lt;/strong&gt;，通常用大写希腊字母$\Sigma,\Gamma$来表示字母表和字母表中符号的打印字体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符串（string）&lt;/strong&gt;：字母表中符号的有穷序列，通常写为一个符号挨着一个符号，不用逗号分隔，如果一个字符串$w$由字符$w_1,\cdots,w_n$一个挨着一个表示，称$w=w_1\cdots w_n$。一个字符串$w$所包含的符号数目称为它的&lt;strong&gt;长度（length）&lt;/strong&gt;，记作$|w|$。长度为零的字符串称为&lt;strong&gt;空串（empty string）&lt;/strong&gt;，记作$\epsilon$。若$\alpha$为$\alpha_1\cdots\alpha_m$、$\beta$为$\beta_1\cdots\beta_n$，它们都是某个字母表$\Sigma$的字符串，若$m=n$且对于每个$j,1\leq j\leq n$都有$\alpha_j$与$\beta_j$相同，称$\alpha=\beta$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;反转（reverse）&lt;/strong&gt;：按照相反的顺序写$w$所得到的字符串，记作$w^R$，例如$w=w_1w_2\cdots w_n$，那么有$w^R=w_nw_{n-1}\cdots w_1$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接（concatenation）&lt;/strong&gt;：若有字符串$x=x_1\cdots x_m,y=y_1\cdots y_n$，那么连接运算记作$xy=x_1\cdots x_my_1\cdots y_n$，也即把$y$附加在$x$得到的字符串。&lt;/p&gt;
&lt;p&gt;不难发现全体字符串集$W$对连接运算构成了一个以字母表$\Sigma$为基的自由含幺半群/自由独异点，也即：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于字符串$x,y,z\in W$，结合律$(xy)z=x(yz)$成立。&lt;/li&gt;
&lt;li&gt;对于字符串$x\in W$，$\epsilon x=x\epsilon=x$，即$\epsilon$为单位元。&lt;/li&gt;
&lt;li&gt;对于字符串$x\in W$，可以唯一地表示为$x=x_1\cdots x_n$，此处的$x_1,\cdots,x_n\in\Sigma$。&lt;/li&gt;
&lt;li&gt;对于字符串$x,y,z\in W$，若有$xy=xz$，则$y=z$；若有$xz=yz$，则$x=y$。即满足左、右消去律。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为结合律成立，可以定义一个字符串自身连接多次为$x^k=x\cdots x$，共有$k$个$x$连接。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子串（substring）&lt;/strong&gt;：若有$\beta=\gamma\alpha\theta$，其中$\alpha,\beta,\gamma,\theta$都是某个字母表上的字符串，那么称$\alpha$为$\beta$的子串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典序（lexicographic order）&lt;/strong&gt;：类似于大家熟悉的字典顺序，而一般采用&lt;strong&gt;字符串顺序（string order）&lt;/strong&gt;，它在字典序的基础上将短的字符串排在长的字符串的前面，例如字母表$\Sigma=${$0,1$}上的字符串顺序为$(\epsilon,0,1,00,01,10,11,000,\cdots)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前缀（prefix）&lt;/strong&gt;：如果有字符串$x,y,z$满足$xz=y$，则称$x$是$y$的前缀，并且若$x\neq y$，则称$x$是$y$的&lt;strong&gt;真前缀（proper prefix）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;语言（language）&lt;/strong&gt;：字符串的集合，称不含字符串的语言为空语言，记作$\varnothing$。如果语言中任何一个成员都不是其他成员的真前缀，那么该语言是&lt;strong&gt;无前缀的（prefix-free）&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;有穷自动机&#34;&gt;有穷自动机
&lt;/h2&gt;&lt;h3 id=&#34;有穷自动机的引入&#34;&gt;有穷自动机的引入
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;有穷自动机（finite automaton,FA）&lt;/strong&gt; 是描述能力和资源极其有限的计算机的模型，但是它也可以做到很多的事情。以一个生活中的例子为例：&lt;/p&gt;
&lt;p&gt;想象一个电视机，在处在开启状态时接收到关闭指令时它的状态会变为关闭，在处在关闭状态时接收到关闭指令时它的状态会变为开启，电视机有两个状态：开启状态和关闭状态，而指令是外部输入，这是一种有穷自动机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/1.png&#34;
	width=&#34;1260&#34;
	height=&#34;426&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/1_hu18221439412241038001.png 480w, https://0x3a0x29.github.io/p/regular/1_hu12088125681086466226.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;一台电视机对应的自动机&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;295&#34;
		data-flex-basis=&#34;709px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;为了更好地描述FA，可以设想一种物理模型————FA的物理模型，现在对其进行描述。首先它带有一个输入带，在输入带上有一系列方格，每个方格里都储存了一个字符，约定输入串从输入带的左端点开始存放，而输入带的右端是无穷的。其次系统有一个&lt;strong&gt;有穷状态控制器（finite state control，FSC）&lt;/strong&gt;，带有有穷个状态，FSC控制了一个读头，每读入一个字符就将读头指向输入带的后一个字符。系统的运行按照3个节拍进行：读入读头指向的字符，FSC根据当前的状态和读入的字符改变状态，读头向右移动一格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/2.png&#34;
	width=&#34;658&#34;
	height=&#34;248&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/2_hu15937446866882204574.png 480w, https://0x3a0x29.github.io/p/regular/2_hu15828587064437324954.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;FA的物理模型示意图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;265&#34;
		data-flex-basis=&#34;636px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;而在很多地方FA都有它的应用，如在时序电路设计当中有摩尔机（Moore Machine）：时序电路的输出是现态的函数。米利机（Mealy Machine）：输出是现态和输入的函数。它们两个也都是FA,下面使用Verilog语言编写的三段式代码描述了一个时序电路中的Moore机，它包含在物理模型当中提到的读入输入，改变状态，等待下一个输入的过程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;//状态寄存器
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always @ (posedge clk or negedge rst_n) begin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    if(!rst_n)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        state &amp;lt;= IDLE;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        state &amp;lt;= next_state;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;end
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;//次态的组合逻辑
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always @ (*) begin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    case(state)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        IDLE：begin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                if(w_i) next_state = S0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                else   next_state = IDLE;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              end
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        S0:  begin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                if(w_i) next_state = S1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                else    next_state = IDLE;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             end
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        S1:  begin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                if(w_i) next_state = S1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                else    next_state = IDLE;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;             end
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        default : next_state = 2&amp;#39;bxx;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   endcase
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;end
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;//输出逻辑
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;always @ (*) beign
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    case(current)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        IDLE:  z = 1&amp;#39;b0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        S0:    z = 1&amp;#39;b0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        S1:    z = 1&amp;#39;b1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        default:  z = 1&amp;#39;b0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    endcase
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;end
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面的这种FA也被称为&lt;strong&gt;有穷状态转换器（Finite-state transducer，FST）&lt;/strong&gt;，读者可以尝试自己给出它的形式化定义，在此不作相关说明。&lt;/p&gt;
&lt;p&gt;为了更好地描述FA的工作，先不给出FA的形式化定义，首先给出一个有穷自动机$M_1$：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/3.png&#34;
	width=&#34;636&#34;
	height=&#34;154&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/3_hu12928029905551494049.png 480w, https://0x3a0x29.github.io/p/regular/3_hu604089665199698384.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;示例自动机&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;412&#34;
		data-flex-basis=&#34;991px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上面这个图被称为$M_1$的&lt;strong&gt;状态图（state diagram）&lt;/strong&gt;，它总共有三个状态$q_0,q_1,q_2$，&lt;strong&gt;起始状态（start state）&lt;/strong&gt;$q_0$用一个单独的箭头表明出来，&lt;strong&gt;接受状态（accept state）&lt;/strong&gt;$q_1$带有一个双圈，从一个状态指向另一个状态的箭头称为&lt;strong&gt;转移（transition）&lt;/strong&gt;。当这个自动机接收到字符串后它会处理这个字符串并给出一个输出，或是&lt;strong&gt;接受&lt;/strong&gt;或是&lt;strong&gt;拒绝&lt;/strong&gt;。常用&lt;strong&gt;状态转移表&lt;/strong&gt;来描述可能的转移过程：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;0&lt;/th&gt;
          &lt;th&gt;1&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;$q_0$&lt;/td&gt;
          &lt;td&gt;$q_0$&lt;/td&gt;
          &lt;td&gt;$q_1$&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;$q_1$&lt;/td&gt;
          &lt;td&gt;$q_2$&lt;/td&gt;
          &lt;td&gt;$q_1$&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;$q_2$&lt;/td&gt;
          &lt;td&gt;$q_2$&lt;/td&gt;
          &lt;td&gt;$q_2$&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;现在来看两个字符串输入的例子：&lt;/p&gt;
&lt;p&gt;输入字符串011：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;开始时处在状态$q_0$。&lt;/li&gt;
&lt;li&gt;读到0，沿着转移从$q_0$到$q_0$。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_0$到$q_1$。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_1$到$q_1$。&lt;/li&gt;
&lt;li&gt;输出接受，因为在输入字符串的末端$M$正处在一个接受状态$q_1$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;输入字符串1100：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;开始时处在状态$q_0$。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_0$到$q_1$。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_1$到$q_1$。&lt;/li&gt;
&lt;li&gt;读到0，沿着转移从$q_1$到$q_2$。&lt;/li&gt;
&lt;li&gt;读到0，沿着转移从$q_2$到$q_2$。&lt;/li&gt;
&lt;li&gt;输出拒绝，因为在输入字符串的末端$M$不处在一个接受状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;有穷自动机的形式化定义&#34;&gt;有穷自动机的形式化定义
&lt;/h3&gt;&lt;p&gt;上面的例子说明，一台FA可以描述成一张含5个部分的表：状态集、输入字母表、动作规则、起始状态集和接受状态集。而用 &lt;strong&gt;转移函数（transition function）&lt;/strong&gt; 来定义动作规则，常记作$\delta$。&lt;/p&gt;
&lt;p&gt;FA是一个5元组$M=(Q,\Sigma,\delta,q_0,F)$，其中：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$Q$是一个有穷集合，称为&lt;strong&gt;状态集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$\Sigma$是一个有穷集合，称为&lt;strong&gt;字母表&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$\delta:Q\times\Sigma\rightarrow Q$，称为&lt;strong&gt;转移函数&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$q_0\in Q$是&lt;strong&gt;起始状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$F\subseteq Q$是&lt;strong&gt;接受状态集&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样就可以给出上面的例子$M_1$的形式化描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$Q=${$q_0,q_1,q_2$}。&lt;/li&gt;
&lt;li&gt;$\Sigma=${$0,1$}。&lt;/li&gt;
&lt;li&gt;$\delta(q_0,0)=q_0,\delta(q_0,1)=q_1,\delta(q_1,0)=q_2,\delta(q_1,1)=q_1,\delta(q_2,0)=q_2,\delta(q_2,1)=q_1$。&lt;/li&gt;
&lt;li&gt;$q_0$是起始状态。&lt;/li&gt;
&lt;li&gt;$F=${$q_1$}。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;若$A$是机器$M$所接受的全部字符串集，则称$A$是机器$M$的&lt;strong&gt;语言&lt;/strong&gt;，记作$L(M)=A$，又称$M$识别$A$或$M$接受$A$。&lt;/p&gt;
&lt;p&gt;转移函数处理的是一个字符，为了在理论分析时更加便于处理字符串，定义扩展转移函数$\hat{\delta}$：当$w=\epsilon$时$\hat{\delta}(q,w)=q$，当$w=xa$时$\hat{\delta}(q,w)=\delta(\hat{\delta}(q,x),a)$，其中$w,x$是字符串，$a$是字符。可知机器$M$接受$w$当且仅当$\hat{\delta}(q_0,w)\in F$。&lt;/p&gt;
&lt;h3 id=&#34;正则运算&#34;&gt;正则运算
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;正则语言（regular language，RL）&lt;/strong&gt;：如果一个语言被一台FA识别，则称它为正则语言。&lt;/p&gt;
&lt;p&gt;为了更好的研究RL，引入 &lt;strong&gt;正则运算（regular operation）&lt;/strong&gt; 以便研究它的性质，设$A,B$为两个语言，那么有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;并（union）&lt;/strong&gt;：$A\cup B=${$x|x\in A或x\in B$}，也有写作$A+B$的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;连接（concatenation）&lt;/strong&gt;：$A\circ B=${$xy|x\in A且y\in B$}，在不产生混淆的情况下可以写为$AB$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;幂（power）&lt;/strong&gt;：$A^0=${$\epsilon$}$,A^1=A,A^n=A^{n-1}\circ A$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;克林闭包（Kleene star）&lt;/strong&gt;：$A^{ * }=\cup^\infty_{i=0}A^i$，也有一种定义称$A^+=\cup^\infty_{i=1}A^i$为正闭包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了正则运算外，也有一些常用的运算，在此也作出介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于两个语言$A,B$，那么有&lt;strong&gt;交&lt;/strong&gt;运算：$A\cap B=${$x|x\in A且x\in B$}。&lt;/li&gt;
&lt;li&gt;对于两个语言$A,B$，那么有&lt;strong&gt;差&lt;/strong&gt;运算：$A-B=${$x|x\in A且x\notin B$}。&lt;/li&gt;
&lt;li&gt;对于字母表$\Sigma$上的一个语言$L$，称这个语言的&lt;strong&gt;补&lt;/strong&gt;运算为：$\overline{L}=\Sigma^{ * }-L$，显然有$L-M=L\cap\overline{M}$。&lt;/li&gt;
&lt;li&gt;对于字母表$\Sigma$上的语言$L$，称它的&lt;strong&gt;反转&lt;/strong&gt;为$L^R=${$w^R\in\Sigma^{ * }|w\in L$}。&lt;/li&gt;
&lt;li&gt;对于字母表$\Sigma$上的语言$L_1,L_2$，称**商（quotient）**为：$L_1/L_2=${$x|\exists y\in L_2使得xy\in L_1$}，这里是$L_2$除以$L_1$的商。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了更好地研究语言和运算之间的性质，引入封闭性的概念：&lt;/p&gt;
&lt;p&gt;如果任意的属于某一语言类的语言在某一特定运算下所得的结果任然是该类语言，则称该语言类对此运算是封闭的，并称该语言类对此运算有&lt;strong&gt;封闭性（closure property）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;给定一个语言类的若干语言的描述。如果存在一个算法，它可以构造出这些语言在给定运算下所获得的运算结果的相应形式的语言描述，则称此语言类对相应的运算是有效封闭的，并称此语言类对相应的运算具有&lt;strong&gt;有效封闭性（valid closure property）&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可以证明RL在并运算下是封闭的：&lt;/p&gt;
&lt;p&gt;设有RL：$A_1,A_2$，识别它们的有穷状态机分别为$M_1=(Q_1,\Sigma,\delta_1,q_1,F_1),M_2=(Q_2,\Sigma,\delta_2,q_2,F_2)$（两者的字母表不同时也可以构造相应的证明过程），那么可以构造这样一台FA$M=(Q_1\times Q_2,\Sigma,\delta,(q_1,q_2),(F_1\times Q_2)\cup(Q_1\times F_2))$，其中对于每一对$(r_1,r_2)\in Q,a\in\Sigma$，$\delta((r_1,r_2),a)=(\delta_1(r_1,a),\delta_2(r_2,a))$，这台自动机可以识别$A_1\cup A_2$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RL在连接运算下也是封闭的，但是如果想要证明这个事实，就会面临一个问题，该如何让需要构造的自动机$M$知道哪里才能将输入的字符串$w=w_1w_2$分为$w_1$和$w_2$，从而让两者分别被两台自动机接受呢？为了解决这个问题要引入非确定性。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;非确定性&#34;&gt;非确定性
&lt;/h2&gt;&lt;h3 id=&#34;非确定性的引入&#34;&gt;非确定性的引入
&lt;/h3&gt;&lt;p&gt;在刚刚定义的FA可以被称为&lt;strong&gt;确定的有穷自动机（deterministic finite automaton,DFA）&lt;/strong&gt;，它进行的是&lt;strong&gt;确定性计算（deterministic computation）&lt;/strong&gt;，现在要介绍的是&lt;strong&gt;带空移动的不确定的有穷自动机（non-deterministic finite automaton with $\epsilon$,$\epsilon$-NFA）&lt;/strong&gt;，这种机器是前者的推广，而在任何一点，其下一个状态可能存在若干个选择。&lt;/p&gt;
&lt;p&gt;首先给出一个$\epsilon$-NFA的例子，记其为$N_1$：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/5.png&#34;
	width=&#34;1120&#34;
	height=&#34;244&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/5_hu13492785266724341849.png 480w, https://0x3a0x29.github.io/p/regular/5_hu10198609769495381885.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;示例自动机&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;459&#34;
		data-flex-basis=&#34;1101px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;与DFA相比，这里某些状态对字母表中的某些符号产生了多个转移箭头，也有些符号没有对应的转移箭头，而这里出现了不取自于字母表的符号$\epsilon$。一般而言，$\epsilon$-NFA的箭头可以标记为字母表中的元素或$\epsilon$，从一个状态可能射出0个、1个或若干个标有$\epsilon$的箭头。&lt;/p&gt;
&lt;p&gt;$\epsilon$-NFA进行运算的过程像是多线程工作，当读入一个字符对应多个转移箭头时，$\epsilon$-NFA便会“复制”自己以进行多个方向的工作，当没有可以转移的箭头时这个$\epsilon$-NFA的“备份”便结束工作，而遇到带有$\epsilon$的箭头时$\epsilon$-NFA直接“复制”一份自身进行工作，也可以借助树的结构来观察这个过程。&lt;/p&gt;
&lt;p&gt;以$N_1$为例，输入字符串010110：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;开始时处在状态$q_1$。&lt;/li&gt;
&lt;li&gt;读到0，沿着转移从$q_1$到$q_1$。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_1$到$q_1,q_2,q_3$。&lt;/li&gt;
&lt;li&gt;读到0，沿着转移从$q_1$到$q_1$，从$q_2$到$q_3$，$q_3$无法进行转移。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_1$到$q_1,q_2,q_3$，从$q_3$到$q_4$。&lt;/li&gt;
&lt;li&gt;读到1，沿着转移从$q_1$到$q_1,q_2,q_3$，从$q_3$到$q_4$，从$q_3$到$q_4$，$q_2$无法进行转移。&lt;/li&gt;
&lt;li&gt;读到0，沿着转移从$q_1$到$q_1$，从$q_2$到$q_3$，从$q_4$到$q_4$，$q_3$无法进行转移。&lt;/li&gt;
&lt;li&gt;输出接受，因为存在一个NFA的“备份”能够到达接受状态$q_4$。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用树的结构来观察这个过程如下：
&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/6.png&#34;
	width=&#34;1150&#34;
	height=&#34;1074&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/6_hu14836835862620595787.png 480w, https://0x3a0x29.github.io/p/regular/6_hu6195013174086624256.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;输入字符串后自动机的状态转移示意图&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;107&#34;
		data-flex-basis=&#34;256px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;非确定性的形式化定义&#34;&gt;非确定性的形式化定义
&lt;/h3&gt;&lt;p&gt;现在给出$\epsilon$-NFA的形式化定义，$\epsilon$-NFA是一个五元组$(Q,\Sigma,\delta,q_0,F)$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$Q$是一个有穷集合，称为&lt;strong&gt;状态集&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$\Sigma$是一个有穷集合，称为&lt;strong&gt;字母表&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$\delta:Q\times\Sigma_\epsilon\rightarrow 2^Q$，称为&lt;strong&gt;转移函数&lt;/strong&gt;，其中$2^Q$表示$Q$的幂集，即$Q$的全体子集的集合，$\Sigma_\epsilon=\Sigma\cup${$\epsilon$}。&lt;/li&gt;
&lt;li&gt;$q_0\in Q$是&lt;strong&gt;起始状态&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;$F\subseteq Q$是&lt;strong&gt;接受状态集&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当$\epsilon$-NFA中不含有有$\epsilon$的转移箭头时得到了 &lt;strong&gt;不确定的有穷自动机（non-deterministic finite automaton,NFA）&lt;/strong&gt; 的定义，在此不作赘述。&lt;/p&gt;
&lt;p&gt;为了方便研究，引入$\epsilon$-闭包（$\epsilon$-Closure）的概念，记为$ECLOSE(q)$，表示经过0个或多于0个空转移到达的全部状态的集合，其递归定义如下：&lt;/p&gt;
&lt;p&gt;$q\in ECLOSE(q)$（包含当前状态本身）&lt;/p&gt;
&lt;p&gt;$\forall p\in ECLOSE(q),$如果有$r\in\theta(p,\epsilon)$，那么$r\in ECLOSE(q)$。&lt;/p&gt;
&lt;p&gt;在$N_1$中可以发现$ECLOSE(q_0)=${$q_0$}$,ECLOSE(q_1)=${$q_1,q_2$}。&lt;/p&gt;
&lt;p&gt;对$\epsilon$-闭包进行推广，状态集$S$的$\epsilon$-闭包为：$ECLOSE(S)=\cup_{q\in S}ECLOSE(q)$，即一个状态集$S$的$\epsilon$-闭包为$S$中每一个状态的$\epsilon$-闭包的并集。&lt;/p&gt;
&lt;p&gt;类似于先前做的那样，也给出扩展转移函数$\hat{\delta}$：&lt;/p&gt;
&lt;p&gt;$\hat{\delta}$：当$w=\epsilon$时$\hat{\delta}(q,w)=ECLOSE(q)$，当$w=xa$时$\hat{\delta}(q,w)=ECLOSE(\cup_{p\in\hat{\delta}(q,x)}\delta(p,a))$，其中$w,x$是字符串，$a$是字符。可知机器$N$接受$w$当且仅当$\hat{\delta}(q_0,w)\cap F\neq\varnothing$。&lt;/p&gt;
&lt;h3 id=&#34;dfa和ε-nfa的等价性&#34;&gt;DFA和ε-NFA的等价性
&lt;/h3&gt;&lt;p&gt;当两台机器识别同样的语言，则称它们是&lt;strong&gt;等价&lt;/strong&gt;的，乍一看上去仿佛$\epsilon$-NFA有着比DFA更加强大的能力，因为DFA本身便符合$\epsilon$-NFA的定义，但是两者实际上是等价的，为此，需要找到用DFA表示$\epsilon$-NFA的方法，这样的构造如下：&lt;/p&gt;
&lt;p&gt;设有$\epsilon$-NFA：$N=(Q,\Sigma,\delta,q_0,F)$，其识别了语言$A$，那么可以构造一台DFA识别语言$A$：$D=(2^Q,\Sigma,\delta_D,ECLOSE(q_0),F_D)$，其中$\forall S\subseteq Q,\forall a\in\Sigma,\delta_D(S,a)=ECLOSE(\cup_{p\in S}\delta(p,a))$，$F_D=${$S|S\subseteq Q,S\cap F\neq\varnothing$}。&lt;/p&gt;
&lt;p&gt;NFA是$\epsilon$-NFA的特殊情形，同时DFA一定是NFA，故这三种FA都是等价的。&lt;/p&gt;
&lt;p&gt;知道了两者的等价性后，可以得到推论：一个语言是正则的当且仅当有一台$\epsilon$-NFA可以识别它。&lt;/p&gt;
&lt;h3 id=&#34;在正则运算下的封闭性&#34;&gt;在正则运算下的封闭性
&lt;/h3&gt;&lt;p&gt;有了关于$\epsilon$-NFA的知识后，可以回过头来看看之前所未解决的问题，也即证明RL在正则运算下的封闭性，在此通过构造三个$\epsilon$-NFA将这个问题解决：&lt;/p&gt;
&lt;p&gt;（1）正则语言在并运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有RL：$A_1,A_2$被它们对应的两个$\epsilon$-NFA识别：$N_1=(Q_1,\Sigma,\delta_1,q_1,F_1),N_2=(Q_2,\Sigma,\delta_2,q_2,F_2)$，那么可以识别$A_1\cup A_2$的$\epsilon$-NFA构造为：$N=(${$q_0$}$\cup Q_1\cup Q_2,\Sigma,\delta,q_0,F_1\cup F_2)$，其中$\forall q\in Q,a\in \Sigma_\epsilon$&lt;/p&gt;
&lt;p&gt;当$q\in Q_1$时$\delta(q,a)=\delta_1(q,a)$&lt;/p&gt;
&lt;p&gt;当$q\in Q_2$时$\delta(q,a)=\delta_2(q,a)$&lt;/p&gt;
&lt;p&gt;当$q=q_0$且$a=\epsilon$时$\delta(q,a)=${$q_1,q_2$}&lt;/p&gt;
&lt;p&gt;当$q=q_0$且$a\neq\epsilon$时$\delta(q,a)=\varnothing$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/7.png&#34;
	width=&#34;922&#34;
	height=&#34;850&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/7_hu526286099206366473.png 480w, https://0x3a0x29.github.io/p/regular/7_hu1731852976432196056.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;并运算对应的自动机&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;108&#34;
		data-flex-basis=&#34;260px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;（2）正则语言在连接运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有RL：$A_1,A_2$被它们对应的两个$\epsilon$-NFA识别：$N_1=(Q_1,\Sigma,\delta_1,q_1,F_1),N_2=(Q_2,\Sigma,\delta_2,q_2,F_2)$，那么可以识别$A_1\circ A_2$的$\epsilon$-NFA构造为：$N=(Q_1\cup Q_2,\Sigma,\delta,q_1,F_2)$，其中$\forall q\in Q,a\in \Sigma_\epsilon$&lt;/p&gt;
&lt;p&gt;当$q\in Q_1$且$q\notin F_1$时$\delta(q,a)=\delta_1(q,a)$&lt;/p&gt;
&lt;p&gt;当$q\in F_1$且$a\neq\epsilon$时$\delta(q,a)=\delta_1(q,a)$&lt;/p&gt;
&lt;p&gt;当$q\in F_1$且$a=\epsilon$时$\delta(q,a)=\delta_1(q,a)\cup${$q_2$}&lt;/p&gt;
&lt;p&gt;当$q\in Q_2$时$\delta(q,a)=\delta_2(q,a)$
&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/8.png&#34;
	width=&#34;1116&#34;
	height=&#34;680&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/8_hu7210683092556059390.png 480w, https://0x3a0x29.github.io/p/regular/8_hu5577002273944923359.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;连接运算对应的自动机&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;164&#34;
		data-flex-basis=&#34;393px&#34;
	
&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（3）正则语言在克林闭包运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有RL：$A_1$被对应的$\epsilon$-NFA识别：$N_1=(Q_1,\Sigma,\delta_1,q_1,F_1)$，那么可以识别$A_1^{ * }$的$\epsilon$-NFA构造为：$N=(${$q_0$}$\cup Q_1,\Sigma,\delta,q_0,${$q_0$}$\cup F_1)$，其中$\forall q\in Q,a\in \Sigma_\epsilon$&lt;/p&gt;
&lt;p&gt;当$q\in Q_1$且$q\notin F_1$时$\delta(q,a)=\delta_1(q,a)$&lt;/p&gt;
&lt;p&gt;当$q\in F_1$且$a\neq\epsilon$时$\delta(q,a)=\delta_1(q,a)$&lt;/p&gt;
&lt;p&gt;当$q\in F_1$且$a=\epsilon$时$\delta(q,a)=\delta_1(q,a)\cup${$q_1$}&lt;/p&gt;
&lt;p&gt;当$q=q_0$且$a=\epsilon$时$\delta(q,a)=${$q_1$}&lt;/p&gt;
&lt;p&gt;当$q=q_0$且$a\neq\epsilon$时$\delta(q,a)=\varnothing$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/9.png&#34;
	width=&#34;1128&#34;
	height=&#34;408&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/9_hu4457836059238505445.png 480w, https://0x3a0x29.github.io/p/regular/9_hu8729684916741227664.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;克林闭包运算对应的自动机&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;276&#34;
		data-flex-basis=&#34;663px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;在其他运算下的封闭性&#34;&gt;在其他运算下的封闭性
&lt;/h3&gt;&lt;p&gt;RL除了在这些正则运算下保持封闭，在其他运算下也有保持封闭的性质，在此选取了常用的性质进行说明：&lt;/p&gt;
&lt;p&gt;（1）RL在补运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有RL：$A$被对应的DFA识别：$D=(Q,\Sigma,\delta,q_0,F)$，那么可以识别$\overline{L}=\Sigma^{ * }-L$的DFA构造为$D&amp;rsquo;=(Q,\Sigma,\delta,q_0,Q-F)$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（2）RL在交运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果$L,M$是RL，考虑事实$L\cap M=\overline{\overline{L}\cup\overline{M}}$。&lt;/p&gt;
&lt;p&gt;也可以通过构造自动机证明这一事实，设有RL：$A_1,A_2$被对应的两个DFA识别：$M_1=(Q_1,\Sigma,\delta_1,q_1,F_1),M_2=(Q_2,\Sigma,\delta_2,q_2,F_2)$，那么可以构造识别$A_1\cap A_2$的DFA：$M=(Q_1\times Q_2,\Sigma,\delta,(q_1,q_2),F_1\times F_2)$。其中$\forall (p,q)\in Q_1\times Q_2,\forall a\in\Sigma,\delta((p,q),a)=(\delta_1(p,a),\delta_2(q,a))$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（3）RL在差运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果$L,M$是RL，考虑事实$L-M=L\cap\overline{M}$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（4）RL在反转运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有RL：$A$被相应的DFA：$D=(Q,\Sigma,\delta,q_0,F)$识别，可以构造识别$A^R$的$\epsilon$-NFA：$N=(Q,\Sigma,\delta&amp;rsquo;,q_R,${$q_0$}$)$，如果有$\delta(q,a)=p$，那么作$\delta&amp;rsquo;(p,a)=q$，同时要求$\delta&amp;rsquo;(q_R,\epsilon)=F$，恰好满足这两个条件即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（5）正则代换：&lt;/p&gt;
&lt;p&gt;可以引入&lt;strong&gt;代换（substitution）&lt;/strong&gt; 的概念，设有两个字母表$\Sigma,\Delta$，那么映射$f:\Sigma\rightarrow 2^{\Delta^{ * }}$称为从$\Sigma$到$\Delta$的一个代换，如果对于$\forall a\in\Sigma,f(a)$是$\Delta$上的RL，则称$f$为&lt;strong&gt;正则代换（regular substitution）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以进一步扩展$f$的定义域，首先将其定义域拓展到$\Sigma^{ * } $上，也就是说定义字符串的代换，$f:\Sigma^{ * }\rightarrow 2^{\Delta^{ * }}$：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f(\epsilon)=${$\epsilon$}。&lt;/li&gt;
&lt;li&gt;$f(xa)=f(x)f(a)$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;再将定义域拓展到$2^{\Sigma^{ * } }$上，也就是定义语言的代换，$f:2^{\Sigma^{ * }}\rightarrow 2^{\Delta^{ * } }$：
对于$\forall L\subseteq\Sigma^{ * } $，有$f(L)=\cup_{x\in L}f(x)$。
为了方便研究，也给出正则表达式上的正则代换：
设$\Sigma,\Delta$是两个字母表，映射$f:\Sigma\rightarrow 2^{\Delta^{ * }}$为正则代换，那么有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$f(\varnothing)=\varnothing$。&lt;/li&gt;
&lt;li&gt;$f(\epsilon)=\epsilon$。&lt;/li&gt;
&lt;li&gt;对于$\forall a\in\Sigma,f(a)$是$\Delta$上的正则表达式&lt;/li&gt;
&lt;li&gt;如果$r,s$是$\Sigma$上的正则表达式，那么有:$f(r\cup s)=f(r)\cup f(s),f(r\circ s)=f(r)\circ f(s),f(r^{ * })=f(r)^{ * }$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用数学归纳法很容易证明：设$L$是$\Sigma$上的一个RL，有正则代换$f:\Sigma\rightarrow 2^{\Delta^{ * }}$，则$f(L)$也是RL。&lt;/p&gt;
&lt;p&gt;可以引入 &lt;strong&gt;同态（homomorphism）&lt;/strong&gt; 的概念，设有两个字母表$\Sigma,\Delta$，有映射$f:\Sigma\rightarrow\Delta^{ * } $。如果对于$\forall x,y\in\Sigma^{ * } $有$f(xy)=f(x)f(y)$，则称$f$为从$\Sigma$到$\Delta^{ * } $的同态映射。&lt;/p&gt;
&lt;p&gt;对于$\forall L\subseteq\Sigma^{ * }$，$L$的同态像$f(L)=\cup_{x\in L}${$f(x)$}。&lt;/p&gt;
&lt;p&gt;对于$\forall w\subseteq\Delta^{ * } $，$w$的同态原像$f^{-1}(w)=${$x|f(x)=w且x\in\Sigma^{ * }$}。&lt;/p&gt;
&lt;p&gt;对于$\forall L\subseteq\Delta^{ * } $，$L$的同态原像$f^{-1}(L)=${$x|f(x)\in L$}。&lt;/p&gt;
&lt;p&gt;（6）RL在同态像运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不难发现同态映射是正则代换的特例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（7）RL在同态原像运算下封闭：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设有$L$是RL，有同态映射$h:\Sigma\rightarrow\Delta^{ * } $，识别它的DFA：$D=(Q,\Gamma,\delta,q_0,F)$，那么可以构造识别$h^{-1}(A)$的DFA：$D&amp;rsquo;=(Q,\Sigma,\delta&amp;rsquo;,q_0,F)$，其中对$\forall (q,a)\in Q\times\Sigma$，都有$\delta&amp;rsquo;(q,a)=\delta(q,h(a))$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（8）RL在商运算下封闭:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设$L_1,L_2\in\Sigma^{ * } $，如果$L_1$是RL，则$L_1/L_2$也是RL。
设有识别$L_1$的DFA：$M_1=(Q,\Sigma,\delta,q_0,F_1)$，那么可以构造识别$L_1/L_2$的DFA：$M_2=(Q,\Sigma,\delta,q_0,${$q|\exists y\in L_2,\delta(q,y)\in F$}$)$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;必须要指出的是，这里的$L_2$可以是各种语言，故这种封闭性不是&lt;strong&gt;有效封闭性&lt;/strong&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正则表达式&#34;&gt;正则表达式
&lt;/h2&gt;&lt;h3 id=&#34;正则表达式的形式化定义&#34;&gt;正则表达式的形式化定义
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;正则表达式（regular expression，RE）&lt;/strong&gt;：类似于算术中的运算存在着对应的表达式，如$5+4$，也可以使用正则运算描述语言的表达式，称为正则表达式，例如$(0\cup 1)0^{ * }$，现在给出它的形式化定义：&lt;/p&gt;
&lt;p&gt;称$R$是一个正则表达式，如果$R$是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$a$，要求$a\in\Sigma$，$\Sigma$是字母表，表示语言{$a$}。&lt;/li&gt;
&lt;li&gt;$\epsilon$，表示语言{$\epsilon$}。&lt;/li&gt;
&lt;li&gt;$\varnothing$，表示空语言。&lt;/li&gt;
&lt;li&gt;$(R_1\cup R_2)$，其中$R_1,R_2$都是正则表达式，表示这两个语言作并运算得到的语言，也有写成$(R_1+R_2)$的。&lt;/li&gt;
&lt;li&gt;$(R_1\circ R_2)$，其中$R_1,R_2$都是正则表达式，表示这两个语言作连接运算得到的语言，在不产生混淆的情况下可以写为$(R_1R_2)$。&lt;/li&gt;
&lt;li&gt;$(R_1)^{ * }$，其中$R_1$是正则表达式，表示这个语言作克林闭包运算得到的语言。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述的定义是有效的、可以避免循环的，被称为归纳定义（inductive defination）。&lt;/p&gt;
&lt;p&gt;表达式中的括号可以被略去，如果略去括号，可以按照下述优先顺序进行运算：克林闭包，连接，并。&lt;/p&gt;
&lt;p&gt;正则表达式$R$所描述的语言记作$L(R)$。&lt;/p&gt;
&lt;p&gt;正则表达式和这里使用到的三种运算形成了Kleene代数（例如对并运算和连接运算形成了一个半环），在此指出有关正则表达式的一些代数定律：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并运算满足交换律和结合律。&lt;/li&gt;
&lt;li&gt;连接运算满足结合律，但不满足交换律。&lt;/li&gt;
&lt;li&gt;$\varnothing$是并运算的单位元，是连接运算的零元，也就是说对于正则表达式$L$始终有$\varnothing\cup L=L\cup\varnothing=L,\varnothing\circ L=L\circ\varnothing=\varnothing$。&lt;/li&gt;
&lt;li&gt;$\epsilon$是连接运算的单位元，也就是说对于正则表达式$L$始终有$\epsilon L=L\epsilon =L$。&lt;/li&gt;
&lt;li&gt;连接运算对并运算满足左右分配律。&lt;/li&gt;
&lt;li&gt;并运算满足幂等律。&lt;/li&gt;
&lt;li&gt;对任意语言$L$都有$(L^{ * })^{ * }=L^{ * }$。&lt;/li&gt;
&lt;li&gt;$\varnothing^{ * }=\epsilon$。&lt;/li&gt;
&lt;li&gt;$\epsilon^{ * }=\epsilon$。&lt;/li&gt;
&lt;li&gt;对任意语言$L$都有$L^{ * }L^{ * }=L^{ * }$。&lt;/li&gt;
&lt;li&gt;对任意语言$L,M$都有$(L\cup M)^{ * }=(L^{ * }M^{ * })^{ * }$。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;与有穷自动机的等价性&#34;&gt;与有穷自动机的等价性
&lt;/h3&gt;&lt;p&gt;现在要说明一个正则语言一定可以用正则表达式描述，反之亦然，也就是说要证明两个命题，下面给出这两个命题的证明。&lt;/p&gt;
&lt;p&gt;（1）如果一个语言可以用正则表达式描述，那么它是正则的。&lt;/p&gt;
&lt;p&gt;可以使用归纳法证明这个结论，归纳基础如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/10.png&#34;
	width=&#34;1212&#34;
	height=&#34;924&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/10_hu4781724733839857856.png 480w, https://0x3a0x29.github.io/p/regular/10_hu6331908880685565072.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;归纳基础&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;131&#34;
		data-flex-basis=&#34;314px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;归纳递推如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/11.png&#34;
	width=&#34;908&#34;
	height=&#34;628&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/11_hu3998622659975730273.png 480w, https://0x3a0x29.github.io/p/regular/11_hu2775156862375133142.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;归纳递推&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;347px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这样的三种构造恰好可以与三种正则运算相对应&lt;/p&gt;
&lt;p&gt;那么找到了将正则表达式转化为对应的$\epsilon$-NFA的方法，证明完毕。&lt;/p&gt;
&lt;p&gt;（2）如果一个语言是正则的，那么可以用正则表达式描述它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，给出一种方法证明这个问题，设有DFA：$M=(\cup_{i=1}^n${$q_i$}$,\Sigma,\delta,q_1,F)$&lt;/p&gt;
&lt;p&gt;令$R^k_{ij}=${$x|\hat{\delta}(q_i,x)=q_j,而且对于x的任意前缀y(y\neq x,y\neq\epsilon),如果\hat{\delta}(q_i,y)=q_j,则l\leq k$}&lt;/p&gt;
&lt;p&gt;也就是说$R^k_{ij}$是所有那些将DFA从给定状态$q_i$引导到状态$q_j$并且中途不经过下标大于$k$的状态的那些字符串，可以发现有递归关系：&lt;/p&gt;
&lt;p&gt;如果$i\neq j$那么有$R^0_{ij}=${$a|\hat{\delta}(q_i,a)=q_j$}，如果$i=j$那么有$R^0_{ij}=${$a|\hat{\delta}(q_i,a)=q_j$}$\cup${$\epsilon$}。&lt;/p&gt;
&lt;p&gt;$R^k_{ij}=R^{k-1}&lt;em&gt;{ik}(R^{k-1}&lt;/em&gt;{kk})^{ * } R^{k-1}&lt;em&gt;{kj}\cup R^{k-1}&lt;/em&gt;{ij}$&lt;/p&gt;
&lt;p&gt;显然有$L(M)=\cup_{q_j\in F}R^n_{1f}$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述这种做法不太直观，为此可以通过引入一个新的自动机：&lt;strong&gt;广义非确定型有穷自动机（generalized nondeterministic finite automaton，GNFA）&lt;/strong&gt; 来解决这个问题，下面给出一个例子对这种自动机进行说明：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/12.png&#34;
	width=&#34;1196&#34;
	height=&#34;826&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/12_hu3432974970291811667.png 480w, https://0x3a0x29.github.io/p/regular/12_hu11285598807232773148.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;一台GNFA&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;144&#34;
		data-flex-basis=&#34;347px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以发现GNFA的转移箭头可以用任何正则表达式作标号，而不是只能用字母表的成员或者$\epsilon$作为标号。相较于NFA一次最多只能读入一个符号，GNFA可以一次读入一段输入符号，沿着连接两个状态的箭头移动，而这段输入符号正好是那个转移箭头上的正则表达式所描述的一个字符串。&lt;/p&gt;
&lt;p&gt;为了方便，对GNFA作出一些特殊形式的条件要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;起始状态有射到其他每一个状态的箭头，但是没有从任何其他状态射入的箭头。&lt;/li&gt;
&lt;li&gt;有唯一的接受状态，并且它有从其他每一个状态射入的箭头，但是没有射到任何其他状态的箭头。此外，这个接受状态和起始状态不同。&lt;/li&gt;
&lt;li&gt;除了起始状态和接受状态之外，每一个状态到自身和其他每一个状态都有一个箭头。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;把DFA转换成GNFA是容易的，只需要新添加初始状态和接受状态，新初始状态到原初始状态有一个$\epsilon$箭头，每一个原接受状态到新接受状态有一个$\epsilon$箭头，把有多个标记的箭头换成并运算的正则表达式形式，最后将需要补上箭头的原先无箭头的地方补上$\varnothing$的箭头即可，因为这个箭头始终无法被使用。&lt;/p&gt;
&lt;p&gt;现在给出GNFA的形式化定义：&lt;/p&gt;
&lt;p&gt;广义非确定型有穷自动机是一个5元组$(Q,\Sigma,\delta,q_{start},q_{accept})$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$Q$是一个有穷的状态集。&lt;/li&gt;
&lt;li&gt;$\Sigma$是一个有穷的字母表。&lt;/li&gt;
&lt;li&gt;$\delta:(Q-${$q_{accept}$}$)\times(Q-${$q_{start}$}$)\rightarrow \mathcal{R} $，即转移函数。&lt;/li&gt;
&lt;li&gt;$q_{start}\in Q$是起始状态。&lt;/li&gt;
&lt;li&gt;$q_{accept}$是接受状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果字符串$w=w_1w_2\cdots w_k$，其中的每一个$w_i\in\Sigma^{ * }$，并且存在状态序列$q_0,q_1,\cdots,q_k$使得&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$q_0=q_{start}$是起始状态。&lt;/li&gt;
&lt;li&gt;$q_k=q_{accept}$是接受状态。&lt;/li&gt;
&lt;li&gt;对于每一个$i,w_i\in L(R_i)$，其中$R_i=\delta(q_{i-1},q_i)$，即$R_i$是从$q_{i-1}$到$q_i$的箭头上的正则表达式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么称这个GNFA接受字符串$w$。&lt;/p&gt;
&lt;p&gt;而对于GNFA，存在一种算法可以不断减少它所拥有的状态数目，最后将会剩下它的初始状态和接受状态，同时也只有一个从初始状态到接受状态的箭头，这个箭头的标记就说等价的正则表达式，现在给出这样一个算法CONVERT(G)，它通过每轮减少一个状态的方式实现了状态的缩减：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设$k$为$G$的状态数，如果$k=2$则$G$一定是一个起始状态、一个接受状态和连接两者的箭头组成，返回箭头上标记的正则表达式$R$。&lt;/p&gt;
&lt;p&gt;如果$k&amp;gt;2$，则任取一个状态$q_{rip}\in Q-${$q_{start},q_{accept}$}，并且令一个新的GNFA：$G&amp;rsquo;=(Q&amp;rsquo;,\Sigma,\delta&amp;rsquo;,q_{start},q_{accept})$，其中$Q&amp;rsquo;=Q-${$q_{rip}$}，而对于每一个$q_i\in Q&amp;rsquo;-${$q_{accept}$}$,q_j\in Q&amp;rsquo;-${$q_{start}$}，令$\delta&amp;rsquo;(q_i,q_j)=(R_1)(R_2)^{ * }(R_3)\cup(R_4)$，其中$R_1=\delta(q_i,q_{rip}),R_2=\delta(q_{rip},q_{rip}),R_3=\delta(q_{rip},q_j),R_4=\delta(q_i,q_j)$，计算CONVERT(G)并返回这个值。&lt;/p&gt;
&lt;p&gt;实际上当$k&amp;gt;2$时CONVERT(G)所做的事情是将某个状态去掉，用能够经过这个状态的路径对应的正则表达式取代了它，从而不影响整个状态机的运行。&lt;/p&gt;
&lt;p&gt;可以证明对于任意的GNFA G，都有CONVERT(G)等价于G，也就是说所有GNFA都有与其等价的一个含有两个状态的GNFA。证明了任何RL都可以用正则表达式来描述它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;myhill-nerode定理和dfa的极小化&#34;&gt;Myhill-Nerode定理和DFA的极小化
&lt;/h2&gt;&lt;h3 id=&#34;myhill-nerode定理&#34;&gt;Myhill-Nerode定理
&lt;/h3&gt;&lt;p&gt;知道任何GNFA都可以被化简为只有两个状态的形式，但是这不意味着DFA和$\epsilon$-NFA可以被化简为只有两个状态的形式，实际上总能找到这样的语言$L_n$使得能够接受它的DFA和$\epsilon$-NFA拥有至少$n$个状态（考虑只含有一个字符串的形如{$0^k$}的语言）。&lt;/p&gt;
&lt;p&gt;但是可以对这些自动机进行化简，在此给出减少DFA的状态以化简它的方法。&lt;/p&gt;
&lt;p&gt;设DFA：$M=(Q,\Sigma,\delta,q_0,F)$，由$M$确定的$\Sigma^{ * } $上的关系$R_M$定义为：对于$\forall x,y\in\Sigma^{ * } $都有$xR_My\Leftrightarrow\hat{\delta}(q_0,x)=\hat{\delta}(q_0,y)$。&lt;/p&gt;
&lt;p&gt;设$L\subseteq\Sigma^{ * } $，$L$确定的$\Sigma^{ * } $上的关系$R_L$定义为：对于$\forall x,y\in\Sigma^{ * } $，$xR_Ly\Leftrightarrow(对\forall z\in\Sigma^{ * } ,xz\in L\Leftrightarrow yz\in L)$。可以证明$xR_My\Rightarrow xR_{L(M)}y$，但是反之不成立。&lt;/p&gt;
&lt;p&gt;设$R$是$\Sigma^{ * } $上的等价关系，对于$\forall x,y\in\Sigma^{ * } $，如果$xRy$则$\forall z\in\Sigma^{ * } $都有$xzRyz$，那么称$R$是&lt;strong&gt;右不变的（right invariant）&lt;/strong&gt; 等价关系。可以证明上面定义的两个关系都是右不变的等价关系。&lt;/p&gt;
&lt;p&gt;设$R$是$\Sigma^{ * } $上的等价关系，则称$|\Sigma^{ * } /R|$是$R$关于$\Sigma^{ * } $的&lt;strong&gt;指数（index）&lt;/strong&gt;（也就是一个集合的等价类的个数），简称为$R$的指数。$\Sigma^{ * } $关于$R$的一个等价类，也就是$\Sigma^{ * } /R$的任意一个元素，简称为$R$的一个等价类。&lt;/p&gt;
&lt;p&gt;由于$xR_My\Rightarrow xR_{L(M)}y$，可以证明对于任意DFA：$M=(Q,\Sigma,\delta,q_0,F)$都有$|\Sigma^{ * } /R_{L(M)}|\leq|\Sigma^{ * } /R_M|\leq|Q|$。同时可以看出$R_M$对$\Sigma^{ * } $的划分比$R_{L(M)}$更加“细”，$R_M$可以将$R_{L(M)}$所划分的等价类进一步划分，称$R_M$是$R_{L(M)}$的&lt;strong&gt;加细（refinement）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Myhill-Nerode定理&lt;/strong&gt;：有三个等价的命题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$L\subseteq\Sigma^{ * } $是RL。&lt;/li&gt;
&lt;li&gt;$L$是$\Sigma^{ * } $上的某个具有有穷指数的右不变等价关系$R$的某些等价类的并。&lt;/li&gt;
&lt;li&gt;$R_L$具有有穷指数。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：不妨证明从（1）到（2）、从（2）到（3）、从（3）到（1）都是成立的。&lt;/p&gt;
&lt;p&gt;从（1）到（2）：&lt;/p&gt;
&lt;p&gt;由于$L$是RL，存在识别它的DFA：$M=(Q,\Sigma,\delta,q_0,F)$，由于$R_M$是$\Sigma^{ * } $上的右不变的等价关系，同时$|\Sigma^{ * } |\leq|Q|$，故$R_M$有有穷指数，$R_M$即为满足要求的一个右不变等价关系。&lt;/p&gt;
&lt;p&gt;从（2）到（3）：&lt;/p&gt;
&lt;p&gt;设$L$是$\Sigma^{ * } $上具有有穷指数的右不变等价关系$R$的某些等价类的并，不妨证明$R$是$R_L$的加细，也就是证明$\forall x,y\in\Sigma^{ * } ,xRy\Rightarrow xR_Ly$。由于$R$的右不变性，可知对于$\forall z\in\Sigma^{ * } $都有$xzRyz$，而$L$又是$R$的某些等价类的并，所以$xz\in L\Leftrightarrow yz\in L$，也就是说$xR_Ly$。&lt;/p&gt;
&lt;p&gt;从（3）到（1）：&lt;/p&gt;
&lt;p&gt;设$R_L$有有穷指数，构造DFA：$M&amp;rsquo;=(\Sigma^{ * } /R_L,\Sigma,\delta&amp;rsquo;,[\epsilon],${$[x]|x\in L$}$)$，其中$[\epsilon]$表示$\epsilon$所在的等价类所对应的状态，$[x]$表示$x$所在的等价类所对应的状态。对于任意$([x],a)\in(\Sigma^{ * } /R_L)\times\Sigma$都有$\delta&amp;rsquo;([x],a)=[xa]$，那么有$L(M&amp;rsquo;)=L$，这里构造的$M&amp;rsquo;$称为最小DFA。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由Myhill-Nerode定理可以得到两个推论，在此不对两个推论作出证明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$L$是RL，识别它的DFA：$M=(Q,\Sigma,\delta,q_0,F)$，则$|\Sigma^{ * } /R_L|\leq|Q|$。&lt;/p&gt;
&lt;p&gt;$L$是RL，在同构意义下，接受$L$的最小DFA是唯一的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;定理得到证明，这个定理可以用于证明一个语言是RL，也可以证明一个语言不是RL。
例如语言{$0^n1^n|n\geq 0$}，可以发现它的等价关系$R_L$的指数是无穷的，因此$L$不是RL。&lt;/p&gt;
&lt;h3 id=&#34;dfa的极小化&#34;&gt;DFA的极小化
&lt;/h3&gt;&lt;p&gt;设DFA：$M=(Q,\Sigma,\delta,q_0,F)$，如果$\exists x\in\Sigma^{ * } $使得$Q$中的两个状态$q$和$p$，在$\delta(q,x)\in F$和$\delta(p,x)\in F$中有且仅有一个成立，则称$q$和$p$是&lt;strong&gt;可以区分的（distinguishable）&lt;/strong&gt;；否则称$q$和$p$等价，记作$q\equiv p$。&lt;/p&gt;
&lt;p&gt;为了让DFA极小化，实际上只需要找到一个DFA中全部的可区分状态对，再将不可区分的状态对合并为一个状态，同时保留被合并的状态到其他的状态的转移箭头，同时去掉DFA中的不可达状态，就得到了最小DFA。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://0x3a0x29.github.io/p/regular/13.png&#34;
	width=&#34;1426&#34;
	height=&#34;350&#34;
	srcset=&#34;https://0x3a0x29.github.io/p/regular/13_hu7994359962299853571.png 480w, https://0x3a0x29.github.io/p/regular/13_hu1983745396128431918.png 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;DFA的极小化示例&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;407&#34;
		data-flex-basis=&#34;977px&#34;
	
&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;正则语言的泵引理&#34;&gt;正则语言的泵引理
&lt;/h2&gt;&lt;p&gt;正则语言的泵引理是如此的重要和有影响力，以至于人们一直将其称为引理而未改称其为定理。正则语言的泵引理是它的一种特殊性质：语言中的所有字符串只要它的长度不小于某个特定值————泵长度（pumping length），就可以被“抽取”，也就是说字符串中有一段字串，无论字串重复多少次，得到的字符串依旧在这个语言里。下面给出其形式化表述和相应证明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;泵引理（pumping lemma）&lt;/strong&gt;：若$L$是一个RL，则存在一个正整数$N$，对$w\in L$，只要$|w|&amp;gt;N$，就可以将$w$分为三部分$w=xyz$使得：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$y\neq\epsilon$&lt;/li&gt;
&lt;li&gt;$|xy|\leq N$&lt;/li&gt;
&lt;li&gt;$\forall k\geq 0,xy^kz\in L$&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$M=(Q,\Sigma,\delta,q_0,F)$识别语言$L$，其中$|Q|=N$，在读入长度为$m$的串时（$m\geq N$），它所经过的状态有$q_0,q_1,\cdots,q_m$，根据鸽巢原理，必然有两个状态是相同的，不妨设$q_i=q_j,0\leq i&amp;lt; j\leq N$，那么可以划分$w$为$x=a_1a_2 \cdots a_i,y=a_{i+1}\cdots a_j,z=a_{i+1} \cdots a_M$，找到了这样一种划分符合泵引理的要求，证毕。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了泵引理后，可以发现并不是所有语言都是RL，例如{$0^n1^n|n\geq 0$}这样一个语言便不是一个RL，它不满足泵引理的条件。&lt;/p&gt;
&lt;p&gt;但是值得注意的是泵引理是某个语言是RL的必要条件而不是充分条件，例如{$0^i1^j2^k|i,j,k\geq 0,并且若i=1,则j=k$}，记这个语言为$F$，考虑语言$L=L(01^{ * }2^{ * })$，那么$L\cap F=${$01^n2^n|n\geq 0$}，很明显后者不是RL，由于RL在交运算下封闭，所以$F$不是RL，但它满足泵引理。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;八正则语言的判定性质&#34;&gt;八、正则语言的判定性质
&lt;/h2&gt;&lt;p&gt;任何语言都有3个经典的判定问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以某种形式化模型描述的语言是否为空？是否无穷？&lt;/li&gt;
&lt;li&gt;某个特定的串$w$是否属于所描述的语言？&lt;/li&gt;
&lt;li&gt;以两种方式描述的语言，是否是相同的？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面给出了这三个问题的相关回答：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;设DFA：$M=(Q,\Sigma,\delta,q_0,F)$&lt;/p&gt;
&lt;p&gt;那么$L=L(M)$非空的充分必要条件是：存在$x\in\Sigma^{ * } ,|x|&amp;lt;|Q|,\hat{\delta}(q_0,x)\in F$。&lt;/p&gt;
&lt;p&gt;$L=L(M)$无穷的充分必要条件是：存在$x\in\Sigma^{ * } ,|Q|\leq|x|&amp;lt;2|Q|,\hat{\delta}(q_0,x)\in F$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设DFA：$M_1=(Q_1,\Sigma,\delta_1,q_1,F_1),M_2=(Q_2,\Sigma,\delta_2,q_2,F_2)$，则存在判断$L(M_1),L(M_2)$是否相同的算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记$L_1=L(M_1),L_2=L(M_2)$，那么$(L_1\cap\overline{L_2})\cup(\overline{L_1}\cap L_2)$是正则的，可以被某个有穷自动机$M_3$接受，而$M_3$接受某个串当且仅当$L_1\neq L_2$，已经证明了存在算法判断$L(M_3)$是否为空，得证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设$L$是字母表$\Sigma$上的RL，对于任意的$w\in\Sigma^{ * } $，存在判定$w$是否为$L$的句子的算法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于$L$是RL，故存在DFA使得它接受这个语言。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>FC(一阶谓词演算系统)及其相关定理</title>
        <link>https://0x3a0x29.github.io/p/firstorderpredicatecalculus/</link>
        <pubDate>Mon, 17 Jun 2024 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/p/firstorderpredicatecalculus/</guid>
        <description>&lt;img src="https://0x3a0x29.github.io/p/firstorderpredicatecalculus/image.png" alt="Featured image of post FC(一阶谓词演算系统)及其相关定理" /&gt;&lt;h1 id=&#34;fc及其相关定理&#34;&gt;FC及其相关定理
&lt;/h1&gt;&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;水平有限，存在的错误和不足请大家指正。&lt;/p&gt;
&lt;p&gt;本篇所述皆来自于笔者于23年学校开设的《数理逻辑》课程中讲解内容。&lt;/p&gt;
&lt;p&gt;在先前已经给出了命题逻辑的相关介绍，但是命题逻辑存在着不可避免的缺陷，在命题逻辑中我们将原子命题看成是不可再分的基本单位，这就体现不出命题中研究对象的特性以及研究对象之间的逻辑关系，而有些推理的正确性依赖于命题的内部结构，我们以著名的苏格拉底三段论为例：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;所有的人都是要死的。&lt;/li&gt;
&lt;li&gt;苏格拉底是人。&lt;/li&gt;
&lt;li&gt;所以苏格拉底是要死的。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们引入三个命题变元$P,Q,R$，我们可以写出推理的命题形式：$P\wedge Q\rightarrow R$，但是很明显这个公式并非永真式，我们不能看出原来正确的推理。
为此，我们必须引入谓词逻辑，以帮助我们研究相关的推理形式和规律。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识
&lt;/h2&gt;&lt;p&gt;部分基础概念如定理、证明、演绎等在此不作赘述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个体词&lt;/strong&gt;：用于表示研究对象的词，分为个体常元（通常用字母表靠前的小写字母表示）和个体变元（通常用字母表靠后的小写字母表示）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;谓词&lt;/strong&gt;：表示研究对象的性质（一个个体变元）或研究对象（多个个体变元）之间关系的词（通常用大写字母来表示）。那么我们可以得到n元谓词的概念，为了增加可读性，我们可以写作$P^{(n)}(t_1,t_2,\cdots,t_n)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个体域（论域）&lt;/strong&gt;：个体变元的取值范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;函词&lt;/strong&gt;：用于描述从一个论域到另一个论域的映射，不难发现函词的定义类似于函数的定义，常用小写字母或小写英文单词来表示，对于含有n个个体变元的函词常记作$f^{(n)}$，为了增加可读性，我们可以写作$f^{(n)}(t_1,t_2,\cdots,t_n)$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;量词&lt;/strong&gt;：用于限制个体词的数量，分为全称量词和存在量词。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;全称量词$\forall$&lt;/strong&gt;：表任意的，从量上表示“所有的”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特称量词$\exists$&lt;/strong&gt;：表存在的，从量上表示“至少有一个”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在量词之间显然有着这样的对应关系：&lt;/p&gt;
&lt;p&gt;（1）$\forall xP(x)\Leftrightarrow\neg\exists x\neg P(x)$&lt;/p&gt;
&lt;p&gt;（2）$\exists xP(x)\Leftrightarrow\neg\forall x\neg P(x)$&lt;/p&gt;
&lt;p&gt;（3）$\neg\forall xP(x)\Leftrightarrow\exists x\neg P(x)$&lt;/p&gt;
&lt;p&gt;（4）$\neg\exists xP(x)\Leftrightarrow\forall x\neg P(x)$&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;项&lt;/strong&gt;：类似于之前命题公式的定义，现在给出项的定义：&lt;/p&gt;
&lt;p&gt;（1）个体变元和个体常元是项。&lt;/p&gt;
&lt;p&gt;（2）若$f^{(n)}$是一个n元函词，且$t_1,t_2\cdots,t_n$是项，那么$f^{(n)}(t_1,t_2,\cdots,t_n)$是项。&lt;/p&gt;
&lt;p&gt;（3）有限次的使用（1）（2）进行复合得到的结果也是项。&lt;/p&gt;
&lt;p&gt;在此定义的项的概念在我们将介绍的FC中也是同理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;约束变元&lt;/strong&gt;：受量词约束的个体变元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自由变元&lt;/strong&gt;：不受量词约束的个体变元。&lt;/p&gt;
&lt;p&gt;例如$\forall x(P(x,y)\rightarrow Q(x,y))\rightarrow R(x,y)$中，记前件为$A$，记后件为$B$。在前件中存在指导变元$x$，故$x$为约束变元，在后件中$x$为自由变元，在前件和后件中$y$均为自由变元。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;辖域&lt;/strong&gt;：量词所约束的范围。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;合式公式&lt;/strong&gt;：合式公式也称谓词公式，或简称公式，定义如下：&lt;/p&gt;
&lt;p&gt;（1）不含联结词的单个谓词即原子谓词公式是合式公式。&lt;/p&gt;
&lt;p&gt;（2）若$A$为合式公式，那么$\neg A$也是合式公式。&lt;/p&gt;
&lt;p&gt;（3）若$A,B$为合式公式，且无变元$x$在$A,B$中的一个是约束的，而另一个是自由的，则$A\wedge B,A\vee B,A\rightarrow B,A\leftrightarrow B$都是合式公式。&lt;/p&gt;
&lt;p&gt;（4）若$A$为合式公式，而$x$在$A$中为自由变元，则$\forall xP(x),\exists xP(X)$均为合式公式。&lt;/p&gt;
&lt;p&gt;（5）由（1）~（4）有限次复合所形成的公式均为合式公式。&lt;/p&gt;
&lt;p&gt;在此定义的公式的概念在我们将介绍的FC中也是同理的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子公式&lt;/strong&gt;：如果公式$A$为形如$wBw&amp;rsquo;$的符号串，其中$w,w&amp;rsquo;$都是符号串，$B$是公式，那么$B$就称为公式$A$的子公式。当$w,w&amp;rsquo;$中存在非空串时我们称$B$为真子公式。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;易名规则&lt;/strong&gt;：将量词辖域中出现的某个约束变元改为另一个在该辖域中未出现的个体变元，公式中的其余部分保持不变，改名后的公式称为原公式的改名式，例如$\forall xP(x)$的改名式可以是$\forall yP(x)^x_y$。在使用易名规则时需要注意待改名的变元在其辖域内的此变元都应该被改掉，而其余的保持不变，另外新引进的变元符不应该在该量词的辖域内出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可代入&lt;/strong&gt;：设$v$为谓词公式$A$中的自由变元，且项$t$中不含$A$的约束变元符（若有可以使用易名规则），则称项$t$对$v$是可代入的。&lt;/p&gt;
&lt;p&gt;例如$A=\forall v_1P(v_1,v_2)$中，若$t$不含约束变元$v$的项，那么$t$对$v_2$是可代入的。若$t=f(v_1)$，其中$f$为函词，那么$t$对$v_2$是不可代入的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代入&lt;/strong&gt;：对公式$A$中的自由变元$v$的所有自由出现都换为项$t$（必须是可代入的），记为$A^v_t$。若$A$中无$v$的出现则$A^v_t=A$。值得注意的是：我们使用记号$A^{v_1,v_2,\cdots,v_n}&lt;em&gt;{t_1,t_2,\cdots,t_n}$表示对$A$的变元$v_1,v_2,\cdots,v_n$同时做代入，即将$v_i$代为$t_i$，而不同于$(\cdots((A^{v_1}&lt;/em&gt;{t_1})^{v_2}&lt;em&gt;{t_2})^{v_3}&lt;/em&gt;{t_3}\cdots)^{v_n}_{t_n}$。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;全称化&lt;/strong&gt;：设$v_1,v_2,\cdots,v_n$为公式$A$中的自由变元，则公式$\forall v_{i_1}\forall v_{i_2}\cdots\forall v_{i_r}A$称为$A$的全称化，其中$1\leq i_1,i_2,\cdots,i_r\leq n,1\leq r\leq n$。当$r=n$时即为$A$的全称封闭式。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;有了这些基础知识后，我们便可以将自然语句形式化，例如：&lt;/p&gt;
&lt;p&gt;命题“过平面上两个不同点有且仅有一条直线通过”，令：&lt;/p&gt;
&lt;p&gt;谓词$D(x)$表示：$x$为平面上的点&lt;/p&gt;
&lt;p&gt;谓词$G(x)$表示：$x$为平面上的直线&lt;/p&gt;
&lt;p&gt;谓词$L(x,y,z)$表示：$z$通过$x,y$&lt;/p&gt;
&lt;p&gt;谓词$E(x,y)$表示：$x$与$y$相等&lt;/p&gt;
&lt;p&gt;那么我们可以将语句形式化为：&lt;/p&gt;
&lt;p&gt;$\forall x\forall y(D(x)\wedge D(y)\wedge\neg E(x,y)\rightarrow \exists z(G(z)\wedge L(x,y,z)\wedge\forall u(G(u)\wedge L(x,y,u)\rightarrow E(u,z))))$&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一阶谓词形式系统的语义&#34;&gt;一阶谓词形式系统的语义
&lt;/h2&gt;&lt;p&gt;个体常元、变元、项、函词、谓词等属于语法范畴的概念，它们只是一些字符串，并不具备实际意义。为了讨论谓词演算公式的真值，就需要对函词、谓词进行指称，对个体常元、变元取值的指派，即赋予它们一定的意义。&lt;/p&gt;
&lt;p&gt;在一阶谓词演算系统中，证明和推演只是公式符号组合的形式变糊，并未考虑到其语义，但是建立一个形式系统正是为了研究正确的逻辑推理形式及其规律，为此，在予以解释后，其中的公理和定理应当是逻辑规律的反映。&lt;/p&gt;
&lt;p&gt;由于相较于命题逻辑我们引入了谓词、函词、量词等符号，对谓词公式的解释会更加复杂，其语义解释通常是一个数学结构，包括论域$D$及对常元、函词、谓词进行指称的解释$I$，我们得到了一个结构$U=&amp;lt; D,I &amp;gt;$，全体结构的集合记为$T$（这样的结构通常称为$Tarski$语义类）。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;解释i的组成&#34;&gt;解释I的组成
&lt;/h3&gt;&lt;p&gt;一个&lt;strong&gt;解释&lt;/strong&gt;就是一个映射$I$，它指称常元、函词和谓词为：&lt;/p&gt;
&lt;p&gt;（1）对任一常元$a$指定为论域$D$的一个个体，记为$I(a)$，简记为$\overline{a}$。&lt;/p&gt;
&lt;p&gt;（2）对每一n元函词$f^{(n)}$指定为$D$上的一个n元函数，记为$I(f^{(n)})$，简记为$\overline{f}^{(n)}$。&lt;/p&gt;
&lt;p&gt;（3）对每一n元谓词$P^{(n)}$指定为$D$上的一个n元关系，记为$I(P^{(n)})$，简记为$\overline{P}^{(n)}$。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;指派&#34;&gt;指派
&lt;/h3&gt;&lt;p&gt;一阶谓词演算中的&lt;strong&gt;指派&lt;/strong&gt;是对个体变元指定为论域$D$中的个体作为其取值，即为映射$s:${$v_1,v_2,\cdots$}$\rightarrow D$。即对任一变元$v_i,s(v_i)\in D$。&lt;/p&gt;
&lt;p&gt;指派$s$可以扩展为从项集合到个体域的映射$\overline{s}$：对于任意的项$t$，&lt;/p&gt;
&lt;p&gt;（1）$\overline{s}(t)=s(v)$，当$t$为变元$v$时。&lt;/p&gt;
&lt;p&gt;（2）$\overline{s}(t)=\overline{a}$，当$t$为常元$a$时。&lt;/p&gt;
&lt;p&gt;（3）$\overline{s}(t)=\overline{f}^{(n)}(\overline{s}(t_1),\overline{s}(t_2),\cdots,\overline{s}(t_n))$，当$t$为n元函词$f^{(n)}(t_1,t_2,\cdots,t_n)$时。&lt;/p&gt;
&lt;p&gt;不难发现指派$s$域解释$I$是相互独立的，但是指派$\overline{s}$却是依赖于解释$I$的。&lt;/p&gt;
&lt;p&gt;有了结构$U=&amp;lt; D,I &amp;gt;$及指派$s$，于是对公式$A$在结构$U=&amp;lt; D,I &amp;gt;$及指派$s$下取值为真记为$\models_UA[s]$，反之记为$\nvDash_UA[s]$。而$\models_UA$则表示在结构$U$中对一切可能的指派$s$，公式$A$皆为真；而$\models A$或者$\models_TA$表示公式$A$在一切结构$U$中均为真，即$A$永真。&lt;/p&gt;
&lt;h3 id=&#34;models_uas的严格定义&#34;&gt;$\models_UA[s]$的严格定义
&lt;/h3&gt;&lt;p&gt;除了解释和指派，我们还需要对量词和联结词的意义作出规定，为此我们给出递归定义来明确$\models_UA[s]$的严格定义。&lt;/p&gt;
&lt;p&gt;（1）当$A$为原子公式$P^{(n)}(t_1,\cdots,t_n)$时$\models_UA[s]$当且仅当$&amp;lt; \overline{s}(t_1),\cdots,\overline{s}(t_n) &amp;gt;\in\overline{P}^{(n)}$，即此时n元谓词所描述的n元关系成立。&lt;/p&gt;
&lt;p&gt;（2）当$A$为公式$\neg B$时$\models_UA[s]$当且仅当$\nvDash_UB[s]$。&lt;/p&gt;
&lt;p&gt;（3）当$A$为公式$B\rightarrow C$时$\models_UA[s]$当且仅当$\nvDash_UB[s]$或$\models_UC[s]$。&lt;/p&gt;
&lt;p&gt;（4）当$A$为公式$\forall vB$时$\models_UA[s]$当且仅当对每一个$d\in D$都有$\models_UB[s(v|d)]$，其中指派$s(v|d)$表示除了对变元$v$用指定元素$d$赋值外，对其他变元的指派与$s$相同。&lt;/p&gt;
&lt;p&gt;当我们使用联结词$\vee,\wedge$和存在量词$\exists$时可以补充：&lt;/p&gt;
&lt;p&gt;（1）$\models_UB\vee C[s]$当且仅当$\models_UB[s]$或$\models_UC[s]$。&lt;/p&gt;
&lt;p&gt;（2）$\models_UB\wedge C[s]$当且仅当$\models_UB[s]$且$\models_UC[s]$。&lt;/p&gt;
&lt;p&gt;（3）$\models_U\exists vB[s]$当且仅当存在$d\in D$使得$\models_UB[s(v|d)]$。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;一阶谓词演算形式系统fc的简单介绍&#34;&gt;一阶谓词演算形式系统FC的简单介绍
&lt;/h2&gt;&lt;p&gt;一阶谓词演算形式系统FC（First order predicate Calculus）是一种形式系统，我们先简单介绍一下FC的组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;字母表$\Sigma=L_v\cup L_a\cup L_f\cup L_p\cup L_l$，其中$L_v$即个体变元，$L_a$即个体常元，$L_f$即各种函词，$L_p$即各种谓词，$L_l$包括了真值联结词$\rightarrow,\neg$，量词$\forall$和括号$(,)$。&lt;/p&gt;
&lt;p&gt;（1）在这里其他的联结词和存在量词$\exists$都被视作是缩写符号。&lt;/p&gt;
&lt;p&gt;（2）这里的介绍中未引入等词$=$。&lt;/p&gt;
&lt;p&gt;（3）$L_f=\varnothing$时称之为纯谓词演算系统。&lt;/p&gt;
&lt;p&gt;（4）如果我们引入0元谓词符号，那么实际上我们就得到了PC，故可以将PC视作FC的子系统，在PC中成立的定理可以迁移到FC中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形式规则：上文提到的合式公式的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公理：设$A,B,C$为代表FC中任意公式的语法变元，$v$为任意变元，$t$为任意项，那么FC中有六个公理模式
$A1:A\rightarrow (B\rightarrow A)$
$A2:(A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$
$A3:(\neg A\rightarrow\neg B)\rightarrow (B\rightarrow A)$
$A4:\forall vA\rightarrow A^v_t$，若$t$对$A$中的变元$v$可代入
$A5:\forall v(A\rightarrow B)\rightarrow(\forall vA\rightarrow\forall vB)$
$A6:A\rightarrow\forall vA$，若$v$在$A$中无自由出现
FC的公理包含上述六个公理模式和他们对应的全称化，同时后面的3个公理也是永真式，在此不作证明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推理规则：同PC中的规则$r_{mp}$：即若有$A$和$A\rightarrow B$成立，那么$B$也成立，形式化的推理序列为：$A,A\rightarrow B,B$。
可以记作$\displaystyle{\frac{A,A\rightarrow B}{B}}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;FC是完备的，也就是说所有永真式均为FC的定理，$G\ddot{o}del$首先发现并证明了这一事实，即$G\ddot{o}del$完备性定理。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;fc中的基本定理&#34;&gt;FC中的基本定理
&lt;/h2&gt;&lt;h3 id=&#34;fc的定理&#34;&gt;FC的定理
&lt;/h3&gt;&lt;p&gt;下列总结了FC中12个基本定理，并给出了部分证明：&lt;/p&gt;
&lt;p&gt;$Th1$：对于FC中的任何公式$A$和变元$v$，$\vdash_{FC}\forall vA\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\forall vA\rightarrow A^v_v$,$A4$，后者即$A$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th2$：对于FC中的任何公式$A$和变元$v$，$\vdash_{FC}A\rightarrow\neg\forall v\neg A$，即$\vdash_{FC}A\rightarrow\exists vA$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\forall v\neg A\rightarrow\neg A$,$A4$&lt;/li&gt;
&lt;li&gt;$(\forall v\neg A\rightarrow\neg A)\rightarrow(A\rightarrow\neg\forall v\neg A)$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$A\rightarrow\neg\forall v\neg A$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th3$：对于FC中的任何公式$A$和变元$v$，$\vdash_{FC}\forall vA\rightarrow\exists vA$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\forall vA\rightarrow A$,$Th1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vA$,$Th2$&lt;/li&gt;
&lt;li&gt;$\forall vA\rightarrow\exists vA$,三段论&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th4$：（&lt;strong&gt;普化定理&lt;/strong&gt;/全称推广定理）对于FC中的任何公式$A$和变元$v$，如果$\vdash_{FC}A$，那么$\vdash_{FC}\forall vA$
需要注意的是$\vdash_{FC}A\rightarrow\forall vA$并不一定成立，故在$A6$中我们作出了额外的要求：$v$在$A$中无自由出现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$A_1,A_2,\cdots,A_n(=A)$是FC中公式$A$的证明序列，对证明的长度n使用归纳法。
（1）当n=1时，$A$只能是公理。若$v$在$A$中自由出现，那么$\forall vA$也是公理；若$v$不在$A$中自由出现，则$A\rightarrow\forall vA$为公理，由$r_{mp}$知$\forall vA$为公理。
（2）当n&amp;gt;1时，若$A$为公理，仿照（1）的证明可知$\forall vA$为定理。若$A_n$为$A_j(i&amp;lt; n)$，则由归纳假设可知$\forall vA_j=\forall vA$为定理。若$A_n$是由$A_i,A_j$通过$r_{mp}$推得，不妨设$A_j=A_i\rightarrow A$，则由归纳假设$\forall vA_i,\forall v(A_i\rightarrow A)$都是定理。再由公理$\forall v(A_i\rightarrow A)\rightarrow(\forall vA_i\rightarrow\forall vA)$知$\forall vA_i\rightarrow\forall vA$为定理，使用$r_{mp}$则知$\forall vA$为定理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th5$：对于FC中的任何公式集合$\Gamma$，公式$A$和不在$\Gamma$的任意公式中自由出现的变元$v$，对$Th4$进行推广，得到：如果$\Gamma\vdash_{FC}A$，那么$\Gamma\vdash_{FC}\forall vA$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：设$A_1,A_2,\cdots,A_n(=A)$是FC中公式$A$的演绎序列，对证明的长度n使用归纳法。
（1）当n=1时，若$A$是公理。若$v$在$A$中自由出现，那么$\forall vA$也是公理；若$v$不在$A$中自由出现，则$A\rightarrow\forall vA$为公理，由$r_{mp}$知$\forall vA$为公理。于是当$A$为公理时，都有$\Gamma\vdash\forall vA$。若$A\in\Gamma$，则$v$不在$A$中自由出现，从而$A\rightarrow\forall vA$为公理，从而由$r_{mp}$知$\Gamma\vdash\forall vA$。
（2）当n&amp;gt;1时，若$A$为公理或者$A\in\Gamma$，仿照（1）的证明可知$\forall vA$为定理。若$A_n$为$A_j(i&amp;lt; n)$，则由归纳假设可知$\forall vA_j=\forall vA$为定理。若$A_n$是由$A_i,A_j$通过$r_{mp}$推得，不妨设$A_j=A_i\rightarrow A$，则由归纳假设$\forall vA_i,\forall v(A_i\rightarrow A)$都是定理。再由公理$\forall v(A_i\rightarrow A)\rightarrow(\forall vA_i\rightarrow\forall vA)$知$\forall vA_i\rightarrow\forall vA$为定理，使用$r_{mp}$则知$\forall vA$为定理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th6$：（&lt;strong&gt;演绎定理&lt;/strong&gt;）在FC中演绎定理也成立，对于FC中任何公式集合$\Gamma$和FC中的任意两个公式$A,B$，那么$\Gamma;A\vdash_{FC}B$当且仅当$\Gamma\vdash_{FC}A\rightarrow B$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：类似于在PC中演绎定理的证明，在此不作说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th7$：设$\Gamma$为FC中的任一公式集合，$A,B$为FC中任意两个公式，$\Gamma;A\vdash_{FC}\neg B$当且仅当$\Gamma;B\vdash_{FC}\neg A$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\Gamma;A\vdash\neg B$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash A\rightarrow\neg B$,$Th6$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash(A\rightarrow\neg B)\rightarrow(B\rightarrow\neg A)$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash B\rightarrow\neg A$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$\Gamma;B\vdash\neg A$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th8$：（反证法）如果FC中的公式集合$\Gamma\cup${$A$}是不一致的，则$\Gamma\vdash_{FC}\neg A$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：由于$\Gamma\cup${$A$}不一致，则存在公式$B$使得$\Gamma;A\vdash B$和$\Gamma;A\vdash\neg B$。由于$\neg B\rightarrow(B\rightarrow\neg A)$为定理，所以$\Gamma;A\vdash\neg A$，由演绎定理得$\Gamma\vdash A\rightarrow\neg A$，又因为$(A\rightarrow\neg A)\rightarrow\neg A$为定理，从而$\Gamma\vdash\neg A$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th9$：设$\Gamma$为FC中的任一公式集合，$A,B$为FC中的任意两个公式，并且变元$v$不在$\Gamma$的任何公式里面自由出现，那么$\Gamma;A\vdash_{FC}B$蕴含$\Gamma;\forall vA\vdash_{FC}B$和$\Gamma;\forall vA\vdash_{FC}\forall vB$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\Gamma;A\vdash B$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash A\rightarrow B$,$Th6$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\forall v(A\rightarrow B)$,$Th4$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\forall v(A\rightarrow B)\rightarrow(\forall vA\rightarrow\forall vB)$,$A5$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\forall vA\rightarrow\forall vB$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$\Gamma;\forall vA\vdash\forall vB$,$Th6$&lt;/li&gt;
&lt;li&gt;$\Gamma;\forall vA\vdash B$,$Th1$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th10$：（&lt;strong&gt;存在消除&lt;/strong&gt;）设$\Gamma$为FC中的任一公式集合，$A,B$为FC中的任意两个公式，并且变元$v$不在$\Gamma$的任何公式以及公式$B$里面自由出现，那么由$\Gamma\vdash_{FC}\exists vA$以及$\Gamma;A\vdash_{FC}B$可以推出$\Gamma\vdash_{FC}B$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\Gamma;A\vdash B$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash A\rightarrow B$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash(A\rightarrow B)\rightarrow(\neg B\rightarrow A)$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\neg B\rightarrow\neg A$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash;\neg B\vdash\neg A$&lt;/li&gt;
&lt;li&gt;$\Gamma;\neg B\vdash\forall v\neg A$,$Th2$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\neg B\rightarrow\forall v\neg A$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash(\neg B\rightarrow\forall v\neg A)\rightarrow(\neg\forall v\neg A\rightarrow B)$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\neg\forall v\neg A\rightarrow B$,$r_{mp}(7)(8)$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\exists vA\rightarrow B$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash\exists vA$&lt;/li&gt;
&lt;li&gt;$\Gamma\vdash B$,$r_{mp}(10)(11)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th11$：（替换原理）设$A,B$为FC的公式，且满足$A\vdash\dashv_{FC}B$，$A$是$C$的子公式，$D$是将$C$中$A$的若干出现换为公式$B$得到的公式，则$C\vdash\dashv_{FC}D$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th12$：（改名定理）在FC中若$A&amp;rsquo;$是$A$的改名式，且$A&amp;rsquo;$改用的变元不在$A$中出现，则$A\vdash\dashv_{FC}A&amp;rsquo;$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&#34;例题&#34;&gt;例题
&lt;/h3&gt;&lt;p&gt;证明：$\vdash A\rightarrow B$且变元$v$在$B$中无自由出现，则$\vdash\exists vA\rightarrow B$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\vdash A\rightarrow B$&lt;/li&gt;
&lt;li&gt;$\vdash\neg B\rightarrow\neg A$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$\vdash\forall v(\neg B\rightarrow\neg A)$,$Th1$&lt;/li&gt;
&lt;li&gt;$\vdash\forall v(\neg B\rightarrow\neg A)\rightarrow(\forall v\neg B\rightarrow\forall v\neg A)$,$A5$&lt;/li&gt;
&lt;li&gt;$\vdash\forall v\neg B\rightarrow\forall v\neg A$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$\vdash\neg B\rightarrow\forall v\neg B$,$A6$&lt;/li&gt;
&lt;li&gt;$\vdash\neg B\rightarrow\forall v\neg A$,三段论&lt;/li&gt;
&lt;li&gt;$\vdash(\neg B\rightarrow\forall v\neg A)\rightarrow(\neg\forall v\neg A\rightarrow B)$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$\vdash\neg\forall v\neg A\rightarrow B$,$r_{mp}(7)(8)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;证明：$\vdash(A\rightarrow\exists vB)\rightarrow\exists v(A\rightarrow B)$，其中$v$在$A$中无自由出现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\forall v\neg(A\rightarrow B)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\neg(A\rightarrow B)$,$Th1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\neg(A\rightarrow B)\rightarrow\neg B$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\neg B$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\forall v\neg B$,$Th1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\neg(A\rightarrow B)\rightarrow A$,$PC$中的定理&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash A$,$r_{mp}(2)(6)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash A\rightarrow\exists vB$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\exists vB$,$r_{mp}(7)(8)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB,\forall v\neg(A\rightarrow B)\vdash\neg\forall v\neg B$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB\vdash\neg\forall v\neg(A\rightarrow B)$,对(5)和(10)使用反证法&lt;/li&gt;
&lt;li&gt;$A\rightarrow\exists vB\vdash\exists v(A\rightarrow B)$&lt;/li&gt;
&lt;li&gt;$\vdash(A\rightarrow\exists vB)\rightarrow\exists v(A\rightarrow B)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;其他形式的一阶谓词演算系统&#34;&gt;其他形式的一阶谓词演算系统
&lt;/h2&gt;&lt;p&gt;FC的形式是简洁的，但是正如PC所具有的问题那样，在实际应用中FC并不方便，因为它所使用的联结词、量词和公理数量太少了。故类似于先前在介绍完PC后引入了ND，本文将引入FCM和FND两个形式系统，以便让我们的推理更加直观。&lt;/p&gt;
&lt;h3 id=&#34;fcm形式系统&#34;&gt;FCM形式系统
&lt;/h3&gt;&lt;p&gt;FCM形式系统是由莫绍揆教授提出的使用五个逻辑联结词（$\neg,\rightarrow,\vee,\wedge,\leftrightarrow$）和两个量词（$\forall,\exists$）的一阶谓词演算形式系统：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;公理：设$A,B,C$为代表FC中任意公式的语法变元，$v$为任意变元，$t$为任意项，那么FCM的公理包含下列七组公理模式及其对应的全称化&lt;/p&gt;
&lt;p&gt;$A1.1:A\rightarrow A$&lt;/p&gt;
&lt;p&gt;$A1.2:(A\rightarrow(B\rightarrow C))\rightarrow(B\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;$A1.3:(A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;$A1.4:(A\rightarrow(A\rightarrow B))\rightarrow(A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;$A2.1:(A\leftrightarrow B)\rightarrow(A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;$A2.2:(A\leftrightarrow B)\rightarrow(B\rightarrow A)$&lt;/p&gt;
&lt;p&gt;$A2.3:(A\rightarrow B)\rightarrow((B\rightarrow A)\rightarrow(A\leftrightarrow B))$&lt;/p&gt;
&lt;p&gt;$A3.1:A\rightarrow(A\vee B)$&lt;/p&gt;
&lt;p&gt;$A3.2:B\rightarrow(A\vee B)$&lt;/p&gt;
&lt;p&gt;$A3.3:(A\rightarrow C)\rightarrow((B\rightarrow C)\rightarrow(A\vee B\rightarrow C))$&lt;/p&gt;
&lt;p&gt;$A4.1:A\wedge B\rightarrow A$&lt;/p&gt;
&lt;p&gt;$A4.2:A\wedge B\rightarrow B$&lt;/p&gt;
&lt;p&gt;$A4.3:A\rightarrow(B\rightarrow A\wedge B)$&lt;/p&gt;
&lt;p&gt;$A5.1:(A\rightarrow\neg B)\rightarrow(B\rightarrow\neg A)$&lt;/p&gt;
&lt;p&gt;$A5.2:\neg\neg A\rightarrow A$&lt;/p&gt;
&lt;p&gt;$A6.1:\forall vA\rightarrow A^v_t$，若$t$对$A$中的变元$v$可代入&lt;/p&gt;
&lt;p&gt;$A6.2:\forall v(A\rightarrow B)\rightarrow(\forall vA\rightarrow\forall vB)$&lt;/p&gt;
&lt;p&gt;$A6.3:A\rightarrow\forall vA$，若$v$在$A$中无自由出现&lt;/p&gt;
&lt;p&gt;$A7.1:\exists vA\rightarrow\neg\forall v\neg A$&lt;/p&gt;
&lt;p&gt;$A7.2:\neg\forall v\neg A\rightarrow\exists vA$&lt;/p&gt;
&lt;p&gt;这七组公理模式是显然的，很多在之前已经进行了证明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推理规则：$r_{mp}$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;fnd形式系统&#34;&gt;FND形式系统
&lt;/h3&gt;&lt;p&gt;在ND的基础上，很容易扩展出一个谓词演算的自然推理系统，我们称作FND，FND在ND的基础上新增添了一些规则，主要是增加了有关量词的推理规则，其余规则保持不变。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\forall$引入规则${\frac{\Gamma\vdash A}{\Gamma\vdash\forall vA}}(\forall+)$&lt;/li&gt;
&lt;li&gt;$\forall$消除规则${\frac{\Gamma\vdash\forall vA}{\Gamma\vdash A^v_t}}(\forall-)$，若$t$对$A$中的变元$v$可代入&lt;/li&gt;
&lt;li&gt;$\exists$引入规则${\frac{\Gamma\vdash A^t_t}{\Gamma\vdash\exists vA}}(\exists+)$，若$t$对$A$中的变元$v$可代入&lt;/li&gt;
&lt;li&gt;$\exists$消除规则${\frac{\Gamma\vdash\exists vA,\Gamma;A^v_t\vdash B}{\Gamma\vdash B}}(\exists-)$，其中常元$c$在$\Gamma$及公式$A,B$中均无自由出现&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们现在对这里的推理规则的意义进行解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$(\forall+)$规则：考虑FC中的全称引入定理。&lt;/li&gt;
&lt;li&gt;$(\forall-)$规则：考虑FC的公理$\forall vA\rightarrow A^v_t$，若$t$对$A$中的变元$v$可代入。&lt;/li&gt;
&lt;li&gt;$(\exists+)$规则：考虑FC的定理$A^v_t\rightarrow\exists vA$，若$t$对$A$中的变元$v$可代入。&lt;/li&gt;
&lt;li&gt;$(\exists-)$规则：考虑FC的存在消除定理。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&#34;例题-1&#34;&gt;例题
&lt;/h3&gt;&lt;p&gt;证明：$\exists x(A\vee B)\vdash\dashv\exists xA\vee\exists xB$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B,A\vdash\exists xA$,$(\exists+)(1)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B,A\vdash\exists xA\vee\exists xB$,$(\vee+)(2)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B,B\vdash\exists xB$,$(\exists+)(4)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B,B\vdash\exists xA\vee\exists xB$,$(\vee+)(5)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B\vdash A\vee B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B),A\vee B\vdash\exists xA\vee\exists xB$,$(\vee-)(3)(6)(7)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B)\vdash\exists x(A\vee B)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B)\vdash\exists xA\vee\exists xB$,$(\exists-)(8)(9)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xA,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xA,A\vdash A\vee B$,$(\vee+)(11)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xA,A\vdash\exists x(A\vee B)$,$(\exists+)(12)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xA\vdash\exists xA$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xA\vdash\exists x(A\vee B)$,$(\exists-)(13)(14)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xB,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xB,B\vdash A\vee B$,$(\vee+)(16)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xB,B\vdash\exists x(A\vee B)$,$(\exists+)(17)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xB\vdash\exists xB$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB,\exists xB\vdash\exists x(A\vee B)$,$(\exists-)(18)(19)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB\vdash\exists xA\vee\exists xB$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\exists xA\vee\exists xB\vdash\exists x(A\vee B)$,$(\vee-)(15)(20)(21)$&lt;/li&gt;
&lt;li&gt;$\exists x(A\vee B)\vdash\dashv\exists xA\vee\exists xB$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;fc定理证明习题选&#34;&gt;FC定理证明习题选
&lt;/h2&gt;&lt;p&gt;下面给出了八道FC定理习题供读者练习使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明：$\forall x(A\rightarrow B)\vdash A\rightarrow\forall xB$，其中$x$在$A$中无自由出现。&lt;/li&gt;
&lt;li&gt;证明: $\vdash\exists v(A\rightarrow B)\rightarrow(A\rightarrow\exists vB)$，其中$v$在$A$中无自由出现。&lt;/li&gt;
&lt;li&gt;证明：存在一种方法能击败所有敌人，那么所有敌人都存在一种方法让其被击败。&lt;/li&gt;
&lt;li&gt;证明：$\exists x(A\wedge B)\vdash\exists xA\wedge\exists xB$&lt;/li&gt;
&lt;li&gt;证明：$\Gamma=${$\exists x(P(x)\wedge\forall y(D(y)\rightarrow L(x,y))),\forall x\forall y(P(x)\wedge Q(y)\rightarrow\neg L(x,y))$}，则有$\Gamma\vdash\forall y(D(y)\rightarrow\neg Q(y))$。&lt;/li&gt;
&lt;li&gt;证明：$\Gamma=${$P(Sam),G(Clyde)\wedge L(Clyde,Oscar),(P(Oscar)\oplus G(Oscar))\wedge L(Oscar,Sam)$}，则有$\Gamma\vdash\exists x\exists y(G(x)\wedge P(y)\wedge L(x,y))$，注：$\oplus$表示联结词中的“异或”。&lt;/li&gt;
&lt;li&gt;证明：$\Gamma=${$\forall x(N(x)\rightarrow E(x)\oplus O(x)),\forall x(N(x)\rightarrow(E(x)\leftrightarrow G(x))),\neg\forall x(N(x)\rightarrow G(x))$}，则有$\Gamma\vdash\exists x(N(x)\wedge O(x))$。&lt;/li&gt;
&lt;li&gt;证明：有二元关系$R$，若$R$是传递且反自反的，那么它是非对称的。&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>ND(自然演绎推理系统)及其相关定理</title>
        <link>https://0x3a0x29.github.io/p/naturaldeduction/</link>
        <pubDate>Tue, 19 Dec 2023 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/p/naturaldeduction/</guid>
        <description>&lt;img src="https://0x3a0x29.github.io/p/naturaldeduction/image.png" alt="Featured image of post ND(自然演绎推理系统)及其相关定理" /&gt;&lt;h1 id=&#34;nd及其相关定理&#34;&gt;ND及其相关定理
&lt;/h1&gt;&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;水平有限，存在的错误和不足请大家指正。&lt;/p&gt;
&lt;p&gt;本篇所述皆来自于笔者于23年学校开设的《数理逻辑》课程中讲解内容。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识
&lt;/h2&gt;&lt;p&gt;命题：能唯一确定真假值的陈述句。&lt;/p&gt;
&lt;p&gt;原子命题：不能分解为更简单的陈述句的命题。&lt;/p&gt;
&lt;p&gt;复合命题：由联结词及简单命题构成的命题。&lt;/p&gt;
&lt;p&gt;命题变元：用来表示命题的英文字母。&lt;/p&gt;
&lt;p&gt;联结词：（下列的$A,B$为命题变元）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;否定词$\neg$：表示“非”，如$\neg A$表示“对$A$的否定”。&lt;/li&gt;
&lt;li&gt;合取词$\wedge$：表示“与”，如$A\wedge B$表示“$A$与$B$”。&lt;/li&gt;
&lt;li&gt;析取词$\vee$：表示“或”，如$A\vee B$表示“$A$或$B$”。&lt;/li&gt;
&lt;li&gt;蕴涵词$\rightarrow$：表示“如果……那么”，如$A\rightarrow B$表示“如果$A$，那么$B$”，其中$A$被称为前件，$B$被称为后件。&lt;/li&gt;
&lt;li&gt;双条件词$\leftrightarrow$：表示“当且仅当”，如$A\leftrightarrow B$表示“$A$当且仅当$B$”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为表示方便，我们约定联结词的运算优先级从高到低为$\neg,(\wedge,\vee),\rightarrow,\leftrightarrow$&lt;/p&gt;
&lt;p&gt;命题公式的定义：&lt;/p&gt;
&lt;p&gt;（1）原子命题是命题公式&lt;/p&gt;
&lt;p&gt;（2）若$A,B$是命题公式，那么$\neg A,A\wedge B,A\vee B,A\rightarrow B,A\leftrightarrow B$也是命题公式&lt;/p&gt;
&lt;p&gt;（3）有限次的使用（1）（2）进行复合得到的结果也是命题公式&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;自然演绎推理系统nd的简单介绍&#34;&gt;自然演绎推理系统ND的简单介绍
&lt;/h2&gt;&lt;p&gt;与之前介绍的PC一样，自然演绎推理系统ND（natural deduction）也是一种形式系统，相较于PC而言，ND是一个更加实用、比较符合人的思维模式的推理演算系统，ND的规则和直观含义都比较明显，我们先简单介绍一下ND的组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;字符集：包括原子变元符$p_1,p_2,\cdots,p_n,\cdots$、联结词完备集{$\neg,\wedge,\vee,\rightarrow,\leftrightarrow$}、辅助符号$(,)$&lt;/li&gt;
&lt;li&gt;形成规则：由原子变元符及联结词形成命题公式的规则，即上文提到的命题公式的定义&lt;/li&gt;
&lt;li&gt;公理：设$A$为可以表达任意命题公式的语法变元，$\Gamma$是一个公式集，在ND中只有一个公理（也有人把这个公理变形为推理规则，这样的ND的公理集就是$\varnothing$）：
$\Gamma;A\vdash A(\in)$&lt;/li&gt;
&lt;li&gt;推理规则：用于从已有的公理和已推出的结论来推理另一结论。相较于PC，在ND中多了很多推理规则，这也使得ND更加符合我们的思维模式。
&lt;ol&gt;
&lt;li&gt;假设引入规则${\frac{\Gamma\vdash B}{\Gamma;A\vdash B}}(+)$&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;假设消除规则&lt;/strong&gt;${\frac{\Gamma;A\vdash B,\Gamma;\neg A\vdash B}{\Gamma\vdash B}}(-)$&lt;/li&gt;
&lt;li&gt;$\vee$引入规则${\frac{\Gamma\vdash A}{\Gamma\vdash A\vee B},\frac{\Gamma\vdash A}{\Gamma\vdash B\vee A}}(\vee+)$&lt;/li&gt;
&lt;li&gt;$\vee$&lt;strong&gt;消除规则&lt;/strong&gt;${\frac{\Gamma;A\vdash C,\Gamma;B\vdash C,\Gamma\vdash A\vee B}{\Gamma\vdash C}}(\vee-)$&lt;/li&gt;
&lt;li&gt;$\wedge$引入规则${\frac{\Gamma\vdash A,\Gamma\vdash B}{\Gamma\vdash A\wedge B}}(\wedge+)$&lt;/li&gt;
&lt;li&gt;$\wedge$消除规则${\frac{\Gamma\vdash A\wedge B}{\Gamma\vdash A},\frac{\Gamma\vdash A\wedge B}{\Gamma\vdash B}}(\wedge -)$&lt;/li&gt;
&lt;li&gt;$\rightarrow$引入规则${\frac{\Gamma;A\vdash B}{\Gamma\vdash A\rightarrow B}}(\rightarrow+)$&lt;/li&gt;
&lt;li&gt;$\rightarrow$消除规则${\frac{\Gamma\vdash A,\Gamma\vdash A\rightarrow B}{\Gamma\vdash B}}(\rightarrow-)$&lt;/li&gt;
&lt;li&gt;$\neg$&lt;strong&gt;引入规则&lt;/strong&gt;${\frac{\Gamma;A\vdash B,\Gamma;A\vdash\neg B}{\Gamma\vdash\neg A}}(\neg+)$&lt;/li&gt;
&lt;li&gt;$\neg$消除规则${\frac{\Gamma\vdash A,\Gamma\vdash\neg A}{\Gamma\vdash B}}(\neg-)$&lt;/li&gt;
&lt;li&gt;$\neg\neg$引入规则${\frac{\Gamma\vdash A}{\Gamma\vdash\neg\neg A}}(\neg\neg+)$&lt;/li&gt;
&lt;li&gt;$\neg\neg$消除规则${\frac{\Gamma\vdash\neg\neg A}{\Gamma\vdash A}}(\neg\neg-)$&lt;/li&gt;
&lt;li&gt;$\leftrightarrow$引入规则${\frac{\Gamma\vdash A\rightarrow B,\Gamma\vdash B\rightarrow A}{\Gamma\vdash A\leftrightarrow B}}(\leftrightarrow+)$&lt;/li&gt;
&lt;li&gt;$\leftrightarrow$消除规则${\frac{\Gamma\vdash A\leftrightarrow B}{\Gamma\vdash A\rightarrow B},\frac{\Gamma\vdash A\leftrightarrow B}{\Gamma\vdash B\rightarrow A}}(\leftrightarrow-)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;定理推导：包括所有的推理结论及其推理过程。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们现在对这里的14个推理规则的意义进行解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$(+)$规则：考虑重言式$B\rightarrow(A\rightarrow B)$&lt;/li&gt;
&lt;li&gt;$(-)$规则：人在推理中引入假设$A$或者引入假设$\neg A$并不影响$B$的推导&lt;/li&gt;
&lt;li&gt;$(\vee+)$规则：考虑重言式$A\rightarrow A\vee B$和$A\rightarrow B\vee A$&lt;/li&gt;
&lt;li&gt;$(\vee-)$规则：考虑重言式$(A\rightarrow C)\wedge(B\rightarrow C)(A\vee B)\rightarrow C$&lt;/li&gt;
&lt;li&gt;$(\wedge+)$规则：考虑重言式$A\rightarrow(B\rightarrow A\wedge B)$&lt;/li&gt;
&lt;li&gt;$(\wedge-)$规则：考虑重言式$A\wedge B\rightarrow A$和$A\wedge B\rightarrow B$&lt;/li&gt;
&lt;li&gt;$(\rightarrow+)$规则：考虑PC中的演绎定理&lt;/li&gt;
&lt;li&gt;$(\rightarrow-)$规则：考虑PC中的分离规则&lt;/li&gt;
&lt;li&gt;$(\neg+)$规则：实际上就是反证法&lt;/li&gt;
&lt;li&gt;$(\neg-)$规则：考虑重言式$\neg A\rightarrow(A\rightarrow B)$&lt;/li&gt;
&lt;li&gt;$(\neg\neg+)$规则：考虑重言式$A\rightarrow\neg\neg A$&lt;/li&gt;
&lt;li&gt;$(\neg\neg-)$规则：考虑重言式$\neg\neg A\rightarrow A$&lt;/li&gt;
&lt;li&gt;$(\leftrightarrow+)$规则：考虑重言式$((A\rightarrow B)\wedge(B\rightarrow A))\rightarrow(A\leftrightarrow B)$&lt;/li&gt;
&lt;li&gt;$(\leftrightarrow-)$规则：考虑重言式$(A\leftrightarrow B)\rightarrow((A\rightarrow B)\wedge(B\rightarrow A))$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;逻辑推理相关的基本定义&#34;&gt;逻辑推理相关的基本定义
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;演绎&lt;/strong&gt;：在ND中，若有$\Gamma\vdash_{ND}A$，即存在序列：$\Gamma_1\vdash A_1,\Gamma_2\vdash A_2,\cdots,\Gamma_m\vdash A_m$使得$\Gamma_i\vdash A_i$或为ND的公理，或为$\Gamma_i\vdash A_i(j&amp;lt; i)$，或为$\Gamma_{j_1}\vdash A_{j_1},\cdots,\Gamma_{j_k}\vdash A_{j_k}(j_1,\cdots,j_k&amp;lt; i)$使用推理规则导出的。当$\Gamma=\varnothing$时我们记作$\vdash_{ND}A$，称$A$为ND的&lt;strong&gt;定理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;例：证明$A\vdash_{ND}B\rightarrow A$（这个定理说明了我们对一个定理增添前件后任旧是一个定理）。也就是说我们已经知道$A$成立了，现在要推出$B\rightarrow A$也成立，这个过程都要在ND中进行，故我们要在ND中构造一个演绎序列使得最后一个是$\vdash A\rightarrow(B\rightarrow A)$，一个可行的序列如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A,B\vdash A$,$(\in)$                                    （这是公理$(\in)$）&lt;/li&gt;
&lt;li&gt;$A\vdash B\rightarrow A$,$(\rightarrow+)(1)$             （对$(1)$使用$\rightarrow+$规则）&lt;/li&gt;
&lt;li&gt;$\vdash A\rightarrow(B\rightarrow A)$,$(\rightarrow)(2)$ （对$(2)$使用$\rightarrow+$规则）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;nd中的基本定理&#34;&gt;ND中的基本定理
&lt;/h2&gt;&lt;p&gt;在ND中直接使用公理和推理规则得出ND中的定理会非常繁琐，其中有不少步骤遵循相同的模式，下列总结了ND中10个基本定理，用于帮助寻找ND的定理：&lt;/p&gt;
&lt;p&gt;$Th1$：$\vdash_{ND}A\vee\neg A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vdash A\wedge\neg A$,$(\vee+)(1)$&lt;/li&gt;
&lt;li&gt;$\neg A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vdash A\vee\neg A$,$(\vee+)(3)$&lt;/li&gt;
&lt;li&gt;$\vdash A\vee\neg A$,$(-)(2)(4)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th2$：$\vdash_{ND}\neg(A\vee B)\leftrightarrow(\neg A\wedge\neg B)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg(A\vee B),A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B),A\vdash A\vee B$,$(\vee+)(1)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B),A\vdash\neg(A\vee B)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B)\vdash\neg A$,$(\neg+)(2)(3)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B),B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B),B\vdash A\vee B$,$(\vee+)(5)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B),B\vdash\neg(A\vee B)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B)\vdash\neg B$,$(\neg+)(6)(7)$&lt;/li&gt;
&lt;li&gt;$\neg(A\vee B)\vdash\neg A\wedge\neg B$,$(\wedge+)(4)(8)$&lt;/li&gt;
&lt;li&gt;$\vdash\neg(A\vee B)\rightarrow(\neg A\wedge\neg B)$,$(\rightarrow+)(9)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,A\vdash\neg A\wedge\neg B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,A\vdash\neg A$,$(\wedge-)(12)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,A\vdash A\wedge\neg A$,$(\wedge+)(11)(13)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,B\vdash\neg A\wedge\neg B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,B\vdash\neg B$,$(\wedge-)(16)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B,A\vdash A\wedge\neg A$,$(\neg-)(15)(17)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B\vdash A\vee B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B\vdash A\wedge\neg A$,$(\vee-)(14)(18)(19)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B\vdash A$,$(\wedge-)(20)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B,A\vee B\vdash\neg A$,$(\wedge-)(20)$&lt;/li&gt;
&lt;li&gt;$\neg A\wedge\neg B\vdash\neg(A\vee B)$,$(\neg+)(21)(22)$&lt;/li&gt;
&lt;li&gt;$\vdash(\neg A\wedge\neg B)\rightarrow\neg(A\vee B)$,$(\rightarrow+)(23)$&lt;/li&gt;
&lt;li&gt;$\vdash\neg(A\vee B)\leftrightarrow(\neg A\wedge\neg B)$,$(\leftrightarrow+)(10)(24)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th3$：$\vdash_{ND}\neg(A\wedge B)\leftrightarrow(\neg A\vee\neg B)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg(A\wedge B),A,B\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),A,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),A,B\vdash A\wedge B$,$(\wedge+)(1)(2)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),A,B\vdash\neg(A\wedge B)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),A\vdash\neg B$,$(\neg+)(3)(4)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),A\vdash\neg A\vee\neg B$,$(\vee+)(5)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),\neg A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B),\neg A\vdash\neg A\vee\neg B$,$(\vee+)(7)$&lt;/li&gt;
&lt;li&gt;$\neg(A\wedge B)\vdash\neg A\vee\neg B$,$(-)(6)(8)$&lt;/li&gt;
&lt;li&gt;$\vdash\neg(A\wedge B)\rightarrow(\neg A\vee\neg B)$,$(\rightarrow+)(9)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg A,A\wedge B\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg A,A\wedge B\vdash A\wedge B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg A,A\wedge B\vdash A$,$(\wedge-)(12)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg A\vdash\neg(A\wedge B)$,$(\neg+)(11)(13)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg B,A\wedge B\vdash\neg B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg B,A\wedge B\vdash A\wedge B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg B,A\wedge B\vdash B$,$(\wedge-)(16)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B,\neg B\vdash\neg(A\wedge B)$,$(\neg+)(15)(17)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B\vdash\neg A\vee\neg B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee\neg B\vdash\neg(A\wedge B)$,$(\vee-)(14)(18)(19)$&lt;/li&gt;
&lt;li&gt;$\vdash(\neg A\vee\neg B)\rightarrow\neg(A\wedge B)$,$(\rightarrow+)(20)$&lt;/li&gt;
&lt;li&gt;$\vdash(\neg A\vee\neg b)\leftrightarrow\neg(A\wedge B)$,$(\leftrightarrow+)(10)(21)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th4$：$\neg A\rightarrow B\vdash\dashv_{ND} A\vee B$，这里的$P\vdash\dashv_{ND}Q$当且仅当$P\vdash_{ND}Q$且$Q\vdash_{ND}P$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow B,\neg A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow B,\neg A\vdash\neg A\rightarrow B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow B,\neg A\vdash B$,$(\rightarrow-)(1)(2)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow B,\neg A\vdash A\vee B$,$(\vee+)(3)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow B,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow B,A\vdash A\vee B$,$(\vee+)(5)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow B\vdash A\vee B$,$(-)(4)(6)$&lt;/li&gt;
&lt;li&gt;$A\vee B,\neg A,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee B,\neg A,A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee B,\neg A,A\vdash B$,$(\neg-)(8)(9)$&lt;/li&gt;
&lt;li&gt;$A\vee B,\neg A,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee B,\neg A\vdash A\vee B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee B,\neg A\vdash B$,$(\vee-)(8)(11)(12)$&lt;/li&gt;
&lt;li&gt;$A\vee B\vdash \neg A\rightarrow B$,$(\rightarrow+)(13)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th5$：$A\rightarrow B\vdash\dashv_{ND}\neg A\vee B$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow B,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B,A\vdash A\rightarrow B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B,A\vdash B$,$(\rightarrow-)(1)(2)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B,A\vdash\neg A\vee B$,$(\vee+)(3)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B,\neg A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B,\neg A\vdash\neg A\vee B$,$(\vee+)(5)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B\vdash\neg A\vee B$,$(-)(4)(6)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B,\neg A,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B,\neg A,A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B,\neg A,A\vdash B$,$(\neg-)(8)(9)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B,A,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B,A\vdash\neg A\vee B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B,A\vdash B$,$(\vee-)(8)(11)(12)$&lt;/li&gt;
&lt;li&gt;$\neg A\vee B\vdash A\rightarrow B$,$(\rightarrow+)(13)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th6$：$\vdash_{ND}A\wedge(B\vee C)\leftrightarrow(A\wedge B)\vee(A\wedge C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\wedge(B\vee C),B\vdash A\wedge(B\vee C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),B\vdash A$,$(\wedge-)(1)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),B\vdash A\wedge B$,$(\wedge+)(2)(3)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),B\vdash(A\wedge B)\vee(A\wedge C)$,$(\vee+)(4)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),C\vdash A\wedge(B\vee C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),C\vdash A$,$(\wedge-)(6)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),C\vdash C$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),C\vdash A\wedge C$,$(\wedge+)(7)(8)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C),C\vdash(A\wedge B)\vee(A\wedge C)$,$(\vee+)(9)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C)\vdash A\wedge(B\vee C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C)\vdash B\vee C$,$(\wedge-)(11)$&lt;/li&gt;
&lt;li&gt;$A\wedge(B\vee C)\vdash(A\wedge B)\vee(A\wedge C)$,$(\vee-)(5)(10)(12)$&lt;/li&gt;
&lt;li&gt;$\vdash A\wedge(B\vee C)\rightarrow(A\wedge B)\vee(A\wedge C)$,$(\rightarrow+)(13)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge B\vdash A\wedge B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge B\vdash B$,$(\wedge-)(15)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge B\vdash B\vee C$,$(\vee+)(16)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge B\vdash A$,$(\wedge-)(15)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge B\vdash A\wedge(B\vee C)$,$(\wedge+)(17)(18)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge C\vdash A\wedge C$,$(\in)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge C\vdash C$,$(\wedge-)(20)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge C\vdash B\vee C$,$(\vee+)(21)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge C\vdash A$,$(\wedge-)(20)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C),A\wedge C\vdash A\wedge(B\vee C)$,$(\wedge+)(22)(23)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C)\vdash(A\wedge B)\vee(A\wedge C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$(A\wedge B)\vee(A\wedge C)\vdash A\wedge(B\vee C)$,$(\vee-)(19)(24)(25)$&lt;/li&gt;
&lt;li&gt;$\vdash(A\wedge B)\vee(A\wedge C)\rightarrow A\wedge(B\vee C)$,$(\rightarrow+)(26)$&lt;/li&gt;
&lt;li&gt;$\vdash A\wedge(B\vee C)\leftrightarrow(A\wedge B)\vee(A\wedge C)$,$(\leftrightarrow+)(14)(27)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th7$：$\vdash_{HD}A\vee(B\wedge C)\leftrightarrow(A\vee B)\wedge(A\vee C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\vee(B\wedge C),B\wedge C\vdash B\wedge C$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),B\wedge C\vdash B$,$(\wedge-)(1)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),B\wedge C\vdash A\vee B$,$(\vee+)(2)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),B\wedge C\vdash C$,$(\wedge-)(1)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),B\wedge C\vdash A\vee C$,$(\vee+)(4)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),B\wedge C\vdash (A\vee B)\wedge(A\vee C)$,$(\wedge+)(3)(5)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),A\vdash A\vee B$,$(\vee+)(7)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),A\vdash A\vee C$,$(\vee+)(7)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C),A\vdash(A\vee B)\wedge(A\vee C)$,$(\wedge+)(8)(9)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C)\vdash A\vee(B\wedge C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vee(B\wedge C)\vdash(A\vee B)\wedge(A\vee C)$,$(\vee-)(6)(10)(11)$&lt;/li&gt;
&lt;li&gt;$\vdash A\vee(B\wedge C)\rightarrow(A\vee B)\wedge(A\vee C)$,$(\rightarrow+)(12)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A,A\vee B\vdash\neg A\rightarrow B$,$Th4$（这里存在着一个对应的演绎序列，这里实际上是一种简写，后面的证明中我们也这样简写）&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash(A\vee B)\rightarrow(\neg A\rightarrow B)$,$(\rightarrow+)(14)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash(A\vee B)\wedge(A\vee C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash A\vee B$,$(\wedge-)(16)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash\neg A\rightarrow B$,$(\rightarrow-)(15)(17)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash B$,$(\rightarrow-)(18)(19)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A,A\vee C\vdash\neg A\rightarrow C$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash(A\vee C)\rightarrow(\neg A\rightarrow C)$,$(\rightarrow+)(21)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash A\vee C$,$(\wedge-)(16)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash\neg A\rightarrow C$,$(\rightarrow-)(22)(23)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash C$,$(\rightarrow-)(19)(24)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash B\wedge C$,$(\wedge+)(20)(25)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\neg A\vdash A\vee(B\wedge C)$,$(\vee+)(26)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),A\vdash A\vee(B\wedge C)$,$(\vee+)(28)$&lt;/li&gt;
&lt;li&gt;$(A\vee B)\wedge(A\vee C),\vdash A\vee(B\wedge C)$,$(-)(27)(29)$&lt;/li&gt;
&lt;li&gt;$\vdash(A\vee B)\wedge(A\vee C)\rightarrow A\vee(B\wedge C)$,$(\rightarrow+)(30)$&lt;/li&gt;
&lt;li&gt;$\vdash A\vee(B\wedge C)\leftrightarrow(A\vee B)\wedge(A\vee C)$,$(\leftrightarrow+)(13)(31)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;从上面的7个定理的证明中我们可以发现，和PC相比，ND的证明思路更加符合我们的思维模式，事实上能通过PC证明的定理在ND中也可以证明出来，为了证明这个事实，我们不妨在ND中尝试证明PC中使用到的3个公理。&lt;/p&gt;
&lt;p&gt;$Th8$：$\vdash_{ND}A\rightarrow(B\rightarrow A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A,B\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\vdash B\rightarrow A$,$(\rightarrow+)(1)$&lt;/li&gt;
&lt;li&gt;$\vdash A\rightarrow(B\rightarrow A)$,$(\rightarrow+)(2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th9$：$\vdash_{ND}(A\rightarrow(B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B,A\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B,A\vdash A\rightarrow B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B,A\vdash B$,$(\rightarrow-)(1)(2)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B,A\vdash A\rightarrow(B\rightarrow C)$,$(\in)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B,A\vdash B\rightarrow C$,$(\rightarrow-)(1)(4)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B,A\vdash C$,$(\rightarrow-)(3)(5)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),A\rightarrow B\vdash A\rightarrow C$,$(\rightarrow+)(6)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C),\vdash(A\rightarrow B)\rightarrow(A\rightarrow C)$,$(\rightarrow+)(7)$&lt;/li&gt;
&lt;li&gt;$\vdash(A\rightarrow(B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$(\rightarrow+)(8)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th10$：$\vdash_{ND}(\neg A\rightarrow\neg B)\rightarrow(B\rightarrow A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,\neg A,B\vdash\neg A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,\neg A,B\vdash\neg A\rightarrow\neg B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,\neg A,B\vdash\neg B$,$(\rightarrow-)(1)(2)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,\neg A,B\vdash B$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,\neg A,B\vdash A$,$(\neg-)(3)(4)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,A,B\vdash A$,$(\in)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B,B\vdash A$,$(-)(5)(6)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg B\vdash B\rightarrow A$,$(\rightarrow+)(7)$&lt;/li&gt;
&lt;li&gt;$\vdash(\neg A\rightarrow\neg B)\rightarrow(B\rightarrow A)$,$(\rightarrow+)(8)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&#34;nd定理证明习题选&#34;&gt;ND定理证明习题选
&lt;/h2&gt;&lt;p&gt;下面给出了六道ND定理习题供读者练习使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明：$\vdash_{ND}A\rightarrow(B\rightarrow C)\leftrightarrow(A\wedge B\rightarrow C)$&lt;/li&gt;
&lt;li&gt;证明：$A\rightarrow B,\neg(B\rightarrow C)\rightarrow\neg A\vdash_{ND}A\rightarrow C$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{ND}(A\vee B)\wedge(\neg B\vee C)\rightarrow A\vee C$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{ND}(A\wedge B)\leftrightarrow A\wedge(\neg A\vee B)$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{ND}((A\leftrightarrow B)\leftrightarrow A)\leftrightarrow B$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{ND}(A\leftrightarrow\neg B)\leftrightarrow\neg(A\leftrightarrow B)$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>PC(命题逻辑演算形式系统)及其相关定理</title>
        <link>https://0x3a0x29.github.io/p/propositionalcalculus/</link>
        <pubDate>Mon, 18 Dec 2023 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/p/propositionalcalculus/</guid>
        <description>&lt;img src="https://0x3a0x29.github.io/p/propositionalcalculus/23.png" alt="Featured image of post PC(命题逻辑演算形式系统)及其相关定理" /&gt;&lt;h1 id=&#34;pc及其相关定理&#34;&gt;PC及其相关定理
&lt;/h1&gt;&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;水平有限，存在的错误和不足请大家指正。&lt;/p&gt;
&lt;p&gt;本篇所述皆来自于笔者于23年学校开设的《数理逻辑》课程中讲解内容。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基础知识&#34;&gt;基础知识
&lt;/h2&gt;&lt;p&gt;命题：能唯一确定真假值的陈述句。&lt;/p&gt;
&lt;p&gt;原子命题：不能分解为更简单的陈述句的命题。&lt;/p&gt;
&lt;p&gt;复合命题：由联结词及简单命题构成的命题。&lt;/p&gt;
&lt;p&gt;命题变元：用来表示命题的英文字母。（下列的$A,B$为命题变元）&lt;/p&gt;
&lt;p&gt;联结词：有五种常用的联结词，如下所示。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;否定词&lt;/strong&gt;$\neg$：表示“非”，如$\neg A$表示“对$A$的否定”。&lt;/li&gt;
&lt;li&gt;合取词$\wedge$：表示“与”，如$A\wedge B$表示“$A$与$B$”。&lt;/li&gt;
&lt;li&gt;析取词$\vee$：表示“或”，如$A\vee B$表示“$A$或$B$”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;蕴涵词&lt;/strong&gt;$\rightarrow$：表示“如果……那么”，如$A\rightarrow B$表示“如果$A$，那么$B$”，其中$A$被称为前件，$B$被称为后件。&lt;/li&gt;
&lt;li&gt;双条件词$\leftrightarrow$：表示“当且仅当”，如$A\leftrightarrow B$表示“$A$当且仅当$B$”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为表示方便，我们约定联结词的运算优先级从高到低为$\neg,(\wedge,\vee),\rightarrow,\leftrightarrow$&lt;/p&gt;
&lt;p&gt;命题公式的定义：&lt;/p&gt;
&lt;p&gt;（1）原子命题是命题公式。&lt;/p&gt;
&lt;p&gt;（2）若$A,B$是命题公式，那么$\neg A,A\wedge B,A\vee B,A\rightarrow B,A\leftrightarrow B$也是命题公式。&lt;/p&gt;
&lt;p&gt;（3）有限次的使用（1）（2）进行复合得到的结果也是命题公式。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;命题逻辑演算形式系统pc的简单介绍&#34;&gt;命题逻辑演算形式系统PC的简单介绍
&lt;/h2&gt;&lt;p&gt;命题逻辑演算形式系统PC（propositional calculus）是一种形式系统，我们先简单介绍一下PC的组成部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;字符集：包括原子变元符$p_1,p_2,\cdots,p_n,\cdots$、联结词完备集{$\neg,\rightarrow$}、辅助符号$(,)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;形成规则：由原子变元符及联结词形成命题公式的规则，即上文提到的命题公式的定义&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公理：设$A,B,C$为可以表达任意命题公式的语法变元，那么PC中有三个公理
$A1:A\rightarrow (B\rightarrow A)$&lt;/p&gt;
&lt;p&gt;$A2:(A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;$A3:(\neg A\rightarrow\neg B)\rightarrow (B\rightarrow A)$&lt;/p&gt;
&lt;p&gt;$A1$的含义是：如果$A$成立，那么已知$B$成立的前提下$A$任旧成立。&lt;/p&gt;
&lt;p&gt;$A2$的含义是：如果$A$成立能使得只需要$B$成立那么$C$就会成立，那么如果$A$能推出$B$、$A$就能推出$C$。&lt;/p&gt;
&lt;p&gt;$A3$的含义是：如果$A$不成立能推出$B$不成立，那么$B$成立就能推出$A$成立。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推理规则：用于从已有的公理和已推出的结论来推理另一结论。
在PC中只有分离规则$r_{mp}$：即若有$A$和$A\rightarrow B$成立，那么$B$也成立，形式化的推理序列为：$A,A\rightarrow B,B$。
可以记作$\displaystyle{\frac{A,A\rightarrow B}{B}}$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定理推导：包括所有的推理结论及其推理过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h2 id=&#34;逻辑推理相关的基本定义&#34;&gt;逻辑推理相关的基本定义
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;证明&lt;/strong&gt;：称以下公式序列为公式$A$在PC中的一个证明：$A_1,A_2,\cdots,A_{m-1},A$，其中$A_i$或为PC的公理、或为$A_j(j&amp;lt; i)$、或为$A_j,A_k(j,k&amp;lt; i)$通过形成规则得到的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定理&lt;/strong&gt;：公式$A$在PC中有一个证明序列，那么它就是PC的定理，我们记为$\vdash_{PC}A$。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;演绎&lt;/strong&gt;：设$\Gamma$为PC中若干公式构成的公式集，则称下列公式序列为公式$A$以$\Gamma$为前提的演绎：$A_1,A_2,\cdots,A_{m-1},A$，其中$A_i$或为PC的公理、或为$\Gamma$中的成员、或为$A_j(j&amp;lt; i)$、或为$A_j,A_k(j,k&amp;lt; i)$通过分离规则得到的。我们可以记为$\Gamma\vdash_{PC}A$。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例：证明$A\vdash_{PC}B\rightarrow A$（这个定理说明了我们对一个定理增添前件后任旧是一个定理）。也就是说我们已经知道$A$成立了，现在要推出$B\rightarrow A$也成立，这个过程都要在PC中进行，故我们要在PC中构造一个演绎序列使得最后一个公式是$B\rightarrow A$，一个可行的公式序列如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A$                              （$A$是演绎前提中的成员）&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow A)$,$A1$  （$A\rightarrow(B\rightarrow A)$是公理中的$A1$）&lt;/li&gt;
&lt;li&gt;$B\rightarrow A$,$r_{mp}(1)(2)$   （对公式序列中的$(1)(2)$使用分离规则得到结论$B\rightarrow A$）&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面我们成功构造了一个符合演绎要求的公式序列，也就是说有$A\vdash_{PC}B\rightarrow A$，我们完成了这个例子的证明。&lt;/p&gt;
&lt;p&gt;实际上我们可以证明PC有合理性、一致性、完备性，这表明PC中的定理是永真的、从$\Gamma$演绎出$A$就会有$\Gamma\Rightarrow A$（合理性），PC不会推出相互矛盾的结论（一致性），任何PC中的永真式都是PC的定理（完备性）。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pc的基本定理&#34;&gt;PC的基本定理
&lt;/h2&gt;&lt;p&gt;在PC中直接使用公理和推理规则得出PC中的定理会非常繁琐，其中有不少步骤遵循相同的模式，下列总结了PC中35个基本定理（其中7个定理较为重要），用于帮助寻找PC的定理：&lt;/p&gt;
&lt;p&gt;$Th1$：$\vdash_{PC}A\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow A)$,$A1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow((B\rightarrow A)\rightarrow A)$,$A1$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow((B\rightarrow A)\rightarrow A))\rightarrow((A\rightarrow(B\rightarrow A))\rightarrow(A\rightarrow A))$,$A2$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow A))\rightarrow(A\rightarrow A)$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow A$,$r_{mp}(1)(4)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;前件互换定理&#34;&gt;前件互换定理
&lt;/h3&gt;&lt;p&gt;$Th2$：若$\vdash_{PC}A\rightarrow(B\rightarrow C)$，则$\vdash_{PC}B\rightarrow(A\rightarrow C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$A2$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(A\rightarrow C)$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow B)\rightarrow(A\rightarrow C))\rightarrow(B\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C)))$,$A1$&lt;/li&gt;
&lt;li&gt;$B\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C)))\rightarrow((B\rightarrow(A\rightarrow B))\rightarrow(B\rightarrow(A\rightarrow C)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow(A\rightarrow B))\rightarrow(B\rightarrow(A\rightarrow C))$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(A\rightarrow B)$,$A1$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(A\rightarrow C)$,$r_{mp}(7)(8)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th3$：$\vdash_{PC}(A\rightarrow(B\rightarrow C))\rightarrow(B\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$A1$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C))$,$Th2$（因为这是PC中的一个定理，所以它存在一个对应的证明序列，这里实际上是一种简写，不将这个定理对应的证明序列写出，后续的证明中我们也这样简写）&lt;/li&gt;
&lt;li&gt;$((A\rightarrow B)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C)))\rightarrow(B\rightarrow((A\rightarrow B)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C))))$,$A1$&lt;/li&gt;
&lt;li&gt;$B\rightarrow((A\rightarrow B)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C)))$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow((A\rightarrow B)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C))))\rightarrow((B\rightarrow(A\rightarrow B))\rightarrow(B\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C))))$,$A2$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow(A\rightarrow B))\rightarrow(B\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C)))$,$r_{mp}(4)(5)$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(A\rightarrow B)$,$A1$&lt;/li&gt;
&lt;li&gt;$B\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow(A\rightarrow C))$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow (B\rightarrow C))\rightarrow(B\rightarrow(A\rightarrow C))$,$Th2$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;加前件定理&#34;&gt;加前件定理
&lt;/h3&gt;&lt;p&gt;$Th4$：$\vdash_{PC}(B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$A2$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C)))\rightarrow((B\rightarrow C)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))))$,$A1$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C)))$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$((B\rightarrow C)\rightarrow((A\rightarrow (B\rightarrow C))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))))\rightarrow(((B\rightarrow C)\rightarrow((A\rightarrow (B\rightarrow C))))\rightarrow((B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))))$,$A2$&lt;/li&gt;
&lt;li&gt;$((B\rightarrow C)\rightarrow((A\rightarrow (B\rightarrow C))))\rightarrow((B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C)))$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow((A\rightarrow (B\rightarrow C)))$,$A1$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;加后件定理&#34;&gt;加后件定理
&lt;/h3&gt;&lt;p&gt;$Th5$：$\vdash_{PC}(A\rightarrow B)\rightarrow((B\rightarrow C)\rightarrow(A\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow((B\rightarrow C)\rightarrow(A\rightarrow C))$,$Th2$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;三段论定理&#34;&gt;三段论定理
&lt;/h3&gt;&lt;p&gt;$Th6$：$\vdash_{PC}A\rightarrow B,\vdash_{PC}B\rightarrow C$，那么$\vdash_{PC}A\rightarrow C$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$Th4$&lt;/li&gt;
&lt;li&gt;$B\rightarrow C$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(A\rightarrow C)$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow B$&lt;/li&gt;
&lt;li&gt;$A\rightarrow C$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th7$：$\vdash_{PC}\neg A\rightarrow (A\rightarrow B)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow(\neg B\rightarrow\neg A)$,$A1$&lt;/li&gt;
&lt;li&gt;$(\neg B\rightarrow\neg A)\rightarrow (A\rightarrow B)$,$A3$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow(A\rightarrow B)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th8$：$\vdash_{PC}A\rightarrow(\neg A\rightarrow B)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow (A\rightarrow B)$,$Th7$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(\neg A\rightarrow B)$,$Th2$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th9$：$\vdash_{PC}(\neg A\rightarrow A)\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow(A\rightarrow\neg(\neg A\rightarrow A))$,$Th7$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(A\rightarrow\neg(\neg A\rightarrow A)))\rightarrow((\neg A\rightarrow A)\rightarrow(\neg A\rightarrow\neg(\neg A\rightarrow A)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow A)\rightarrow(\neg A\rightarrow\neg(\neg A\rightarrow A))$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow\neg(\neg A\rightarrow A))\rightarrow((\neg A\rightarrow A)\rightarrow A)$,$A3$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow A)\rightarrow((\neg A\rightarrow A)\rightarrow A)$,$Th6$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow A)\rightarrow((\neg A\rightarrow A)\rightarrow A))\rightarrow(((\neg A\rightarrow A)\rightarrow(\neg A\rightarrow A))\rightarrow((\neg A\rightarrow A)\rightarrow A))$,$A2$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow A)\rightarrow(\neg A\rightarrow A))\rightarrow((\neg A\rightarrow A)\rightarrow A)$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow A)\rightarrow(\neg A\rightarrow A)$,$Th1$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow A)\rightarrow A$,$r_{mp}(7)(8)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th10$：$\vdash_{PC}\neg\neg A\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg\neg A\rightarrow(\neg A\rightarrow\neg\neg\neg A)$,$Th7$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow\neg\neg\neg A)\rightarrow(\neg\neg A\rightarrow A)$,$A3$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow(\neg\neg A\rightarrow A)$,$Th6$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow(\neg\neg A\rightarrow A))\rightarrow((\neg\neg A\rightarrow\neg\neg A)\rightarrow(\neg\neg A\rightarrow A))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow\neg\neg A)\rightarrow(\neg\neg A\rightarrow A)$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow\neg\neg A$,$Th1$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow A$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th11$：$\vdash_{PC}(A\rightarrow\neg A)\rightarrow\neg A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg\neg A\rightarrow A$,$Th10$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow A)\rightarrow((A\rightarrow\neg A)\rightarrow(\neg\neg A\rightarrow\neg A))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg A)\rightarrow(\neg\neg A\rightarrow\neg A)$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow\neg A)\rightarrow\neg A$,$Th9$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg A)\rightarrow\neg A$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th12$：$\vdash_{PC}A\rightarrow\neg\neg A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(\neg A\rightarrow\neg\neg A)$,$Th8$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow\neg\neg A)\rightarrow\neg\neg A$,$Th11$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\neg\neg A$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th13$：$\vdash_{PC}(A\rightarrow B)\rightarrow(\neg B\rightarrow\neg A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(\neg\neg A\rightarrow\neg\neg B)\rightarrow(\neg B\rightarrow\neg A)$,$A3$&lt;/li&gt;
&lt;li&gt;$B\rightarrow\neg\neg B$,$Th12$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow\neg\neg B)\rightarrow((\neg\neg A\rightarrow B)\rightarrow(\neg\neg A\rightarrow\neg\neg B))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow B)\rightarrow(\neg\neg A\rightarrow\neg\neg B)$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow B)\rightarrow(\neg B\rightarrow\neg A)$,$Th6$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow A$,$Th10$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow A)\rightarrow((A\rightarrow B)\rightarrow(\neg\neg A\rightarrow B))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(\neg\neg A\rightarrow B)$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(\neg B\rightarrow\neg A)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th14$：$\vdash_{PC}(\neg A\rightarrow B)\rightarrow(\neg B\rightarrow A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(\neg A\rightarrow\neg\neg B)\rightarrow(\neg B\rightarrow A)$,$A3$&lt;/li&gt;
&lt;li&gt;$B\rightarrow\neg\neg B$,$Th12$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow\neg\neg B)\rightarrow((\neg A\rightarrow B)\rightarrow(\neg A\rightarrow\neg\neg B))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow(\neg A\rightarrow\neg\neg B)$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow(\neg B\rightarrow A)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th15$：$\vdash_{PC}(A\rightarrow\neg B)\rightarrow(B\rightarrow\neg A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(\neg\neg A\rightarrow\neg B)\rightarrow(B\rightarrow\neg A)$,$A3$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow A$,$Th10$&lt;/li&gt;
&lt;li&gt;$(\neg\neg A\rightarrow A)\rightarrow((A\rightarrow\neg B)\rightarrow(\neg\neg A\rightarrow\neg B))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow(\neg\neg A\rightarrow\neg B)$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow(B\rightarrow\neg A)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;反证法&#34;&gt;反证法
&lt;/h3&gt;&lt;p&gt;$Th16$：$\vdash_{PC}(\neg A\rightarrow B)\rightarrow((\neg A\rightarrow\neg B)\rightarrow A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(\neg A\rightarrow\neg B)\rightarrow(B\rightarrow A)$,$A3$&lt;/li&gt;
&lt;li&gt;$B\rightarrow((\neg A\rightarrow\neg B)\rightarrow A)$,$Th2$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow\neg B)\rightarrow A)\rightarrow(\neg A\rightarrow\neg(\neg A\rightarrow\neg B))$,$Th13$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(\neg A\rightarrow\neg(\neg A\rightarrow\neg B))$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow(B\rightarrow\neg(\neg A\rightarrow\neg B))$,$Th2$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(B\rightarrow\neg(\neg A\rightarrow\neg B)))\rightarrow((\neg A\rightarrow B)\rightarrow(\neg A\rightarrow\neg(\neg A\rightarrow\neg B)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow(\neg A\rightarrow\neg(\neg A\rightarrow\neg B))$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow\neg(\neg A\rightarrow\neg B))\rightarrow((\neg A\rightarrow\neg B)\rightarrow A)$,$A3$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow((\neg A\rightarrow\neg B)\rightarrow A)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th17$：$\vdash_{PC}(A\rightarrow B)\rightarrow((A\rightarrow\neg B)\rightarrow\neg A)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow((A\rightarrow\neg B)\rightarrow\neg A)$,$Th15$&lt;/li&gt;
&lt;li&gt;$B\rightarrow((A\rightarrow\neg B)\rightarrow\neg A)$,$Th3$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg B)\rightarrow\neg A)\rightarrow(A\rightarrow\neg(A\rightarrow\neg B))$,$Th15$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(A\rightarrow\neg(A\rightarrow\neg B))$,$Th6$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow\neg(A\rightarrow\neg B))$,$Th2$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow\neg(A\rightarrow\neg B)))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow\neg(A\rightarrow\neg B)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(A\rightarrow\neg(A\rightarrow\neg B))$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg(A\rightarrow\neg B))\rightarrow((A\rightarrow\neg B)\rightarrow\neg A)$,$Th15$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow((A\rightarrow\neg B)\rightarrow\neg A)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;拆分&#34;&gt;→拆分
&lt;/h3&gt;&lt;p&gt;$Th18$：$\vdash_{PC}\neg A\rightarrow C,\vdash_{PC}B\rightarrow C$当且仅当$\vdash_{PC}(A\rightarrow B)\rightarrow C$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当$\vdash_{PC}(A\rightarrow B)\rightarrow C$时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow C$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(A\rightarrow B)$,$A1$&lt;/li&gt;
&lt;li&gt;$B\rightarrow C$,$Th6$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow(A\rightarrow B)$,$Th7$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow C$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当$\vdash_{PC}\neg A\rightarrow C,\vdash_{PC}B\rightarrow C$时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow C$&lt;/li&gt;
&lt;li&gt;$B\rightarrow C$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow C))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(A\rightarrow C)$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow C)\rightarrow(\neg C\rightarrow A)$,$Th14$&lt;/li&gt;
&lt;li&gt;$\neg C\rightarrow A$,$r_{mp}(1)(5)$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow A)\rightarrow((A\rightarrow C)\rightarrow(\neg C\rightarrow C))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow C)\rightarrow(\neg C\rightarrow C)$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(\neg C\rightarrow C)$,$Th2$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow C)\rightarrow C$,$Th9$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow C$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th19$：定义$A\vee B =_ {df}\neg A\rightarrow B$，$\vdash_{PC}A\rightarrow A\vee B$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(\neg A\rightarrow B)$,$Th8$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th20$：$\vdash_{PC}A\rightarrow B\vee A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(\neg B\rightarrow A)$,$A1$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th21$：如果$\vdash_{PC}P\rightarrow Q,\vdash_{PC}R\rightarrow S$，那么$\vdash_{PC}(Q\rightarrow R)\rightarrow(P\rightarrow S)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$P\rightarrow Q$&lt;/li&gt;
&lt;li&gt;$(P\rightarrow Q)\rightarrow((Q\rightarrow R)\rightarrow(P\rightarrow R))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(Q\rightarrow R)\rightarrow(P\rightarrow R)$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$R\rightarrow S$&lt;/li&gt;
&lt;li&gt;$(R\rightarrow S)\rightarrow((P\rightarrow R)\rightarrow(P\rightarrow S))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(P\rightarrow R)\rightarrow(P\rightarrow S)$,$r_{mp}(4)(5)$&lt;/li&gt;
&lt;li&gt;$(Q\rightarrow R)\rightarrow(P\rightarrow S)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th22$：$\vdash_{PC}(A\rightarrow C)\rightarrow((B\rightarrow C)\rightarrow((A\vee B)\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow(\neg A\rightarrow B)$,$Th1$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow((\neg A\rightarrow B)\rightarrow B)$,$Th2$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow B)\rightarrow B)\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B))$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B)))\rightarrow(\neg C\rightarrow(\neg A\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B))))$,$A1$&lt;/li&gt;
&lt;li&gt;$\neg C\rightarrow(\neg A\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B)))$,$r_{mp}(4)(5)$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow(\neg A\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B))))\rightarrow((\neg C\rightarrow\neg A)\rightarrow(\neg C\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B))))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow\neg A)\rightarrow(\neg C\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B)))$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow(\neg B\rightarrow\neg(\neg A\rightarrow B)))\rightarrow((\neg C\rightarrow\neg B)\rightarrow(\neg C\rightarrow\neg(\neg A\rightarrow B)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow\neg A)\rightarrow((\neg C\rightarrow\neg B)\rightarrow(\neg C\rightarrow\neg(\neg A\rightarrow B)))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow C)\rightarrow(\neg C\rightarrow\neg A)$,$Th13$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow C)\rightarrow((\neg C\rightarrow\neg B)\rightarrow(\neg C\rightarrow\neg(\neg A\rightarrow B)))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow(\neg C\rightarrow\neg B)$,$Th13$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow\neg(\neg A\rightarrow B))\rightarrow((\neg A\rightarrow B)\rightarrow C)$,$A3$&lt;/li&gt;
&lt;li&gt;$((\neg C\rightarrow(\neg C\rightarrow\neg(\neg A\rightarrow B)))\rightarrow(\neg C\rightarrow\neg B))\rightarrow((B\rightarrow C)\rightarrow((\neg A\rightarrow B)\rightarrow C))$,$Th21$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow C)\rightarrow((B\rightarrow C)\rightarrow((\neg A\rightarrow B)\rightarrow C))$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th23$：
定义$A\wedge B =_ {df} \neg(A\rightarrow\neg B)$，那么$\vdash_{PC}A\wedge B\rightarrow C$当且仅当$\vdash_{PC}A\rightarrow(B\rightarrow C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当$\vdash_{PC}A\wedge B\rightarrow C$时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$\neg(A\rightarrow\neg B)\rightarrow C$&lt;/li&gt;
&lt;li&gt;$(\neg(A\rightarrow\neg B)\rightarrow C)\rightarrow(\neg C\rightarrow(A\rightarrow\neg B))$,$Th14$&lt;/li&gt;
&lt;li&gt;$\neg C\rightarrow(A\rightarrow\neg B)$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(\neg C\rightarrow\neg B)$,$Th2$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow\neg B)\rightarrow(B\rightarrow C)$,$A3$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C)$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当$\vdash_{PC}A\rightarrow(B\rightarrow C)$时：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C)$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow C)\rightarrow(\neg C\rightarrow\neg B)$,$Th13$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(\neg C\rightarrow\neg B)$,$Th6$&lt;/li&gt;
&lt;li&gt;$\neg C\rightarrow(A\rightarrow\neg B)$,$Th2$&lt;/li&gt;
&lt;li&gt;$(\neg C\rightarrow(A\rightarrow\neg B))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow C)$,$Th14$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg B)\rightarrow C$,$r_{mp}(4)(5)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th24$：$\vdash_{PC}A\wedge B\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg A\rightarrow(A\rightarrow\neg B)$,$Th7$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(A\rightarrow\neg B))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow A)$,$Th14$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg B)\rightarrow A$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th25$：$\vdash_{PC}B\wedge A\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$\neg B\rightarrow(A\rightarrow\neg B)$,$A1$&lt;/li&gt;
&lt;li&gt;$(\neg B\rightarrow(A\rightarrow\neg B))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow B)$,$Th14$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg B)\rightarrow B$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th26$：$\vdash_{PC}A\rightarrow(B\rightarrow A\wedge B)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\wedge B\rightarrow A\wedge B$,$Th1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow A\wedge B)$,$Th23$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th27$：$\vdash_{PC}(A\rightarrow B)\rightarrow((A\rightarrow C)\rightarrow(A\rightarrow B\wedge C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$B\rightarrow(C\rightarrow B\wedge C)$,$Th26$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow(C\rightarrow B\wedge C))\rightarrow(A\rightarrow(B\rightarrow(C\rightarrow B\wedge C)))$,$A1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow(C\rightarrow B\wedge C))$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow(C\rightarrow B\wedge C)))\rightarrow((A\rightarrow B)\rightarrow(A\rightarrow(C\rightarrow B\wedge C)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow B)\rightarrow(A\rightarrow(C\rightarrow B\wedge C))$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$A\rightarrow((A\rightarrow B)\rightarrow(C\rightarrow B\wedge C))$,$Th2$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow B)\rightarrow(C\rightarrow B\wedge C))\rightarrow((A\rightarrow C)\rightarrow(A\rightarrow B\wedge C))$,$A2$&lt;/li&gt;
&lt;li&gt;$A\rightarrow((A\rightarrow C)\rightarrow(A\rightarrow B\wedge C))$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th28$：我们将$\vdash_{PC}P\rightarrow Q,\vdash_{PC}Q\rightarrow P$记作$\vdash_{PC}P\leftrightarrow Q$，那么有$\vdash_{PC}A\vee B\leftrightarrow B\vee A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow(\neg B\rightarrow A)$,$Th14$&lt;/li&gt;
&lt;li&gt;$(\neg B\rightarrow A)\rightarrow(\neg A\rightarrow B)$,$Th14$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th29$：$\vdash_{PC}A\wedge B\leftrightarrow B\wedge A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow(B\rightarrow\neg A)$,$Th15$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow\neg A)\rightarrow(A\rightarrow\neg B)$,$Th15$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th30$：$\vdash_{PC}(A\vee B)\vee C\leftrightarrow A\vee(B\vee C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$B\rightarrow(\neg B\rightarrow C)$,$Th8$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow(\neg B\rightarrow C))\rightarrow((\neg A\rightarrow B)\rightarrow(\neg A\rightarrow(\neg B\rightarrow C)))$,$A2$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow(\neg A\rightarrow(\neg B\rightarrow C))$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$\neg\neg(\neg A\rightarrow B)\rightarrow(\neg A\rightarrow B)$,$Th10$&lt;/li&gt;
&lt;li&gt;$\neg\neg(\neg A\rightarrow B)\rightarrow(\neg A\rightarrow(\neg B\rightarrow C))$,$Th6$&lt;/li&gt;
&lt;li&gt;$C\rightarrow(\neg B\rightarrow C)$,$A1$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow(\neg B\rightarrow C))\rightarrow(\neg A\rightarrow(C\rightarrow(\neg B\rightarrow C)))$,$A1$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow(C\rightarrow(\neg B\rightarrow C))$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$C\rightarrow(\neg A\rightarrow(\neg B\rightarrow C))$,$Th2$&lt;/li&gt;
&lt;li&gt;$(\neg(\neg A\rightarrow B)\rightarrow C)\rightarrow(\neg A\rightarrow(\neg B\rightarrow C))$,$Th18$&lt;/li&gt;
&lt;li&gt;$B\rightarrow(\neg A\rightarrow B)$,$A1$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow(\neg A\rightarrow B))\rightarrow(\neg(\neg A\rightarrow B)\rightarrow\neg B)$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(\neg A\rightarrow B)\rightarrow\neg B$,$r_{mp}(11)(12)$&lt;/li&gt;
&lt;li&gt;$(\neg(\neg A\rightarrow B)\rightarrow\neg B)\rightarrow((\neg B\rightarrow C)\rightarrow(\neg(\neg A\rightarrow B)\rightarrow C))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(\neg B\rightarrow C)\rightarrow(\neg(\neg A\rightarrow B)\rightarrow C)$,$r_{mp}(13)(14)$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow(A\rightarrow C)$,$Th7$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(\neg A\rightarrow B)$,$Th8$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(\neg A\rightarrow B))\rightarrow(\neg(\neg A\rightarrow B)\rightarrow\neg A)$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(\neg A\rightarrow B)\rightarrow\neg A$,$r_{mp}(17)(18)$&lt;/li&gt;
&lt;li&gt;$(\neg(\neg A\rightarrow B)\rightarrow\neg A)\rightarrow(A\rightarrow(\neg(\neg A\rightarrow B)\rightarrow\neg A))$,$A1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(\neg(\neg A\rightarrow B)\rightarrow\neg A)$,$r_{mp}(19)(20)$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow A$,$Th10$&lt;/li&gt;
&lt;li&gt;$\neg\neg A\rightarrow(\neg(\neg A\rightarrow B)\rightarrow\neg A)$,$Th6$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(\neg B\rightarrow C))\rightarrow(\neg(\neg A\rightarrow B)\rightarrow C)$,$Th18$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th31$：$\vdash_{PC}(A\wedge B)\wedge C\leftrightarrow A\wedge(B\wedge C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(B\rightarrow\neg C)\rightarrow(C\rightarrow\neg B)$,$Th15$&lt;/li&gt;
&lt;li&gt;$((B\rightarrow\neg C)\rightarrow(C\rightarrow\neg B))\rightarrow((A\rightarrow(B\rightarrow\neg C))\rightarrow(A\rightarrow(C\rightarrow\neg B)))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow\neg C))\rightarrow(A\rightarrow(C\rightarrow\neg B))$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(C\rightarrow\neg B))\rightarrow(C\rightarrow(A\rightarrow\neg B))$,$Th3$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow\neg C))\rightarrow(C\rightarrow(A\rightarrow\neg B))$,$Th6$&lt;/li&gt;
&lt;li&gt;$\neg\neg(B\rightarrow\neg C)\rightarrow(B\rightarrow\neg C)$,$Th10$&lt;/li&gt;
&lt;li&gt;$(\neg\neg(B\rightarrow\neg C)\rightarrow(B\rightarrow\neg C))\rightarrow((A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow(A\rightarrow(B\rightarrow\neg C)))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow(A\rightarrow(B\rightarrow\neg C))$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow(C\rightarrow(A\rightarrow\neg B))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow(A\rightarrow\neg B))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow\neg C)$,$Th13$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow\neg C)$,$Th6$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow\neg C))\rightarrow(\neg(\neg(A\rightarrow\neg B)\rightarrow\neg C)\rightarrow\neg(A\rightarrow\neg\neg(B\rightarrow\neg C)))$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(\neg(A\rightarrow\neg B)\rightarrow\neg C)\rightarrow\neg(A\rightarrow\neg\neg(B\rightarrow\neg C))$,$r_{mp}(11)(12)$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow\neg B)\rightarrow(B\rightarrow\neg C)$,$Th15$&lt;/li&gt;
&lt;li&gt;$((C\rightarrow\neg B)\rightarrow(B\rightarrow\neg C))\rightarrow((A\rightarrow(C\rightarrow\neg B))\rightarrow(A\rightarrow(B\rightarrow\neg C)))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(C\rightarrow\neg B))\rightarrow(A\rightarrow(B\rightarrow\neg C))$,$r_{mp}(14)(15)$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow(A\rightarrow\neg B))\rightarrow(A\rightarrow(C\rightarrow\neg B))$,$Th3$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow(A\rightarrow\neg B))\rightarrow(A\rightarrow(B\rightarrow\neg C))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow\neg C)\rightarrow\neg\neg(B\rightarrow\neg C)$,$Th12$&lt;/li&gt;
&lt;li&gt;$((B\rightarrow\neg C)\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow((A\rightarrow(B\rightarrow\neg C))\rightarrow(A\rightarrow\neg\neg(B\rightarrow\neg C)))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow\neg C))\rightarrow(A\rightarrow\neg\neg(B\rightarrow\neg C))$,$r_{mp}(19)(20)$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow(A\rightarrow\neg B))\rightarrow(A\rightarrow\neg\neg(B\rightarrow\neg C))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(\neg(A\rightarrow\neg B)\rightarrow\neg C)\rightarrow(C\rightarrow(A\rightarrow\neg B))$,$A3$&lt;/li&gt;
&lt;li&gt;$(\neg(A\rightarrow\neg B)\rightarrow\neg C)\rightarrow(A\rightarrow\neg\neg(B\rightarrow\neg C))$,$Th6$&lt;/li&gt;
&lt;li&gt;$((\neg(A\rightarrow\neg B)\rightarrow\neg C)\rightarrow(A\rightarrow\neg\neg(B\rightarrow\neg C)))\rightarrow(\neg(A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow\neg(\neg(A\rightarrow\neg B)\rightarrow\neg C))$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg\neg(B\rightarrow\neg C))\rightarrow\neg(\neg(A\rightarrow\neg B)\rightarrow\neg C)$,$r_{mp}(24)(25)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th32$：$\vdash_{PC}A\wedge(A\vee B)\leftrightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(A\vee B\rightarrow A)$,$A1$&lt;/li&gt;
&lt;li&gt;$A\wedge(A \vee B)\rightarrow A$,$Th23$&lt;/li&gt;
&lt;li&gt;$\neg A\rightarrow\neg A$,$Th1$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(\neg A\rightarrow B)$,$Th8$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(\neg A\rightarrow B))\rightarrow(\neg(\neg A\rightarrow B)\rightarrow\neg A)$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(\neg A\rightarrow B)\rightarrow\neg A$,$r_{mp}(4)(5)$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow B)\rightarrow\neg A)\rightarrow\neg A$,$Th18$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg(\neg A\rightarrow B))\rightarrow((\neg A\rightarrow B)\rightarrow\neg A)$,$Th15$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg(\neg A\rightarrow B))\rightarrow\neg A$,$Th6$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg(\neg A\rightarrow B))\rightarrow\neg A)\rightarrow(A\rightarrow\neg(A\rightarrow\neg(\neg A\rightarrow B)))$,$Th15$&lt;/li&gt;
&lt;li&gt;$A\rightarrow\neg(A\rightarrow\neg(\neg A\rightarrow B))$,$r_{mp}(9)(10)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th33$：$\vdash_{PC}A\vee(A\wedge B)\leftrightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$A\rightarrow(\neg A\rightarrow(A\wedge B))$,$Th8$&lt;/li&gt;
&lt;li&gt;$A\wedge B\rightarrow A$,$Th24$&lt;/li&gt;
&lt;li&gt;$(A\wedge B\rightarrow A)\rightarrow((\neg A\rightarrow(A\wedge B))\rightarrow(\neg A\rightarrow A))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(A\wedge B))\rightarrow(\neg A\rightarrow A)$,$r_{mp}(2)(3)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow A)\rightarrow A$,$Th9$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(A\wedge B))\rightarrow A$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th34$：$\vdash_{PC}A\wedge(B\vee C)\leftrightarrow(A\wedge B)\vee(A\wedge C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$B\rightarrow(\neg B\rightarrow C)$,$Th8$&lt;/li&gt;
&lt;li&gt;$(B\rightarrow(\neg B\rightarrow C))\rightarrow(\neg(\neg B\rightarrow C)\rightarrow\neg B)$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(\neg B\rightarrow C)\rightarrow\neg B$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$(\neg(\neg B\rightarrow C)\rightarrow\neg B)\rightarrow((A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(A\rightarrow\neg B))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(A\rightarrow\neg B)$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(A\rightarrow\neg B))\rightarrow(\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg(\neg B\rightarrow C)))$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg(\neg B\rightarrow C))$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;li&gt;$C\rightarrow(\neg B\rightarrow C)$,$A1$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow(\neg B\rightarrow C))\rightarrow(\neg(\neg B\rightarrow C)\rightarrow\neg C)$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(\neg B\rightarrow C)\rightarrow\neg C$,$r_{mp}(8)(9)$&lt;/li&gt;
&lt;li&gt;$(\neg(\neg B\rightarrow C)\rightarrow\neg C)\rightarrow((A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(A\rightarrow\neg C))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(A\rightarrow\neg C)$,$r_{mp}(10)(11)$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(A\rightarrow\neg C))\rightarrow(\neg(A\rightarrow\neg C)\rightarrow\neg(A\rightarrow\neg(\neg B\rightarrow C)))$,$Th13$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg C)\rightarrow\neg(A\rightarrow\neg(\neg B\rightarrow C))$,$r_{mp}(12)(13)$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))\rightarrow\neg(A\rightarrow\neg(\neg B\rightarrow C))$,$Th18$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow\neg\neg(A\rightarrow\neg B)$,$Th12$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg B)\rightarrow\neg\neg(A\rightarrow\neg B))\rightarrow((\neg\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))\rightarrow((A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C)))$,$Th5$&lt;/li&gt;
&lt;li&gt;$(\neg\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))\rightarrow((A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))$,$r_{mp}(16)(17)$&lt;/li&gt;
&lt;li&gt;$(\neg\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))\rightarrow\neg(A\rightarrow\neg(\neg B\rightarrow C))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow((A\rightarrow\neg C)\rightarrow(A\rightarrow\neg(\neg B\rightarrow C)))$,$Th23$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg C)\rightarrow(A\rightarrow\neg(\neg B\rightarrow C)))\rightarrow(\neg(A\rightarrow\neg(\neg B\rightarrow C))\rightarrow\neg(A\rightarrow\neg C))$,$Th13$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow\neg B)\rightarrow(\neg(A\rightarrow\neg(\neg B\rightarrow C))\rightarrow\neg(A\rightarrow\neg C))$,$Th6$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg(\neg B\rightarrow C))\rightarrow((A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))$,$Th2$&lt;/li&gt;
&lt;li&gt;$\neg\neg(A\rightarrow\neg B)\rightarrow(A\rightarrow\neg B)$,$Th10$&lt;/li&gt;
&lt;li&gt;$(\neg\neg(A\rightarrow\neg B)\rightarrow(A\rightarrow\neg B))\rightarrow(((A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))\rightarrow(\neg\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C)))$,$Th5$&lt;/li&gt;
&lt;li&gt;$((A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))\rightarrow(\neg\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))$,$r_{mp}(24)(25)$&lt;/li&gt;
&lt;li&gt;$\neg(A\rightarrow\neg(\neg B\rightarrow C))\rightarrow(\neg\neg(A\rightarrow\neg B)\rightarrow\neg(A\rightarrow\neg C))$,$Th6$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;$Th35$：$\vdash_{PC}A\vee(B\wedge C)\leftrightarrow(A\vee B)\wedge(A\vee C)$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$B\wedge C\rightarrow B$,$Th24$&lt;/li&gt;
&lt;li&gt;$(B\wedge C\rightarrow B)\rightarrow((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow B))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow B)$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow B))\rightarrow(((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow C))\rightarrow((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow B)\wedge(\neg A\rightarrow C)))$&lt;/li&gt;
&lt;li&gt;$((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow C))\rightarrow((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow B)\wedge(\neg A\rightarrow C))$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$B\wedge C\rightarrow C$,$Th25$&lt;/li&gt;
&lt;li&gt;$(B\wedge C\rightarrow C)\rightarrow((\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow C))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow C)$,$r_{mp}(6)(7)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow(B\wedge C))\rightarrow(\neg A\rightarrow B)\wedge(\neg A\rightarrow C)$,$r_{mp}(5)(8)$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\rightarrow((\neg A\rightarrow C)\rightarrow(\neg A\rightarrow B\wedge C))$,$Th27$&lt;/li&gt;
&lt;li&gt;$(\neg A\rightarrow B)\wedge(\neg A\rightarrow C)\rightarrow(\neg A\rightarrow B\wedge C)$,$Th23$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;上述的35个PC的定理都是十分重要和有用的，其中定理$Th16$（反证法）和$Th18$（→拆分法）可以帮助我们将定理更加系统地证明，下面我们举两个例子进行说明。&lt;/p&gt;
&lt;h2 id=&#34;pc的基本定理的运用&#34;&gt;PC的基本定理的运用
&lt;/h2&gt;&lt;p&gt;运用$Th16$证明：$\vdash_{PC}((A\rightarrow B)\rightarrow A)\rightarrow A$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果我们要运用$Th16$，我们就需要假设这个定理不成立从而推出矛盾，不妨证明：&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}\neg(((A\rightarrow B)\rightarrow A)\rightarrow A)\rightarrow(A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}\neg(((A\rightarrow B)\rightarrow A)\rightarrow A)\rightarrow\neg(A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;后者即证：$\vdash_{PC}((A\rightarrow B)\rightarrow A)\rightarrow((A\rightarrow B)\rightarrow A)$，结论是显然的。&lt;/p&gt;
&lt;p&gt;前者即证：$\vdash_{PC}((A\rightarrow B)\rightarrow A)\rightarrow(\neg(A\rightarrow B)\rightarrow A)$&lt;/p&gt;
&lt;p&gt;后件可以由$\neg A\rightarrow(A\rightarrow B)$变形得到，所以得证。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运用$Th18$证明：$\vdash_{PC}(A\rightarrow C)\rightarrow((B\rightarrow C)\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;运用$Th18$证明这个定理等价于证明：&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}\neg A\rightarrow((B\rightarrow C)\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}C\rightarrow((B\rightarrow C)\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;后者即证：$\vdash_{PC}(B\rightarrow C)\rightarrow(C\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;其后件是$A1$，故结论是显然的。&lt;/p&gt;
&lt;p&gt;现在我们只需要证明：$\vdash_{PC}\neg A\rightarrow((B\rightarrow C)\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;即证：$\vdash_{PC}(B\rightarrow C)\rightarrow(\neg A\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;再次运用$Th18$，即证：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;$\vdash_{PC}\neg B\rightarrow(\neg A\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;$\vdash_{PC}C\rightarrow(\neg A\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;后者即证$\vdash_{PC}\neg A\rightarrow(C\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;其后件是$A1$，故结论是显然的。&lt;/p&gt;
&lt;p&gt;现在我们只需要证明：$\vdash_{PC}\neg B\rightarrow(\neg A\rightarrow(((A\rightarrow B)\rightarrow B)\rightarrow C))$&lt;/p&gt;
&lt;p&gt;即证：$\vdash_{PC}((A\rightarrow B)\rightarrow B)\rightarrow(\neg B\rightarrow(\neg A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;再次运用$Th18$，即证：&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}\neg(A\rightarrow B)\rightarrow(\neg B\rightarrow(\neg A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}B\rightarrow(\neg B\rightarrow(\neg A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;后者是$Th8$，故结论是显然的。&lt;/p&gt;
&lt;p&gt;现在我们只需要证明：$\vdash_{PC}\neg(A\rightarrow B)\rightarrow(\neg B\rightarrow(\neg A\rightarrow C))$&lt;/p&gt;
&lt;p&gt;即证：$\vdash_{PC}\neg B\rightarrow(\neg A\rightarrow(\neg C\rightarrow (A\rightarrow B)))$&lt;/p&gt;
&lt;p&gt;不妨证：$\vdash_{PC}\neg A\rightarrow(\neg C\rightarrow (A\rightarrow B))$&lt;/p&gt;
&lt;p&gt;可知有：&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}\neg A\rightarrow(A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;$\vdash_{PC}(A\rightarrow B)\rightarrow(\neg C\rightarrow(A\rightarrow B))$&lt;/p&gt;
&lt;p&gt;按照上述思路将对应的证明序列写出即可证明该定理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;演绎定理&#34;&gt;演绎定理
&lt;/h2&gt;&lt;p&gt;证明：$\vdash_{PC}(A\rightarrow(B\rightarrow C))\rightarrow((C\rightarrow D)\rightarrow(A\rightarrow(B\rightarrow D)))$&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;$(C\rightarrow D)\rightarrow((B\rightarrow C)\rightarrow(B\rightarrow D))$,$Th4$&lt;/li&gt;
&lt;li&gt;$((B\rightarrow C)\rightarrow(B\rightarrow D))\rightarrow((A\rightarrow(B\rightarrow C))\rightarrow(A\rightarrow(B\rightarrow D)))$,$Th4$&lt;/li&gt;
&lt;li&gt;$(C\rightarrow D)\rightarrow((A\rightarrow(B\rightarrow C))\rightarrow(A\rightarrow(B\rightarrow D)))$,$Th6$&lt;/li&gt;
&lt;li&gt;$(A\rightarrow(B\rightarrow C))\rightarrow((C\rightarrow D)\rightarrow(A\rightarrow(B\rightarrow D)))$,$Th2$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这个例子表明，在PC中证明定理的这个过程中的公式序列的公式长度通常较长，为了缩短公式序列的长度，我们现在给出PC中一个重要方便的定理：&lt;strong&gt;演绎定理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演绎定理&lt;/strong&gt;：对PC中任意公式集合$\Gamma$和公式$A,B$，$\Gamma\cup${$A$}$\vdash_{PC}B$（或记为$\Gamma;A\vdash_{PC}B$）当且仅当$\Gamma\vdash_{PC}A\rightarrow B$。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：（充分性）&lt;/p&gt;
&lt;p&gt;已知$\Gamma\vdash_{PC}A\rightarrow B$&lt;/p&gt;
&lt;p&gt;从$\Gamma$出发在PC可以得到一个$A\rightarrow B$的演绎序列$A_1,A_2,\cdots,A_n(=A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;从$\Gamma\cup${$A$}出发在PC也可以得到一个$A\rightarrow B$的演绎序列$A_1,A_2,\cdots,A_n(=A\rightarrow B)$&lt;/p&gt;
&lt;p&gt;从$\Gamma\cup${$A$}出发在PC中可以得到$B$的一个演绎序列$A_1,A_2,\cdots,A_n(=A\rightarrow B),A,B$&lt;/p&gt;
&lt;p&gt;也就是说有$\Gamma;A\vdash_{PC}B$。
证明：（必要性）&lt;/p&gt;
&lt;p&gt;已知$\Gamma\cup${$A$}$\vdash_{PC}B$&lt;/p&gt;
&lt;p&gt;从$\Gamma\cup${$A$}出发在PC可以得到一个$B$的演绎序列$B_1,B_2,\cdots,B_k(=B)$，我们对演绎序列的长度$k$使用数学归纳法：&lt;/p&gt;
&lt;p&gt;当$k=1$时可知$B$或是公理、或有$B\in\Gamma\cup${$A$}：&lt;/p&gt;
&lt;p&gt;当$B$是公理时，$A\rightarrow B$有演绎序列$B,B\rightarrow(A\rightarrow B),A\rightarrow B$。&lt;/p&gt;
&lt;p&gt;当$B\in\Gamma$时，$A\rightarrow B$有演绎序列$B,B\rightarrow(A\rightarrow B),A\rightarrow B$。&lt;/p&gt;
&lt;p&gt;当$B=A$时，$A\rightarrow B$也即$A\rightarrow A$，也就是$Th1$，那么有$\Gamma\vdash_{PC}A\rightarrow B$。&lt;/p&gt;
&lt;p&gt;假设$k&amp;lt; n$时原命题成立，那么对于$B$的演绎序列中的公式有$\Gamma\vdash_{PC}A\rightarrow B_i,i&amp;lt; n$。&lt;/p&gt;
&lt;p&gt;那么$k=n$时$B$或为公理、或有$B\in\Gamma\cup${$A$}，或由$B_i,B_j(i,j&amp;lt; n)$通过$r_{mp}$得到。&lt;/p&gt;
&lt;p&gt;当$B$是公理时，$A\rightarrow B$有演绎序列$B,B\rightarrow(A\rightarrow B),A\rightarrow B$。&lt;/p&gt;
&lt;p&gt;当$B\in\Gamma$时，$A\rightarrow B$有演绎序列$B,B\rightarrow(A\rightarrow B),A\rightarrow B$。&lt;/p&gt;
&lt;p&gt;当$B=A$时，$A\rightarrow B$也即$A\rightarrow A$，也就是$Th1$，那么有$\Gamma\vdash_{PC}A\rightarrow B$。&lt;/p&gt;
&lt;p&gt;当$B$由$B_i,B_j(i,j&amp;lt; n)$通过$r_{mp}$得到时，我们设$B_j=B_i\rightarrow B$。&lt;/p&gt;
&lt;p&gt;那么有：$\Gamma\vdash_{PC}A\rightarrow B_i,\Gamma\vdash_{PC}A\rightarrow B_j$&lt;/p&gt;
&lt;p&gt;也就是说：$\Gamma\vdash_{PC}A\rightarrow B_i,\Gamma\vdash_{PC}A\rightarrow(B_i\rightarrow B)$&lt;/p&gt;
&lt;p&gt;由$A2$知：$(A\rightarrow(B_i\rightarrow B))\rightarrow((A\rightarrow B_i)\rightarrow(A\rightarrow B))$&lt;/p&gt;
&lt;p&gt;故：$\vdash_{PC}(A\rightarrow B_i)\rightarrow(A\rightarrow B)$，则$\Gamma\vdash_{PC}A\rightarrow B$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们现在回到上面那个例子，现在使用演绎定理解决这个问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;证明：$\vdash_{PC}(A\rightarrow(B\rightarrow C))\rightarrow((C\rightarrow D)\rightarrow(A\rightarrow(B\rightarrow D)))$&lt;/p&gt;
&lt;p&gt;即证：$A\rightarrow(B\rightarrow C)\vdash_{PC}(C\rightarrow D)\rightarrow(A\rightarrow(B\rightarrow D))$&lt;/p&gt;
&lt;p&gt;即证：$A\rightarrow(B\rightarrow C),C\rightarrow D\vdash_{PC}A\rightarrow(B\rightarrow D)$&lt;/p&gt;
&lt;p&gt;即证：$A\rightarrow(B\rightarrow C),C\rightarrow D,A\vdash_{PC}B\rightarrow D$&lt;/p&gt;
&lt;p&gt;即证：$A\rightarrow(B\rightarrow C),C\rightarrow D,A,B\vdash_{PC}D$&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$A$&lt;/li&gt;
&lt;li&gt;$A\rightarrow(B\rightarrow C)$&lt;/li&gt;
&lt;li&gt;$B\rightarrow C$,$r_{mp}(1)(2)$&lt;/li&gt;
&lt;li&gt;$B$&lt;/li&gt;
&lt;li&gt;$C$,$r_{mp}(3)(4)$&lt;/li&gt;
&lt;li&gt;$C\rightarrow D$&lt;/li&gt;
&lt;li&gt;$D$,$r_{mp}(5)(6)$&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;不难发现，在使用了演绎定理之后，我们的证明过程中涉及的公式变得更加简单了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pc定理证明习题选&#34;&gt;PC定理证明习题选
&lt;/h2&gt;&lt;p&gt;下面给出了六道PC定理习题供读者练习使用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;证明：$\vdash_{PC}(A\rightarrow(B\rightarrow C))\rightarrow((A\rightarrow(D\rightarrow B))\rightarrow(A\rightarrow(D\rightarrow C)))$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{PC}(((A\rightarrow B)\rightarrow C)\rightarrow D)\rightarrow((B\rightarrow D)\rightarrow(A\rightarrow D))$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{PC}(A\rightarrow(\neg B\rightarrow(\neg D\rightarrow C)))\rightarrow((B\rightarrow\neg A)\rightarrow((C\rightarrow\neg A)\rightarrow(A\rightarrow D)))$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{PC}((D\rightarrow B)\rightarrow((C\rightarrow G)\rightarrow A))\rightarrow((E\rightarrow((C\rightarrow G)\rightarrow A))\rightarrow((D\rightarrow E)\rightarrow(G\rightarrow A)))$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{PC}(C\rightarrow(\neg A\rightarrow(\neg D\rightarrow A)))\rightarrow((B\rightarrow A)\rightarrow((\neg B\rightarrow C)\rightarrow(\neg A\rightarrow D)))$&lt;/li&gt;
&lt;li&gt;证明：$\vdash_{PC}((B\rightarrow C)\rightarrow(D\rightarrow E))\rightarrow(((B\rightarrow C)\rightarrow(G\rightarrow H))\rightarrow(((A\rightarrow B)\rightarrow C)\rightarrow\neg(((E\rightarrow G)\rightarrow(D\rightarrow H))\rightarrow\neg((G\rightarrow\neg H)\rightarrow\neg G))))$&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
</description>
        </item>
        <item>
        <title>关于我</title>
        <link>https://0x3a0x29.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/%E5%85%B3%E4%BA%8E%E6%88%91/</guid>
        <description>&lt;p&gt;一个喜欢做些自己最近感兴趣的事情的人。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>搜索</title>
        <link>https://0x3a0x29.github.io/%E6%90%9C%E7%B4%A2/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>https://0x3a0x29.github.io/%E6%90%9C%E7%B4%A2/</guid>
        <description></description>
        </item>
        
    </channel>
</rss>
