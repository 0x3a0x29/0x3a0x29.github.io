[{"content":"前言 阅读本文需要集合论、图论的相关知识，在此不作有关相关知识的赘述。\n笔者水平有限，存在的错误和不足请大家指正。\n图灵机 图灵机的引入 $\\boldsymbol{Figure\\ 2.1:}$\n在前文中已经介绍了有穷自动机DFA和下推自动机PDA，现在介绍一个更加强大的计算模型，这就是由Alan Turing（1912~1954）在1936年提出的 图灵机（Turing Machine,TM） ，图灵提出TM的目的是为了对算法进行形式化的描述，只考虑算法的基本特征，因此该模型应该具有以下两个性质：\n具有有穷描述。 过程必须是由离散的、可以机械执行的步骤组成。 图灵给出的基本模型包括一个有穷状态控制器（finite state control,FSC）、一条含有无穷多个带方格的输入带和一个读头，这使得TM有着无限大容量的储存且可以任意访问内部数据。对基本模型来说，输入带是两端无穷的，每个方格可以容纳一个符号，在TM最初启动的时候长度为$n$的输入串被存放在输入带左端开始的连续$n$个方格中，在这$n$个带方格之后，其他带方格均含有一个表示空白的符号，它不在输入符号中。TM的每一个移动与所读的符号、所处的状态有关。读头每次读一个符号，则在所读符号所在的带方格中印刷一个符号。在一次移动中将会完成以下$3$个动作：\n改变有穷状态控制器的状态。 在当前所读符号所在的带方格中印刷一个符号。 将读头向右或者向左移动一格。 图灵机的形式化定义 $\\boldsymbol{Definition\\ 2.2:}$\n现在给出TM的形式化定义：\nTM：$M$是一个七元组：$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,B,F)$，其中：\n$Q$是有穷状态集，相应的也有状态的概念。 $q_0$是起始状态，也就是对于一个给定的输入串，$M$以状态$q_0$启动，读头注视着输入串最左端的符号。 $F$是终止状态集，要求$F\\subseteq Q$，也有终止状态的概念。 $\\Gamma$是 带符号表（tape symbol） ，$\\forall X\\in\\Gamma$，称$X$为$M$的一个带符号，表示在$M$的运行过程中，$X$可以在某一时刻出现在输入带上。 $B$被称为 空白符（blank symbol） ，含有空白符的带方格被认为是空的。 $\\Sigma$为输入字母表，要求$\\Sigma\\subseteq\\Gamma-${$B$}，$\\forall a\\in\\Sigma$，称$a$为$M$的一个输入符号，除$B$以外只有$\\Sigma$中的符号才能在$M$刚刚启动的时候出现在输入带上。 $\\delta:Q\\times F\\rightarrow Q\\times F\\times${$R,L$}称为$M$的移动函数。其中$\\delta(q,X)=(p,Y,R)$表示$M$在状态$q$读入符号$X$后将状态改为$p$并在这个$X$所在的带方格中印刷符号$Y$并且将读头向右移动一格。$\\delta(q,X)=(p,Y,L)$表示$M$在状态$q$读入符号$X$后将状态改为$p$并在这个$X$所在的带方格中印刷符号$Y$并且将读头向左移动一格。 这里的每一个动作都是确定的，因此也可以称这里定义的图灵机为确定的图灵机。\n$\\boldsymbol{Definition\\ 2.3:}$\n在TM的计算过程中，当前状态、当前带子内容和读写头当前位置都体现了TM现在的情况，虽然TM有着无穷长的带子，但是经过有限不饿，带上非空内容总是有限的，为此引入瞬时描述（instantaneous description,ID），也可以称为 格局（configuration） 的概念。\n$X_1X_2\\cdots X_{i-1}qX_iX_{i+1}\\cdots X_n$被称为一个瞬时描述，其具有以下含义：\n$q$是TM的当前状态。 带头在左起第$i$个非空格符$X_i$上。 $X_1\\cdots X_n\\in\\Gamma$是从最左到最右非空格内容（$i=1$表示带头左端全是空格符号，$i=n$表示带头右端全是空格符号）。 设$X_1X_2\\cdots X_{i-1}qX_iX_{i+1}\\cdots X_n$是$M$的一个ID，如果有$\\delta(q,X_i)=(p,Y,R)$，那么记$X_1X_2\\cdots X_{i-1}qX_iX_{i+1}\\cdots X_n\\vdash_M X_1X_2\\cdots X_{i-1}YpX_{i+1}\\cdots X_n$，表示$M$在ID：$X_1X_2\\cdots X_{i-1}qX_iX_{i+1}\\cdots X_n$下经过一次移动后ID变为$X_1X_2\\cdots X_{i-1}YpX_{i+1}\\cdots X_n$。\n当读头向左移动时也有类似的定义，对于一些特殊的情况也有相应的定义，在此仅作示意性的说明。\n符号$\\vdash_{M}$称为ID转移符号，显然这是一个二元关系，为了表示方便，用$\\vdash_M^n,\\vdash_M^{ + },\\vdash_M^{ * }$分别表示关系$(\\vdash_M)^n,(\\vdash_M)^{ + },(\\vdash_M)^{ * }$，其意义是显然的。在不产生混淆的情况下也可以简记为$\\vdash^n,\\vdash^{ + },\\vdash^{ * }$。\n$\\boldsymbol{Example\\ 2.4:}$\nTM有着比FA和PDA更加强大的功能，例如下面这样一个例子：\n语言$L_1=${$ww|w\\in(0+1)^{ * }$}，那么可以构造出识别它的TM如下：\n如果$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,B,F)$是一个TM，那么$M$接受的语言为$L(M)=${$w|w\\in\\Sigma^{ * },q_0w\\vdash^{ * }\\alpha p\\beta,p\\in F,\\alpha,\\beta\\in\\Gamma^{ * }$}。\n输入串放在输入带上，$M$处于$q_0$，带头位于输入串的第一个字符上，输入串最终会导致$M$进入某个终止状态。\n$\\boldsymbol{Definition\\ 2.5:}$\n为了方便讨论，一般假定进入终止状态后$M$总会 停机（halt） ，也就是说没有下一个动作的定义，但是一个总会停机的状态不一定是终止状态，后文中为了区分这两种情况，称呼终止状态为接受状态，称总会停机的非终止状态为拒绝状态，TM进入接受状态立马就会接受，进入拒绝状态立马就会拒绝。\n在一个 接受格局（accepting configuration） 中状态是接受状态，在一个 拒绝格局（rejecting configuration） 中状态是拒绝状态，它们都被称为 停机格局（halting configuration） 。\n设$M$是一个TM，$w$是一个输入串。$M$在$w$上的一个 接受计算历史（accepting computation history） 是一个格局序列$C_1,C_2,\\cdots,C_l$，其中$C_l$是$M$在$w$上的起始格局，$C_l$是$M$的一个接受格局，且每个$C_i$都是$C_{i-1}$的合法结果，即符合$M$的规则。$M$在$w$上的一个 拒绝计算历史（rejecting computation history） 的定义是类似的。\n$\\boldsymbol{Definition\\ 2.6:}$\n如果一个语言$L$能够被TM：$M$接受，那么称$L$是 递归可枚举（recursively enumerable language,r.e.） ，称$L$是被$M$识别的语言（language recognized by $ M $），又称该语言是 图灵可识别的（Turing-recognizable） 。\n$\\boldsymbol{Note\\ 2.7:}$\n在一个输入上运行一个TM，可能会出现三种结果：接受、拒绝或循环（loop），一旦出现了循环便意味着TM不好停机，循环动作可以很简单也可能很复杂，可以找到这样一个TM对于某个特定的输入不能停机，也就是进入了循环：\n考虑TM：$M=(${$q_0,q_1$},{$0$},{$0,B$}$,\\delta,q_0,B,\\varnothing)$，其中$\\delta(q_0,0)=(q_1,B,R),\\delta(q_0,B)=(q_1,B,R),\\delta(q_1,B)=(q_0,B,L)$，这个TM接受的语言为$\\varnothing$，其中对于输入{$0^n|n\\geq 2$}而言这个TM会发生拒绝，但是对于输入{$0,\\epsilon$}而言这个TM将会进入循环，无法停机。\n$\\boldsymbol{Definition\\ 2.8:}$\n很难区分一个TM究竟是进入了循环还是需要耗费很长的时间运行，所以如果有一个TM对于所有输入都停机，它永远不会出现循环，则称它为 判定器（decider） ，因为它们总能决定是接受还是拒绝，对于可以识别某个语言的判定器，称其 判定（decide） 该语言。\n$\\boldsymbol{Definition\\ 2.9:}$\n如果一个语言$L$能够被判定器$M$接受，那么称$L$是 递归语言（recursive language） ，称$L$是被$M$判定的语言，又称该语言是 图灵可判定的（Turing decidable） 或简称为 可判定的（decidable） 。\nTM除了作为语言识别器以外，还可以作为非负整函数的计算器，可以对所有非负整数进行编码，例如对于一个函数$f(n_1,n_2,\\cdots,n_k)$而言可以用符号串$0^{n_1}10^{n_2}1\\cdots 10^{n_k}$表示它的$k$个变元$n_1,n_2,\\cdots,n_k$的值，将其作为相应的TM的输入，如果$f(n_1,n_2,\\cdots,n_k)=m$那么TM的输出为$0^m$，也就是说TM会停机并且在输入带上留下字符串$0^m$。\n$\\boldsymbol{Definition\\ 2.10:}$\n设有$k$元函数$f(n_1,n_2,\\cdots,n_k)=m$，存在TM：$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,B,F)$接受输入串$0^{n_1}10^{n_2}1\\cdots 10^{n_k}$并输出$0^m$，当$f(n_1,n_2,\\cdots,n_k)$无定义的时候$M$没有恰当的输出，则称$M$计算$k$元函数$f(n_1,n_2,\\cdots,n_k)$，而$f(n_1,n_2,\\cdots,n_k)$为$M$计算的函数，也称$f$是 图灵可计算的（Turing computable） 。\n如果对于任意的$n_1,n_2,\\cdots,n_k$，$f(n_1,n_2,\\cdots,n_k)$均有定义，也就是计算$f$的TM总能给出确定的输出，则称$f$为 完全递归函数（total recursive function） 。一般地，TM计算的函数都被称为 部分递归函数（partial recursive function） 。\n$\\boldsymbol{Example\\ 2.11:}$\n现在给出一个作为非负整函数的计算器的TM：\n考虑二元函数$f(n,m)$，当$n\u0026gt;m$时$f(n,m)=n-m$，当$n\\leq m$时$f(n,m)=0$。\n考虑TM：$M=(\\cup_{i=0}^6${$q_i$},{$0,1$},{$0,1,X,B$}$,\\delta,q_0,B,${$q_6$}$)$，其中：\n$\\delta(q_0,0)=(q_1,B,R),\\delta(q_0,1)=(q_5,B,R),\\delta(q_1,0)=(q_1,0,R),\\delta(q_1,1)=(q_2,1,R)$\n$\\delta(q_2,X)=(q_2,X,R),\\delta(q_2,0)=(q_3,X,L),\\delta(q_2,B)=(q_4,B,L),\\delta(q_3,X)=(q_3,X,L)$\n$\\delta(q_3,1)=(q_3,1,L),\\delta(q_3,0)=(q_3,0,L),\\delta(q_3,B)=(q_0,B,R),\\delta(q_4,X)=(q_4,B,L)$\n$\\delta(q_4,1)=(q_6,0,R),\\delta(q_5,X)=(q_5,B,R),\\delta(q_5,0)=(q_5,B,R),\\delta(q_5,B)=(q_6,B,R)$\n图灵机的变形 $\\boldsymbol{Definition\\ 2.12:}$\n其他形式的图灵机还有很多，它们被称为图灵机模型的 变形（variant） ，原来的模型和它所有合理的变形有着相同的能力，也就是识别相同的语言类，虽然它们的定义有了变化但它们的能力却没有改变，在形式变化中保持不变的性质被称为 稳健性（robustness） 。TM相较于FA和PDA更具惊人的稳健性。\n$\\boldsymbol{Figure\\ 2.13:}$\n带状态存储的图灵机：在有穷控制器中可以存储有限个符号的图灵机：$M\u0026rsquo;=(Q\u0026rsquo;,\\Sigma,\\Gamma,\\delta,q\u0026rsquo;_0,B,F\u0026rsquo;)$，其中$Q\u0026rsquo;=Q\\times F\\times\\cdots\\times F,q\u0026rsquo;_0=(q_0,B,\\cdots,B)$，也就是说在FCS中存储了一个有限长的缓冲，并且存储输入带上的一些符号，很明显这样的变形和原先的图灵机是等价的。\n$\\boldsymbol{Figure\\ 2.14:}$\n多道图灵机（multi-track Turing machine） ：$M\u0026rsquo;=(Q,\\Sigma,\\Gamma\u0026rsquo;,\\delta,q_0,B\u0026rsquo;,F)$，其中$\\Gamma\u0026rsquo;=\\Gamma\\times\\Gamma\\times\\cdots\\times\\Gamma$，相当于在图灵机当中输入带共有$k$条道，读头一次读入$k$个符号。显然这样的变形和原先的图灵机是等价的。\n$\\boldsymbol{Figure\\ 2.15:}$\n在本文中定义图灵机要求输入带是两端无穷的，但是实际上也可以对这个要求进行限制，现在规定这样一种图灵机，它的输入带具有左端点、而它的右端是无穷的，在TM最初启动的时候从输入带的左端开始放置输入串，也就意味着读头在初始注视着输入带的最左端的符号，为了避免读头通过左端离开输入带，规定在这种情况下图灵机将不会有下一个ID。这样定义的图灵机被称为 基本图灵机（basic Turing machine） ，相对的，在前文中定义的图灵机可以被称作 双向无穷带图灵机（Turing machine with two-way infinite tape） 。\n$\\boldsymbol{Theorem\\ 2.16:}$\n对于任意一个双向无穷带图灵机$M$，都存在一个等价的基本图灵机$M\u0026rsquo;$，也就是说$L(M\u0026rsquo;)=L(M)$。\n设有双向无穷带图灵机$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,B,F)$，为了构造等价的基本图灵机，很自然地会想到用一个有两条道的基本图灵机$M\u0026rsquo;$去模拟$M$的双向无穷带，其中一个带用来存放$M$开始启动时读头所注视的带方格（设其为$A_0$所在的带方格）以及其右侧所有带方格中的内容，第二个带按照相反的顺序用于存放这个位置左侧所有带方格中的内容，为了表示方便，在与$A_0$对应的带方格的第二道上印刷符号$￠$以表示这是带的最左端，例如在$M$的输入带上有符号$\\cdots BA_{-n}\\cdots A_{-1}A_0\\cdots A_i\\cdots A_mB\\cdots$，那么在$M\u0026rsquo;$的输入带上就会有符号$(A_0,￠)(A_1,A_{-1})\\cdots(A_i,A_{-i})\\cdots (B,B)\\cdots$。为了让$M\u0026rsquo;$在模拟$M$的过程中知道自己究竟在处理带子上哪一道的字符，可以利用带状态存储的图灵机来实现这一点，现在给出形式化的证明。\n$\\boldsymbol{Proof:}$考虑基本图灵机$M\u0026rsquo;=(Q\\times${$1,2$}$,\\Sigma\\times${$B$}$,\\Gamma\\times(\\Gamma\\cup${$￠$}$),\\delta\u0026rsquo;,q_0,(B,B),F\\times${$1,2$}$)$，其中$\\delta\u0026rsquo;$的定义如下：\n$M\u0026rsquo;$在启动的时候需要模拟$M$的启动动作，并且要完成$￠$的印刷。对于$\\forall a\\in\\Sigma\\cup${$B$}，如果$\\delta(q_0,a)=(p,X,R)$，那么令$\\delta\u0026rsquo;(q_0,(a,B))=((p,1),(X,￠),R)$，如果$\\delta(q_0,a)=(p,X,L)$，那么令$\\delta\u0026rsquo;(q_0,(a,B))=((p,2),(X,￠),R)$。 $M\u0026rsquo;$的读头未指向带的最左端符号时，它在第一道上完全模拟$M$的动作。对于$\\forall(X,Z)\\in\\Gamma\\times\\Gamma$，如果$\\delta(q,X)=(p,Y,R)$，那么令$\\delta\u0026rsquo;((q,1),(X,Z))=((p,1),(Y,Z),R)$，如果$\\delta(q,X)=(p,Y,L)$，那么令$\\delta\u0026rsquo;((q,1),(X,Z))=((p,1),(Y,Z),L)$。 $M\u0026rsquo;$的读头未指向带的最左端符号时，它在第二道上模拟$M$的动作，但移动方向要相反。对于$\\forall(X,Z)\\in\\Gamma\\times\\Gamma$，如果$\\delta(q,X)=(p,Y,R)$，那么令$\\delta\u0026rsquo;((q,2),(X,Z))=((p,1),(Y,Z),L)$，如果$\\delta(q,X)=(p,Y,L)$，那么令$\\delta\u0026rsquo;((q,1),(X,Z))=((p,1),(Y,Z),R)$。 $M\u0026rsquo;$的读头指向带的最左端符号时，由于最左端的符号的第二道上的符号是$￠$，所以它只能是在第一道上运行。对于$\\forall (q,X)\\in Q\\times\\Gamma$，如果$\\delta(q,X)=(p,Y,R)$，那么令$\\delta\u0026rsquo;((q,1),(X,￠))=((p,1),(Y,￠),R),\\delta\u0026rsquo;((q,2),(X,￠))=((p,1),(Y,￠),R)$，如果$\\delta(q,X)=(p,Y,L)$，那么令$\\delta\u0026rsquo;((q,1),(X,￠))=((p,2),(Y,￠),R),\\delta\u0026rsquo;((q,2),(X,￠))=((p,2),(Y,￠),R)$。 可以证明$L(M)=L(M\u0026rsquo;)$，证毕，这也就意味着这两种图灵机识别同样的语言。\n$\\boldsymbol{Figure\\ 2.17:}$\n多带图灵机（multi-tape Turing machine） ：有多个带子，每个带子都是自己的读写头用于读和写，开始时输入出现在第一个带子上，其他带子都是空白的。转移函数改为允许多个带子同时进行读、写和移动带头，其形式为$\\delta:Q\\times\\Gamma^k\\rightarrow Q\\times\\Gamma^k\\times(${$L,R$}$)^k$，例如$\\delta(q_i,a_1,\\cdots,a_k)=(q_j,b_1,\\cdots,b_k,L,R,\\cdots,L)$，表示如果机器处于状态$q_i$，读头读的符号分别为$a_1,\\cdots,a_k$，那么机器的状态转移到$q_j$，并且读头分别写下符号$b_1,\\cdots,b_k$，同时按照后续的移动方式移动读头。\n$\\boldsymbol{Theorem\\ 2.18:}$\n对于任意一个多带图灵机$M$，都存在一个等价的单带图灵机$S$，也就是说$L(M)=L(S)$。\n$\\boldsymbol{Proof:}$假设$M$有$k$条带子，$S$把这$k$个带子的信息都存储在它唯一的带子上，用来模拟$M$的效果，它用一个定界符#来分开不同带子的内容，同时$S$还要存储$M$中每个带子上的读头的位置，不妨通过在符号上加一个点来描述这种情况（例如读头注视着符号$a$就记符号为$\\dot{a}$）$S$把它们想象为虚拟带子和虚拟读头，现在给出一个可行的$S$模拟$M$：\n对于输入$w=w_1\\cdots w_n$：\n$S$在自己的带子上放入#$\\dot{w_1}w_2\\cdots w_n$#$\\dot{B}$#$\\dot{B}$#$\\cdots$#以表示$M$全部带子的内容。 为了模拟多带机的一步移动，$S$在其带子上从标记左端点的第一个#开始扫描，一直扫描到标记右端点的第$k+1$个#，其目的是确定虚拟读头下的符号，然后$S$进行第二次扫描，并且根据$M$的转移函数指示的方式更新带子。 任何时候，只要$S$将某个虚拟读头向右移动至某个#上面，就意味着$M$已将自己相应的读头移动到了其所在的带子的空白区域上，即以前没有读过的区域上，因此，$S$在这个带子方格上写下$B$，并将这个带子方格到最右端的各个带子方格中的内容都向右移动一格，再继续像之前一样模拟。 $\\boldsymbol{Example\\ 2.19:}$\n$\\boldsymbol{Corollary\\ 2.20:}$\n一个语言是图灵可识别的，当且仅当存在多带图灵机识别它。\n$\\boldsymbol{Figure\\ 2.21:}$\n非确定型图灵机（nondeterministic Turing machine） 在计算过程中机器可以在多种可能性动作中选择一种继续进行，它的转移函数$\\delta:Q\\times\\Gamma\\rightarrow 2^T$（其中$T=Q\\times\\Gamma\\times${$L,R$}），也就是说它对于一个输入串有着多个移动序列，只要存在一个序列可以使图灵机进入终止状态，那么这个输入串便可以被图灵机接受。\n$\\boldsymbol{Theorem\\ 2.22:}$\n每个非确定型图灵机都等价于某一个确定型图灵机。\n$\\boldsymbol{Proof:}$为了用确定型图灵机模拟非确定型图灵机，很容易想到非确定型图灵机的计算会对应一个树的结构，树的分支代表了非确定型图灵机的一个分支，树的结点是$N$的一个格局，根结点对应起始格局。为了让确定型图灵机搜索各个分支，可以采用“宽度优先搜索”：搜索一个深度的所有分支后再搜索下一个深度的所有分支。\n被模拟的非确定型图灵机为$N$，模拟确定型图灵机$D$有三条带子（先前已经证明了这等价于只有一个带子）。第一个带子只包含输入串，且不再改变；第二个带子存放$N$的带子中的内容，此内容对应于$N$的非确定型计算的某个分支；第三个带子记录$D$在$N$的计算树中所处的位置。\n先考虑第三个带子上数据的表示方式，$N$的每个格局都确定一个集合，这个集合包含了该格局可能转移的所有格局，这是由转移函数决定的，因此集合的元素个数是有限的，设集合的元素最大值为$b$，那么对于树的每一个结点都可以分配一个地址，它是$\\Gamma_b=${$1,2,\\cdots,b$}上的一个串（例如$231$表示从根结点出发走到第$2$个子结点，再走到第$3$个子结点，最后走到第$1$个子结点），很显然存在着无意义的地址，那么你此时它就无效。在第三个带子上放置的是$\\Gamma_b$中的一个串，也就是地址，用$\\epsilon$表示根地址，由于采用了“宽度优先搜索”，地址的顺序也自然确定了。\n现在给出$D$的描述：\n开始时，第一个带子包含输入串$w$，第二个带子和第三个带子是空的。 把第一个带子复制到第二个带子上，并且将第三个带子的字符串初始化为$\\epsilon$。 用第二个带子去模拟$N$在·输入$w$上的非确定型计算的某个分支，在$N$的每一步动作前，查询第三个带子上的下一个数字，以决定在$N$的转移函数所允许的选择中作何选择。如果第三个带子上没有符号剩下，或这个非确定型的选择是无效的，则放弃这个分支，进入第4步，如果遇到了拒绝格局也进入第4步。如果遇到了接受格局就接受这个输入。 在第三个带子上用字符串顺序的下一个串来替代原有的串，再转回第2步以模拟下一个计算分支。 $\\boldsymbol{Example\\ 2.23:}$\n$\\boldsymbol{Corollary\\ 2.24:}$\n一个语言是图灵可识别的当且仅当存在非确定型图灵机识别它。\n类似的，对于非确定型图灵机而言也有判定的概念，此时也称其为判定器，现在证明它判定的语言是可判定语言。\n$\\boldsymbol{Corollary\\ 2.25:}$\n一个语言是可判定的当且仅当存在非确定型图灵机判定它。\n$\\boldsymbol{Proof:}$也就是证明一个被非确定型图灵机$N$所判定的语言是可判定的，可以在上文中给出的确定型图灵机中进行修改，将原先的4步改为以下5步即可：\n开始时，第一个带子包含输入串$w$，第二个带子和第三个带子是空的。 把第一个带子复制到第二个带子上，并且将第三个带子的字符串初始化为$\\epsilon$。 用第二个带子去模拟$N$在·输入$w$上的非确定型计算的某个分支，在$N$的每一步动作前，查询第三个带子上的下一个数字，以决定在$N$的转移函数所允许的选择中作何选择。如果第三个带子上没有符号剩下，或这个非确定型的选择是无效的，则放弃这个分支，进入第4步，如果遇到了拒绝格局也进入第4步。如果遇到了接受格局就接受这个输入。 如果$N$的所有非确定型的分支都拒绝，则拒绝，进入第5步。 在第三个带子上用字符串顺序的下一个串来替代原有的串，再转回第2步以模拟下一个计算分支。 $\\boldsymbol{Figure\\ 2.26:}$\n前文中提到TM识别的语言也叫做递归可枚举语言，这就涉及到了一个称作 枚举器（enumerator） 的机器，也是TM的一种变形。粗略的说，枚举器是有打印机的图灵机，图灵机把打印机当作是输出设备，从而可以打印串。枚举器以空白输入的工作带开始运行，如果不停机，那么它可能会打印出串的一个无限序列。枚举器$E$所枚举的语言是最终打印出的串的集合，而且$E$可能以任意顺序生成这个语言的串，甚至可以有重复。\n枚举器的这种模式也可以用TM来表示，让一个TM打印出字符串后用分隔符#对不同字符串进行区分即可，这样的TM称为 作为枚举器的图灵机（Turing machine as enumerator） 。\n$\\boldsymbol{Theorem\\ 2.27}$\n一个语言是可识别的当且仅当存在枚举器枚举它。\n$\\boldsymbol{Proof:}$首先证明如果有枚举器$E$枚举语言$A$，则有TM：$M$识别$A$，对于输入$w$，TM：$M$按照以下方式运行：\n运行$E$，每当$E$输出一个串时，将其与$w$比较。 如果$w$曾经在$E$的输出序列中出现过，则接受。 现在证明另外一个方向，设$\\Sigma^{ * }$中所有可能的串，如果TM：$M$识别语言$A$，则为$A$构造枚举器$E$如下：\n对$i=1,2,\\cdots$重复下列步骤。 对$s_1,s_2,\\cdots,s_i$中的每一个，$M$以其作为输入运行$i$步。 如果有计算接受，则打印出相应的$s_j$。 TM还有着很多的变形，在此对这些TM进行介绍。\n$\\boldsymbol{Figure\\ 2.28:}$\n多维图灵机（multi-dimensional Turing machine） 的带子是多维的，如果带子的维度为$k$，也就意味着读头总共有$2k$种移动方向，无论是沿哪个方向移动都可以不断持续下去。对于多维图灵机而言，在运行的任意时刻，在带上的非空白的内容都可以被一个有限的$k$维立方体所包含，这使得在带子上的字符串可以按照一种方式组合成在一维带上的字符串，这里的做法和在计算机种存放多维数组的方式一样。\n$\\boldsymbol{Theorem\\ 2.29:}$\n多维图灵机和基本图灵机等价。\n$\\boldsymbol{Figure\\ 2.30:}$\n多头图灵机（multi-head Turing machine） 是指在一条带上有多个读头，它们都受到图灵机的有穷控制器的统一控制，图灵机根据当前的状态和这多个读头当前读到的字符决定要执行的移动，各个读头要印刷的字符和所移动的方向都可以是相互独立的。\n$\\boldsymbol{Theorem\\ 2.31:}$\n多头图灵机和基本图灵机等价。\n$\\boldsymbol{Figure\\ 2.32:}$\n离线图灵机（off-line Turing machine） 是一种多带图灵机，其中一条输入带是只读带，通常用符号$￠$放在左边、$$ $放在右边来限定其有限长的输入串存放区域，不允许读头移出它们所限定的输入串之外。它是多带图灵机的一种特例。如果还限制只读带上的读头从左向右移动，那么称这种图灵机为 在线图灵机（on-line Turing machine） 。\n$\\boldsymbol{Theorem\\ 2.33:}$\n离线图灵机和基本图灵机等价，在线图灵机和基本图灵机等价。\n$\\boldsymbol{Figure\\ 2.34:}$\n下推自动机可以被视作是一种非确定的多带图灵机。它有一条只读的输入带且输入带不能左移，还有一条存储带可以印刷符号且读头可以左右移动，但是当其向左移动时必须在当前注视的带方格种印刷空白符号$B$，因此读头所注视的字符右边都是空白符号。一般情况下，当它向右移动时，应该在注视的带方格上印刷一个非空白字符。满足这些条件的图灵机为称为是 多栈机（mulit-stack machine） 。\n一个确定的 双栈机（double stack machine） 是一个确定的图灵机，它具有一条只读的输入带和两条存储带。存储带上的读头左移时只能印刷空白符号。\n$\\boldsymbol{Theorem\\ 2.35:}$\n任意一个单带图灵机都可以被一个确定的双栈机模拟。\n$\\boldsymbol{Figure\\ 2.36:}$\n计数机（counter machine） 是一种离线图灵机，它除了一条只读输入带以外还有若干条用来计数的单向无穷带，用于$n$个用于计数的计数机被称为$n$计数机。 用于计数的带上仅有两种字符：一个为相当于作为栈底符号的$Z$，该字符也可以看作计数带的首符号，它仅出现在用于计数的带的最左端；另一个是空白符$B$，总共带上所记的数就是从$Z$开始到读头当前位置所含的$B$的个数。\n$\\boldsymbol{Theorem\\ 2.37:}$\n任意一个图灵机都可以被一个双计数机模拟。\n$\\boldsymbol{Figure\\ 2.38:}$\n队列自动机（queue automaton） 类似于PDA，只是把栈换成了队列，这个过程也可以用图灵机来表示。\n$\\boldsymbol{Theorem\\ 2.39:}$\n一个语言被一个确定型队列队列自动机识别当且仅当该语言是图灵可识别的。\n$\\boldsymbol{Figure\\ 2.40:}$\n随机存取机（random access machine,RAM） 含有无穷多个存储单元，这些存储单元被编号成$0,1,2,\\cdots$，每个存储单元可以存放一个任意的整数。RAM还有有穷个可以保存任意整数的算术寄存器，这些整数可以被译码成各类计算机指令。显然如果选择合适的指令集合，RAM就可以模拟现有的任何计算机。\n$\\boldsymbol{Theorem\\ 2.41:}$\n如果RAM的基本指令都能用图灵机实现，那么就可以用图灵机实现RAM。\n图灵机和PSG的等价性 $\\boldsymbol{Theorem\\ 2.42:}$\n对于任意一个PSG：$G=(V,T,P,S)$，存在TM：$M$，使得$L(M)=L(G)$。\n$\\boldsymbol{Proof:}$让$M$有两条带，第一条带用于存放输入字符串$ww$，第二条带用于产生$w$，在第二条带上存放的是一个句型，开始启动的时候这个句型是$S$。如果第二条带上的句型是$\\gamma$，$M$将按照某种策略在$\\gamma$中选择一个字串$\\alpha$使得它为$G$的某个产生式的左部，再用$\\alpha$的产生式的某个候选式去替换$\\alpha$。当第二条带上的内容为一个句子的时候，就将其与第一条带上的$w$比较，如果相等就接受$w$，否则就继续去寻找能够产生$w$的派生。\n$\\boldsymbol{Theorem\\ 2.43:}$\n对于任意一个TM：$M$，存在一个PSG：$G=(V,T,P,S)$，使得$L(G)=L(M)$。\n$\\boldsymbol{Proof:}$设$L$是$G$接受的语言，为了使得$G$产生$M$所识别的字符串，首先考虑让$G$产生$\\Sigma^{ * }$中任意一个字符串的变形，然后让$G$模拟$M$处理这个字符串的变形，如果$M$接受它就把字符串的变形还原成该字符串。这里的变形是指让每个字符对应一个二元组，例如对于$a$生成$(a,a)$。对于$\\forall(a_1,a_1)(a_2,a_2)\\cdots(a_n,a_n)\\in(\\Sigma\\times\\Sigma)^{ * }$，可以将其看成$a_1a_2\\cdots a_n$的两个副本，这一的字符串称为 双副本串（double-copy string） 。然后$G$在一个副本上模拟$M$的识别动作，如果$M$进入终止状态，则$G$将句型中除另一个副本以外的所有字符消去以得到句子。\n下面给出一个合理的$G=((\\Sigma\\cup${$\\epsilon$}$)\\times\\Gamma\\cup${$A_1,A_2,A_3$}$\\cup Q,\\Sigma,P,A)$，其中{$A_1,A_2,A_3$}$\\cap\\Gamma=\\varnothing$，$P$包含如下的产生式：\n$A_1\\rightarrow q_0A_2$，准备模拟$M$从$q_0$启动。 对于$\\forall a\\in\\Sigma,A_2\\rightarrow(a,a)A_2$，$A_2$首先生成任意的形如$(a_1,a_1)(a_2,a_2)\\cdots(a_n,a_n)$的串。 $A_2\\rightarrow A_3$，生成双副本子串$(a_1,a_1)(a_2,a_2)\\cdots(a_n,a_n)$后准备用$A_3$在子串后生成一系列相当于空白符的子串，为$G$能够顺利地模拟$M$在处理相应的输入字符串的过程中将读头移向输入串右侧的初始为$B$的带方格做准备。 $A_3\\rightarrow(\\epsilon,B)A_3$，由于$M$在处理一个字符时不知道要用到输入串右侧的多少个初始为$B$的带方格，所以让$A_3$生成一系列相当于空白符的子串$(\\epsilon,B)(\\epsilon,B)\\cdots(\\epsilon,B)$。 $A_3\\rightarrow\\epsilon$。 对于$\\forall a\\in\\Sigma\\cup${$\\epsilon$}$,\\forall q,p\\in Q,\\forall X,Y\\in\\Gamma$，如果$\\delta(q,X)=(p,Y,R)$则$q(a,X)\\rightarrow(a,Y)p$，这是$G$模拟$M$的一次右移。 对于$\\forall a,b\\in\\Sigma\\cup${$\\epsilon$}$,\\forall q,p\\in Q,\\forall X,Y,Z\\in\\Gamma$，如果$\\delta(q,X)=(p,Y,L)$则$(b,Z)q(a,X)\\rightarrow p(b,Z)(a,Y)$，这是$G$模拟$M$的一次左移。 对于$\\forall a\\in\\Sigma\\cup${$\\epsilon$}$,\\forall q\\in F,(a,X)q\\rightarrow qaq,q(a,X)\\rightarrow qaq,q\\rightarrow\\epsilon$。 丘奇-图灵论题 读者读到这里可能会很奇怪，为什么在前文中有些证明给出了TM的转移函数和形式化定义，但是有些证明却只能简单地描述了读头的移动方式和带子的管理方式，这并不是没有理由的，现在对丘奇-图灵论题进行介绍。\n非形式化地说，算法是为实现某个任务而构造的简单指令集，在20世纪以前入门对算法只有直观的认识，在Alonzo Church（1903~1995）和Alan Turing（1912~1954）在1936年所写的文章中给出了算法的明确定义，丘奇使用$\\lambda$-演算这一记号系统来定义算法，图灵使用机器来左同样的事情，这两个定义是等价的，算法的非形式化概念和精确定义之间的这个联系被称为 丘奇-图灵论题（Church-Turing thesis） ，现在给出丘奇-图灵论题的一个说明：\n丘奇创造了一种称为$M$的机械方法，它通过数学和逻辑的方式来完成任务，这个方法$M$满足以下条件：\n$M$中的指令的数目必须是有限的。 方法在执行有限数量的步骤后就会产生输出。 它不应该是虚构的，在现实生活中可以实现。 它不需要任何复杂的理解。 这个论题认为对于任何可以用有效算法解决的问题，都存在解决此问题的TM。这个论题无法被证明，因为它涉及到了有效算法的直观概念，但TM是形式化的、严格的。丘奇-图灵论题指出TM是被用作算法定义的一个精确模型，实际上不必划分过多的时间在TM的低层次程序上，只需要相信TM刻画了所有的算法即可。在承认这一点的前提下，下面将描述TM算法的方法标准化：\n形式化描述：详细地写出TM的状态、转移函数等，也是先前最常见的描述方式。 实现描述：使用日常语言描述TM的动作，如如何移动读写头、怎么在带子上存储数据等，这种程度的描述没有给出状态和转移函数的细节。 高层次描述：使用日常语言来描述算法，但忽略了实现的细节，这种程度的描述不提及TM应该如何管理它的带子和读头。 前文已经给出了很多TM的描述，它们都是形式化描述或者是实现描述，这有助于理解TM并增强使用它们的信心，有了这样的信心便足以进行高层次描述。\nTM的输入总是一个串，要想让TM解决更多问题，例如把多项式、图、文法、自动机等作为输入，就要把这些对象字符串化，可以设计一个TM来对这些串进行适当的解码，使之被解释为所希望的对象，为了方便描述，对于一个对象$O$，称它编码成字符串的记号是$\u0026lt; O \u0026gt;$，也可以将多个对象$O_1,O_2,\\cdots,O_n$编码成一个串$\u0026lt; O_1,O_2,\\cdots,O_n \u0026gt;$。选择何种方式进行编码是不重要的，因为TM总能将一种转换成另一种。\n图灵可识别语言和可判定语言的封闭性 $\\boldsymbol{Theorem\\ 2.44:}$\n图灵可识别语言类在并、连接、克林闭包、交和同态运算下封闭。\n$\\boldsymbol{Proof:}$\n（1）并运算：\n有TM：$M_X,M_Y$分别识别语言$X,Y$，识别$X\\cup Y$的TM：$M_{XY}$如下：\n对于输入串$w$：\n逐步地在$w$上交替运行$M_X,M_Y$，如果其中任何一个接受，那么$M_{XY}$接受。如果两个机器都停机且拒绝，那么$M_{XY}$就拒绝。 （2）连接运算：\n有TM：$M_X,M_Y$分别识别语言$X,Y$，识别$XY$的TM：$M_{XY}$如下：\n对于输入串$w$：\n$M_{XY}$将会非确定地将输入串分为$s_1$和$s_2$。 在$s_1$上运行$M_X$，如果$M_Y$接受就进入步骤3，如果$M_X$停机且拒绝，那么$M_{XY}$就拒绝。 在$s_2$上运行$M_Y$，如果$M_Y$接受那么$M_{XY}$就接受，如果$M_Y$停机且拒绝，那么$M_{XY}$就拒绝。 （3）克林闭包运算：\n有TM：$M_X$识别语言$X$，识别$X^{ * }$的TM：$M$如下：\n对于输入串$w$：\n$M$将会非确定地将输入串$w$分为子串$s_1,s_2,\\cdots,s_n$。 在这些串上运行$M_X$，如果$M_X$接受了所有子串那么$M$就接受，否则$M$就拒绝。 （4）交运算：\n有TM：$M_X,M_Y$分别识别语言$X,Y$，识别$X\\cap Y$的TM：$M_{XY}$如下：\n对于输入串$w$：\n在$w$上运行$M_X$，如果$M_X$接受就进入步骤2，否则$M_{XY}$就拒绝。 在$w$上运行$M_Y$，如果$M_Y$接受那么$M_{XY}$接受。否则$M_{XY}$就拒绝。 （5）同态运算：\n有TM：$M_X$分别识别语言$X$，有同态$h$，识别$h(X)$的TM：$M$如下：\n对于输入串$w$：\n$M$会按照字典顺序选择全体字符串中的一个字符串$s$，如果有$h(s)=w$就进入步骤2. 在$s$上运行$M_X$，如果$M_X$接受那么$M$就接受。 $\\boldsymbol{Theorem\\ 2.45:}$\n可判定语言类在并、连接、克林闭包、补和交运算下封闭。\n$\\boldsymbol{Proof:}$\n（1）并运算：\n有TM：$M_X,M_Y$分别判定语言$X,Y$，判定$X\\cup Y$的TM：$M_{XY}$如下：\n对于输入串$w$：\n在$w$上运行$M_X$，如果它接受那么$M_{XY}$就接受，如果$M_X$拒绝了就进入步骤2。 在$w$上运行$M_Y$，如果它接受那么$M_{XY}$就接受，如果$M_Y$拒绝了$M_{XY}$就拒绝。 （2）连接运算：\n有TM：$M_X,M_Y$分别判定语言$X,Y$，判定$XY$的TM：$M_{XY}$如下：\n对于输入串$w$：\n$M_{XY}$将会非确定地将输入串分为$s_1$和$s_2$。 在$s_1$上运行$M_X$，如果$M_Y$接受就进入步骤3，如果$M_X$拒绝，那么$M_{XY}$就拒绝。 在$s_2$上运行$M_Y$，如果$M_Y$接受那么$M_{XY}$就接受，如果$M_Y$拒绝，那么$M_{XY}$就拒绝。 （3）克林闭包运算：\n有TM：$M_X$识别语言$X$，识别$X^{ * }$的TM：$M$如下：\n对于输入串$w$：\n$M$将会非确定地将输入串$w$分为子串$s_1,s_2,\\cdots,s_n$。 在这些串上运行$M_X$，如果$M_X$接受了所有子串那么$M$就接受，如果有子串的结果是拒绝那么$M$就拒绝。 （4）补运算：\n有TM：$M_X$识别语言$X$，识别$\\overline{X}$的TM：$M$如下：\n对于输入串$w$：\n在$w$上运行$M_X$，如果$M_X$接受那么$M$就拒绝，否则$M$就接受。 （5）交运算：\n有TM：$M_X,M_Y$分别识别语言$X,Y$，识别$X\\cap Y$的TM：$M_{XY}$如下：\n对于输入串$w$：\n在$w$上运行$M_X$，如果$M_X$接受就进入步骤2，否则$M_{XY}$就拒绝。 在$w$上运行$M_Y$，如果$M_Y$接受那么$M_{XY}$接受。否则$M_{XY}$就拒绝。 线性有界自动机和上下文有关语言 线性有界自动机 $\\boldsymbol{Definition\\ 3.1:}$\n现在给出 线性有界自动机（linear bounded automaton,LBA） 的介绍，它是一种非确定的图灵机，这个图灵机满足下列两个条件：\n输入字母表包含两个特殊的符号$￠$和$¥$，其中$￠$作为输入符号串的左端标志，¥作为输入符号串的右端标志。 LBA的读头只能在$￠$和$¥$之间移动，且LBA不能在端点符号$￠$和$¥$上面打印另外一个符号。 一台LBA可以被视为一个八元组$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,￠,¥,F)$，其接受的语言$L(M)=${$w|w\\in(\\Sigma-${$￠,¥$}$)^{ * }且\\exists q\\in F使得q_0￠w$\\vdash^{ * }￠\\alpha q\\beta¥$}，其中$\\alpha,\\beta,w\\in\\Sigma^{ * }$。在LBA中它所提供的存储空间受限于它的输入规模，这也是这个计算模型的名称的由来。\n类似地，LBA也有格局的概念，显然如果$M$是一个有$q$个状态和$g$个带子符号的LBA，对于长度为$n$的带子，$M$恰好有$qng^n$个格局。\n线性有界自动机和上下文有关文法的等价性 $\\boldsymbol{Theorem\\ 3.2:}$\n如果$L$是CSL且$\\epsilon\\notin L$，则存在LBA：$M$使得$L=L(M)$。\n$\\boldsymbol{Proof:}$由于$L$是CSL，不妨设CSG：$G=(V,T,P,S)$使得$L=L(G)$，用一个双道的图灵机来模拟$G$，在$M$的第一道上存放字符串$￠w¥$，在第二道上全是空白符。$M$启动后首先在第二道的与$w$的首字符对应的带方格内印刷上$G$的开始符号$S$，然后类似于前文中证明图灵机与PSG等价那样的在第二道上生成$w$的推导，由于$G$是CSG，所以如果第二道上的句型长度超过$|w|$就意味着这次推导失败了，如果某次推导成功了就接受$w$，显然对于LBA而言推导是有上限的，此时依旧都是推导失败那么就拒绝。\n$\\boldsymbol{Theorem\\ 3.3:}$\n对于任意$L$，若$\\epsilon\\notin L$且存在LBA：$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,￠,¥,F)$使得$L=L(M)$，那么$L$是CSL。\n$\\boldsymbol{Proof:}$也类似于前文中证明TM与PSG等价的过程，主要是根据给定的LBA构造出$G$，这里的双副本串是形如$(a_1,q_0￠a_1)(a_2,a_2)\\cdots(a_n,a¥)$的符号行，当长度为一时其为$(a,q_0￠a¥)$，$P$包含如下的产生式：\n对于$\\forall a\\in\\Sigma-${$￠,¥$}有$A_1\\rightarrow(a,q_0￠a)A_2$，准备模拟$M$从$q_0$启动并生成双副本串$(a_1,q_0￠a_1)(a_2,a_2)\\cdots(a_n,a¥)$中的$(a_1,q_0￠a_1)$并将生成剩余子串的任务交给$A_2$。 对于$\\forall a\\in\\Sigma-${$￠,¥$}有$A_1\\rightarrow(a,q_0￠a¥)$，用于生成双副本串$(a,q_0￠a¥)$。 对于$\\forall a\\in\\Sigma-${$￠,¥$}有$A-2\\rightarrow(a,a)A_2|(a,a¥)$，$A_2$生成子串。 对于$\\forall a,b\\in\\Sigma-${$¥$}$,\\forall q,p\\in Q,\\forall X,Y,Z\\in\\Gamma,X\\neq¥$，如果$\\delta(q,X)=(p,Y,R)$，则有$(a,qX)(b,Z)\\rightarrow(a,Y)(b,pZ)$，$G$模拟$M$的一次右移。 对于$\\forall a,b\\in\\Sigma-${$￠$}$,\\forall q,p\\in Q,\\forall X,Y,Z\\in\\Gamma$，如果$\\delta(q,X)=(p,Y,L)$，则有$(b,Z)(a,qX)\\rightarrow(b,pZ)(a,Y)$，$G$模拟$M$的一次左移。 对于$\\forall a\\in\\Sigma,\\forall q\\in F,\\forall X,Y\\in\\Gamma-${$B$}有$(a,XqY)\\rightarrow a$，由于$q$为终止状态，可以消除句型中的状态$q$。 对于$\\forall a\\in\\Sigma-${$￠,¥$}$,\\forall X\\in\\Gamma-${$B$}有$(a,X)b\\rightarrow ab,a(b,X)\\rightarrow ab$。 上下文有关语言的性质 之前因为还没有介绍LBA，所以没有给出CSL的性质，下文将进行介绍。\n$\\boldsymbol{Theorem\\ 3.4:}$\nCSL类在并、连接、交、补、克林闭包和反转运算下封闭，在此仅对前两者进行证明。\n$\\boldsymbol{Proof:}$\n（1）并运算：\n有CSG：$G_1=(N_1,T_1,P_1,S_1),G_2=(N_2,T_2,P_2,S_2),L_1=(G_1),L_2=L(G_2)$，不妨令$N_1\\cap N_2=\\varnothing$，考虑文法$G=(S\\cup N_1\\cup N_2,T_1\\cup T_2,${$S\\rightarrow S_1,S\\rightarrow S_2$}$\\cup P_1\\cup P_2,S)$，其中$S\\notin N_1\\cup N_2$，这里的$G$显然是CSG。\n（2）连接运算：\n设CSG：$G_1=(N_1,T,P_1,S_1),G_2=(N_2,T,P_2,S_2),L_1=(G_1),L_2=L(G_2)$，不妨令$N_1\\cap N_2=\\varnothing$，考虑文法$G=(S\\cup N_1\\cup N_2,T,${$S\\rightarrow S_1S_2$}$\\cup P_1\\cup P_2,S)$，其中$S\\notin N_1\\cup N_2$，这里的$G$显然是CSG。\n$\\boldsymbol{Note\\ 3.5:}$\n不同于RL和CFL，CSL没有对应的“泵引理”，事实上CSL的表示能力是相当强大的，例如{$a^p|p是素数$}也是一个CSL，这样一个语言显然不具有先前介绍的“泵引理”那样的性质。到目前为止也不具备判断一个语言不是CSL的好的方法，但是依旧可以证明部分语言不是CSL。\n根据乔姆斯基文法体系，可以知道CSL是图灵可识别语言，但是无法得知CSL是否是可判定的，下面给出了相关定理。\n$\\boldsymbol{Theorem\\ 3.6:}$\n任意CSL都是可判定的，也就是说CFL、DCFL和RL也都是可判定的。\n$\\boldsymbol{Proof:}$对于任意CSL：$L$，有CSG使得$L(G)=L$，下面给出一个判定$L$的TM：$M$：\n$M=$“对于输入$\u0026lt; w \u0026gt;$，其中$w$是CSL：\n模拟LBA：$A$使得$L(G)=L(A)$，$A$有$q$个状态、$g$个带子符号和长度为$n$的带子。 在$w$上运行$A$，并且记录$A$在这个过程中产生的格局。 如果$A$接受则$M$接受，如果$A$拒绝或记录的格局超过了$qng^n$个就拒绝。 $\\boldsymbol{Theorem\\ 3.7:}$\nCSL类是可判定语言类的真子类。\n$\\boldsymbol{Proof:}$考虑所有可能的CSG：$G_i=(N_i,${$0,1,\\cdots,9$}$,S_i,P_i)$，这些文法可以用于生成数字字符串，它们按照某种顺序排列。现在定义语言$L=${$i|i\\notin L(G_i)$}，显然判定一个CSG是否能生成一个长度有限的字符串是可以由TM解决的，所以$L$一定是一个PSL。假定$L$是CSL，那么就存在一个CSG：$G_k$使得$L(G_k)=L$，因为$G_1,G_2,\\cdots$已经包含了所有可能的CSG。若$k\\in L(G_k)$，根据$L$的定义，那么$k\\notin L$，发生矛盾；若$k\\in L(G_k)$便也会发生矛盾。故$L$表示一个CSL，CSL都是可判定的，所以CSL类是可判定语言类的真子类。\n可判定性 可判定语言 根据丘奇-图灵论题，前文用TM定义了算法的概念，虽然计算机科学的绝大部分是研究可求解问题的，但是实际上也存在着算法解决不了的问题。通常人们追求问题的答案，而在此时试图证明该问题的不可解性似乎没有什么用处。但是研究不可解性有两个理由：\n知道一个问题在算法上是不可解的，也就不必浪费去寻找不可能的解法，为了更好地使用计算机，就必须正确地认识它的能力和局限。 锻炼人的能力，即使处理的问题都是可解的，了解不可解性也能激发想象力，并使人全面而透彻地理解什么是计算。 在之前已经介绍了RL、CFL的判定问题，在介绍了TM之后，可以回过头来看这些问题，例如DFA的 接受问题（acceptance problem） ，即检测一个特定的DFA是否接受一个事先给定的串，不妨令$A_{DFA}=${$\u0026lt; B,w \u0026gt;|B是DFA且接受输入串w$}，那么问题“DFA是否接受输入$w$和问题“$\u0026lt; B,w \u0026gt;$是否是$A_{DFA}$的元素”是相同的，如果可以证明$A_{DFA}$是可判定的，也就意味着“一个给定的DFA是否接受一个给定的串”是可判定的。\n$\\boldsymbol{Theorem\\ 4.1:}$\n$A_{DFA}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$A_{DFA}$的TM：$M$：\n$M=$“对于输入$\u0026lt; B,w \u0026gt;$，其中$B$是DFA，$w$是串”：\n在输入$w$上模拟$B$。 如果模拟以接受状态结束则接受，如果以非接受状态结束则拒绝。 $\\boldsymbol{Theorem\\ 4.2:}$\n$A_{NFA}=${$\u0026lt; B,w \u0026gt;|B是NFA且接受输入串w$}，$A_{NFA}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$A_{NFA}$的TM：$M$：\n$M=$“对于输入$\u0026lt; B,w \u0026gt;$，其中$B$是NFA，$w$是串”：\n将$B$转换成等价的DFA：$C$。 在输入$w$上模拟$C$。 如果模拟以接受状态结束则接受，如果以非接受状态结束则拒绝。 $\\boldsymbol{Theorem\\ 4.3:}$\n$A_{REX}=${$\u0026lt; B,w \u0026gt;|B是正则表达式，w是串，R派生w$}，$A_{REX}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$A_{REX}$的TM：$M$：\n$M=$“对于输入$\u0026lt; R,w \u0026gt;$，其中$R$是正则表达式，$w$是串”：\n将$R$转换成等价的DFA：$C$。 在输入$w$上模拟$C$。 如果模拟以接受状态结束则接受，如果以非接受状态结束则拒绝。 上面很清晰地说明了对于可判定性，用DFA、NFA或正则表达式表达图灵机都是等价的，因为TM可以将它们的编码进行相互转换。\n在之前也介绍了DFA的空性质测试，也就是检查一个DFA是否根本不接受任何串。令$E_{DFA}=${$\u0026lt; A \u0026gt;|A是一个DFA且L(A)=\\varnothing$}。同时也有检查两个DFA是否识别同一个语言的问题，记$EQ_{DFA}=${$\u0026lt; A,B \u0026gt;|A和B都是DFA且L(A)=L(B)$}。\n$\\boldsymbol{Theorem\\ 4.4:}$\n$E_{DFA}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$E_{DFA}$的TM：$M$：\n$M=$“对于输入$\u0026lt; A \u0026gt;$，其中$A$是DFA：\n标记$A$的初始状态。 重复下列步骤，直到出现无法标记新状态的情况。 对于一个状态，如果有一个到达它的转移是从某个已经标记过的状态出发的，则将其标记。 如果没有接受状态被标记就接受，否则就拒绝。 $\\boldsymbol{Theorem\\ 4.5:}$\n$EQ_{DFA}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$EQ_{DFA}$的TM：$T$：\n$T=$“对于输入$\u0026lt; A,B \u0026gt;$，其中$A$和$B$是DFA：\n模拟一个DFA：$C$使得$L(C)=((L(A)\\cap\\overline{L(B)})\\cup(\\overline{L(A)}\\cap L(B)))$。 在输入$\u0026lt; C \u0026gt;$上运行$\\boldsymbol{Theorem\\ 4.4}$中给出的TM：$M$。 如果$M$接受就接受，否则就拒绝。 由于先前已经给出了CFG和PDA之间的相互转换过程，它们的可判定性问题之间也可以相互转换。\n$\\boldsymbol{Theorem\\ 4.6:}$\n$A_{CFG}=${$\u0026lt; G,w \u0026gt;|G是CFG，w是串，G派生w$}，$A_{CFG}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$A_{CFG}$的TM：$S$：\n$S=$“对于输入$\u0026lt; G,w \u0026gt;$，其中$G$是CFG，$w$是串”：\n将$G$转换成等价的CNF。 列出所有$2|w|-1$步的派生，除非$|w|=0$，此时列出一步以内的派生。 如果这些派生中有一个产生了$w$则接受，否则拒绝。 $\\boldsymbol{Theorem\\ 4.7:}$\n$E_{CFG}=${$\u0026lt; G \u0026gt;|G是一个CFG且L(A)=\\varnothing$}，$E_{CFG}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$E_{CFG}$的TM：$M$：\n$M=$“对于输入$\u0026lt; G \u0026gt;$，其中$G$是CFG：\n标将$G$中所有的终结符全部作上标记。 重复下列步骤，直到出现无法标记新的变元。 如果$G$有产生式$A\\rightarrow U_1U_2\\cdots U_k$且$U_1,U_2,\\cdots,U_k$中的每一个符号都已经被作过标记，那么将变元$A$标记。 如果起始变元没有被标记就接受，否则就拒绝。 $\\boldsymbol{Theorem\\ 4.8:}$\n$A_{LBA}=${$\u0026lt; M,w \u0026gt;|M是LBA，w是串，M接受w$}，$A_{LBA}$是可判定语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$A_{LBA}$的TM：$L$：\n$L=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是LBA，$w$是串：\n在$w$上模拟$M$共$qng^n$步，或者直到它停机，其中$M$有$q$个状态、$g$个带子符号和长度为$n$的带子。 如果$M$停机则当它接受时接受，否则拒绝，如果它没有停机那么拒绝。 不可判定语言 $\\boldsymbol{Theorem\\ 4.9:}$\n$A_{TM}=${$\u0026lt; M,w \u0026gt;|M是TM，w是串，M接受w$}，$A_{TM}$是可识别语言。\n$\\boldsymbol{Proof:}$下面给出一个判定$A_{TM}$的TM：$U$：\n$U=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM，$w$是串：\n在输入$w$上模拟$M$。 如果$M$进入接受状态那么接受，如果$M$进入拒绝状态那么拒绝。 注意如果$M$在$w$上发生了循环，则机器$U$在输入$\u0026lt; M,w \u0026gt;$上循环，这也是为何$U$无法判定$A_{TM}$的原因。$U$本身也很有意思，它是所谓 通用图灵机（universal Turing machine） 的一个例子，之所以称为是通用图灵机，是因为它能够模拟其他任何的图灵机。\n$\\boldsymbol{Theorem\\ 4.10:}$\n$A_{TM}$是不可判定语言。\n$\\boldsymbol{Proof:}$假设$A_{TM}$是可判定的，它的判定器是$H$，令$M$为TM、$w$为一个串，在输入$\u0026lt; M,w \u0026gt;$上，如果$M$接受$w$则$H$就停机且接受$w$，如果$M$不接受$w$则$H$也会停机但拒绝$w$。考虑TM：$D$：\n$D=$“对于输入\u0026lt; M \u0026gt;，其中$M$是一个TM”：\n在输入$\u0026lt; M,\u0026lt; M \u0026gt; \u0026gt;$上运行$H$。 如果$H$接受就拒绝，反之就接受。 也就是说当$M$不接受$\u0026lt; M \u0026gt;$的时候$D$就接受输入$\u0026lt; M \u0026gt;$，如果$M$接受$\u0026lt; M \u0026gt;$的时候$D$就拒绝输入$\u0026lt; M \u0026gt;$，并且$D$是一个判定器。当以$D$的描述$\u0026lt; D \u0026gt;$作为$D$的输入时会发生矛盾，故$D$不存在，于是$H$不存在，证毕。\n$\\boldsymbol{Theorem\\ 4.11:}$\n存在不能被任何TM识别的语言。\n$\\boldsymbol{Proof:}$在集合论的学习中可以知道自然数集合$N$是可数的，而实数集合$R$是不可数的，也就是说$N$的势比$R$的势要小，不存在一个从$N$到$R$的双射。在证明中也将会这么做。\n对于任意的字母表$\\Sigma$，其上所有串的集合$\\Sigma^{ * }$是可数的，这是因为对于每个自然数$n$，长度为$n$的串只有有限多个，可以以此写下长度为$0$的串、长度为$1$的串、长度为$2$的串，这样就可以构造出$\\Sigma^{ * }$的序列。\n所有TM构成的集合是可数的，因为每个TM：$M$都可以对应于一个编码$\u0026lt; M \u0026gt;$，只要去掉不是图灵机编码的串便得到了一个TM的序列。\n$\\Sigma$上所有语言构成的集合$\\mathcal{L}$实际上是所有串的集合$\\Sigma^{ * }$的幂集，利用集合论中的康托尔定理可知$\\mathcal{L}$是不可数的，这也就意味着所有语言的集合与所有TM的集合之间不能有一一对应，可以下结论：存在不能被任何TM识别的语言。\n$\\boldsymbol{Definition\\ 4.12:}$\n一个语言的补是由不在这个语言中的所有串构成的语言，如果一个语言是一个图灵可识别语言的补集，就称它是 补图灵可识别的（co-Turing-recognizable） 。\n$\\boldsymbol{Theorem\\ 4.13:}$\n一个语言都是可判定的当且仅当它既是图灵可识别的，也是补图灵可识别的。\n$\\boldsymbol{Proof:}$如果$A$是可判定的，那么$\\overline{A}$也是可判定的，故$A$是图灵可识别的，也是补图灵可识别的。\n如果$A$和$\\overline{A}$都是图灵可识别的，令它们的识别器分别为$A_1,A_2$，现在给出$A$的判定器：\n$M=$“对于输入$w$”：\n在输入$w$上并行运行$M_1$和$M_2$。 如果$M_1$接受就接受，如果$M_2$接受就拒绝。 $\\boldsymbol{Corollary\\ 4.14:}$\n$\\overline{A_{TM}}$不是图灵可识别的。\n可归约性 语言理论中的不可判定问题 $\\boldsymbol{Definition\\ 5.1:}$\n归约（reduction） 旨在将一个问题转化成另一个问题，且使得可以用第二个问题的解来解第一个问题。例如在新城市中认路，如果有一张地图在身那就容易多了，认路问题就归约得到地图问题。\n当$A$可归约到$B$时解$A$不可能比解$B$更难，因为$B$的一个解给出了$A$的一个解，根据可计算性理论，如果$A$可归约到$B$，且$B$是可判定的，则$A$也是可判定的。如果$A$是不可判定的，且可归约到$B$，则$B$也是不可判定的。\n$\\boldsymbol{Theorem\\ 5.2:}$\n确定一个TM对给定的输入是否会停机的问题被称为 停机问题（halting problem） ，$HALT_{TM}=${$\u0026lt; M,w \u0026gt;|M是一个TM且对输入w停机$}，$HALT_{TM}$是不可判定的。\n$\\boldsymbol{Proof:}$设TM：$R$判定$HALT_{TM}$，可以构造识别$A_{TM}$的TM：$S$：\n$S=$“在输入$\u0026lt; M,w \u0026gt;$上，此处$\u0026lt; M,w \u0026gt;$是TM：$M$和串$w$的编码”：\n在输入$\u0026lt; M,w \u0026gt;$上运行TM：$R$。 如果$R$拒绝就拒绝。 如果$R$接受就在$w$上模拟$M$直到它停机。 如果$M$已经接受就接受，否则拒绝。 $\\boldsymbol{Theorem\\ 5.3:}$\n$E_{TM}=${$\u0026lt; M \u0026gt;|M是一个TM且L(M)=\\varnothing$}，$E_{TM}$是不可判定的。\n$\\boldsymbol{Proof:}$假定判定$E_{TM}$的TM为$R$，下面给出一个判定$A_{TM}$的TM：$S$：\n$M_1=$“对于输入$x$，其中$x$是串：\n如果$x\\neq w$则拒绝。 如果$x=w$则在输入$w$上运行$M$，当$M$接受时则接受。 $S=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM、$w$是串：\n用$M$和$w$的描述来构造上述TM：$M_1$。 在输入$\u0026lt; M_1 \u0026gt;$上运行$R$。 如果$R$接受就拒绝，否则就接受。 $\\boldsymbol{Theorem\\ 5.4:}$\n$REGULAR_{TM}=${$\u0026lt; M \u0026gt;|M是一个TM且L(M)是正则语言$}，$REGULAR_{TM}$是不可判定的。\n$\\boldsymbol{Proof:}$假定判定$REGULAR_{TM}$的TM为$R$，下面给出一个判定$A_{TM}$的TM：$S$：\n$M_2=$“对于输入$\u0026lt; M,w \u0026gt;$，$M$是TM，$x$是串”：\n如果$x$具有形式$0^n1^n$则接受。 如果$x$不具有此形式，则在输入$w$上运行$M$，如果$M$接受则接受。 $S=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM，$w$是串”：\n利用$M$和$w$构造相应的TM：$M_2$。 在输入$\u0026lt; M_2 \u0026gt;$上运行$R$。 如果$R$接受则接受，否则拒绝。 $\\boldsymbol{Theorem\\ 5.5:}$\n$EQ_{TM}=${$\u0026lt; M_1,M_2 \u0026gt;|M_1和M_2都是TM且L(M_1)=L(M_2)$}，$EQ_{TM}$是不可判定的。\n$\\boldsymbol{Proof:}$假定判定$EQ_{TM}$的TM为$R$，下面给出一个判定$E_{TM}$的TM：$S$：\n$S=$“对于输入$\u0026lt; M \u0026gt;$，其中$M$是TM”：\n在输入$\u0026lt; M,M_1 \u0026gt;$上运行$R$，其中$M_1$是拒绝所有输入的TM。 如果$R$接受则接受，否则拒绝。 $\\boldsymbol{Theorem\\ 5.6:}$\n$E_{LBA}=${$\u0026lt; B \u0026gt;|B是一个LBA且L(B)=\\varnothing$}，$E_{LBA}$是不可判定的。\n$\\boldsymbol{Proof:}$通过构造LBA：$B$使得它识别的语言包含了$M$在$w$上的所有接受计算历史就可以实现归约。设$x$是$M$在$w$上的一个接受计算历史$C_1,C_2,\\cdots,C_l$，不妨表示为一个串并用#相互隔开。$B$首先对于输入的接受计算历史$x$会先将其分解为$C_1,C_2,\\cdots,C_l$，之后$B$检查$C_i$是否满足接受计算历史的三个条件：\n$C_1$是$M$在$w$上的起始格局。 每个$C_{i+1}$都是$C_i$的合法结果。 $C_l$是$M$的一个接受格局。 很容易实现这样的$B$，在此不作详细的说明。\n假设TM：$R$判定$E_{LBA}$，下面给出一个判定$A_{TM}$的TM：$S$：\n$S=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM，$w$是串”：\n按照上述思路从$M$和$w$中构造LBA：$B$。 在输入$\u0026lt; B \u0026gt;$上运行$R$。 如果$R$拒绝则接受，否则拒绝。 $\\boldsymbol{Theorem\\ 5.7:}$\n$ALL_{CFG}=${$\u0026lt; G \u0026gt;|G是一个CFG且L(G)=\\Sigma^{ * }$}，$EQ_{CFG}=${$\u0026lt; G_1,G_2 \u0026gt;|G_1和G_2都是CFG且L(G_1)=L(G_2)$}，$ALL_{CFG}$和$EQ_{CFG}$都是不可判定的，$EQ_{CFG}$是补图灵可识别的，在此不作证明。\n$\\boldsymbol{Theorem\\ 5.8:}$\n赖斯定理（Rice\u0026rsquo;s theorem） 指出图灵可识别语言的所有非平凡性质都是不可判定的。\n具体地说，设$P$是一个语言，它由TM的描述组成，且$P$满足两个条件：\n$P$是非平凡的，它包含TM的描述但不是所有的。 $P$是TM的语言的属性，对于任意TM：$M_1,M_2$，若有$L(M_1)=L(M_2)$，那么$\u0026lt; M_1 \u0026gt;\\in P$当且仅当$\u0026lt; M_2 \u0026gt;\\in P$。 那么$P$就是一个不可判定语言。\n$\\boldsymbol{Proof:}$设$P$是满足属性的可判定语言，其判定机为$R_P$，设$T_\\varnothing$是一个总是拒绝的TM，那么有$L(T_\\varnothing)=\\varnothing$。不妨设$\u0026lt; T_\\varnothing \u0026gt;\\notin P$，由于$P$是非平凡的，存在一个TM：$T$使得$\u0026lt; T \u0026gt;\\in P$，下面给出一个判定$A_{TM}$的TM：$S$：\n$S=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM，$w$是串”：\n用$M$和$w$构造TM：$M_w$，其对于输入$x$：首先在$w$上模拟$M$，如果拒绝就拒绝；如果接受那么在$x$上模拟$T$，如果依旧是接受那么$M_w$就接受。 用TM：$R_P$确定是否有$\u0026lt; M_w \u0026gt;\\in P$，如果是那么接受，如果否那么拒绝。 如果$M$接受$w$，那么TM：$M_w$可以模拟$T$。如果$M$接受$w$还接受$\\varnothing$，那么$L(M_w)$等于$L(T)$，因此当且仅当$M$接受$w$时$\u0026lt; M_w \u0026gt;\\in P$。\n映射可归约性 $\\boldsymbol{Definition\\ 5.9:}$\n函数$f:\\Sigma^{ * }\\rightarrow\\Sigma^{ * }$是一个 可计算函数（computable function） ，如果有某个TM：$M$使得在每个输入$w$上$M$停机且此时只有$f(w)$出现在带子上。\n$\\boldsymbol{Definition\\ 5.10:}$\n语言$A$是 映射可归约（mapping reducible） 到语言$B$的，如果存在可计算函数$f:\\Sigma^{ * }\\rightarrow\\Sigma^{ * }$使得1对于1每个$w$都有$w\\in A\\Leftrightarrow f(w)\\in B$，记作$A\\leq_m B$，称函数$f$为从$A$到$B$的 归约 。显然$\\leq_m$是一个传递关系。\n$\\boldsymbol{Theorem\\ 5.11:}$\n如果$A\\leq_mB$且$B$是可判定的，则$A$也是可判定的。\n$\\boldsymbol{Proof:}$设$M$是$B$的判定器，$f$是从$A$到$B$的归约，下面给出$A$的判定器$N$：\n$N=$“对于输入$w$，其中$w$是串”：\n计算$f(w)$。 在$f(w)$上运行$M$，输出$M$的输出。 $\\boldsymbol{Corollary\\ 5.12:}$\n如果$A\\leq_mB$且$A$是不可判定的，则$B$也是不可判定的。\n$\\boldsymbol{Example\\ 5.13:}$\n在$\\boldsymbol{Theorem\\ 5.5}$的证明中隐含了一个从$E_{TM}$到$EQ_{TM}$的映射归约，此归约$f$将输入$\u0026lt; M \u0026gt;$映射到输出$\u0026lt; M,M_1 \u0026gt;$，其中$M_1$是拒绝所有输入的机器。\n$\\boldsymbol{Theorem\\ 5.14:}$\n如果$A\\leq_mB$且$B$是图灵可识别的，则$A$也是图灵可识别的。\n$\\boldsymbol{Proof:}$设$M$是$B$的识别器，$f$是从$A$到$B$的归约，下面给出$A$的识别器$N$：\n$N=$“对于输入$w$，其中$w$是串”：\n计算$f(w)$。 在$f(w)$上运行$M$，输出$M$的输出。 $\\boldsymbol{Corollary\\ 5.15:}$\n如果$A\\leq_mB$且$A$不是图灵可识别的，则$B$不是图灵可识别的。\n$\\boldsymbol{Theorem\\ 5.16:}$\n$EQ_{TM}$既不是图灵可识别的，也不是补图灵可识别的。\n$\\boldsymbol{Proof:}$首先证明$EQ_{TM}$不是图灵可识别的，只要证明从$A_{TM}$可归约到$\\overline{EQ_{TM}}$，考虑计算归约函数$f$的TM：$F$：\n$F=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM，$w$是串”：\n构造两个机器$M_1$和$M_2$：$M_1$对于任何输入都拒绝；$M_2$对于任何输入都在$w$上运行$M$，如果接受就接受。 输出$\u0026lt; M_1,M_2 \u0026gt;$。 证明$EQ_{TM}$不是补图灵可识别的，只要证明从$A_{TM}$可归约到$EQ_{TM}$，考虑计算归约函数$g$的TM：$G$：\n$G=$“对于输入$\u0026lt; M,w \u0026gt;$，其中$M$是TM，$w$是串”：\n构造两个机器$M_1$和$M_2$：$M_1$对于任何输入都接受；$M_2$对于任何输入都在$w$上运行$M$，如果接受就接受。 输出$\u0026lt; M_1,M_2 \u0026gt;$。 显然$w\\in A_{TM}\\Leftrightarrow f(w)\\in\\overline{EQ_{TM}}$且$w\\in A_{TM}\\Leftrightarrow g(w)\\in EQ_{TM}$，也就是说$A_{TM}\\leq_mEQ_{TM}$且$A_{TM}\\leq_m\\overline{EQ_{TM}}$。\n$\\boldsymbol{Note\\ 5.17:}$\n在之前和本文中都对一些语言之间的关系进行了讨论，下面给出了一个韦恩图表示各种语言之间的关系。\n图灵可归约性 直观上来看$A_{TM}$和$\\overline{A_{TM}}$应该是可以相互归约的问题，因为它们当中任一个问题的解都可以用来解另一个问题，但是$\\overline{A_{TM}}\\leq_mA_{TM}$是不正确的，因为$A_{TM}$是图灵可识别的而$\\overline{A_{TM}}$不是。\n$\\boldsymbol{Definition\\ 5.18:}$\n语言$B$的一个 谕示（oracle） （也称为预言者）是一个能够报告某个串$w$是否为$B$的成员的外部装置，这个术语本身就意味着一种神奇的能力，意味着谕示的能力超越了算法的能力。一个 谕示图灵机（oracle Turing machine） （也称为预言机）是一种修改过的图灵机，它有着询问一个谕示的额外能力，记$M^B$为对语言$B$有谕示的谕示图灵机。\n$\\boldsymbol{Example\\ 5.19:}$\n考虑$A_{TM}$的一个谕示，那么可以给出判定$E_{TM}$的方法：\n$T^{A_{TM}}=$“对于输入$\u0026lt; M \u0026gt;$，其中$M$是一个TM”：\n构造TM：$N$，它对于任何输入，先对$\\Sigma^{ * }$中的所有串并行运行$M$，如果$M$接受了其中任何一个串$N$就接受。 询问谕示以确定$\u0026lt; N,0 \u0026gt;\\in A_{TM}$是否成立。 谕示回答“不”则接受，否则拒绝。 可以看出$T^{A_{TM}}$判定$E_{TM}$，于是说$E_{TM}$是相对于$A_{TM}$可判定的（decidable relative）。\n$\\boldsymbol{Note\\ 5.20:}$\n带$A_{TM}$的谕示的图灵机的能力依旧是有限的，它不能判定{$\u0026lt; M,w \u0026gt;|M是一个谕示图灵机且M^{A_{TM}}接受w$}。\n$\\boldsymbol{Definition\\ 5.21:}$\n称语言$A$ 图灵可归约（Turing reducible） 到语言$B$，如果$A$相当于$B$是可判定的，记作$S\\leq_TB$。显然如果有$A\\leq_mB$，那么$A\\leq_TB$。显然$\\leq_T$是一个传递关系。\n$\\boldsymbol{Theorem\\ 5.22:}$\n如果$A\\leq_TB$且$B$是可判定的，那么$A$也是可判定的。\n$\\boldsymbol{Proof:}$如果$B$是可判定的，用判定$B$的时间过程来替换$B$的谕示即可。\n递归定理 递归定理（recursion theorem） 是一个数学结论，在可计算性理论中起着重要作用，它与数理逻辑、自再生系统理论以及计算机病毒都有联系。递归定理指出，一台机器是有可能能够生产自己的。\n$\\boldsymbol{Theorem\\ 6.1:}$\n存在可计算函数$q:\\Sigma^{ * }\\rightarrow\\Sigma^{ * }$，对任意串$w$，$q(w)$是TM：$P_w$的描述，$P_w$打印出$w$然后停机。\n$\\boldsymbol{Proof:}$可以给出一个计算$q(w)$的TM：$Q$：\n$Q=$“对于输入串$w$”：\n构造TM：$P_w$，其对于任何输入都会抹去输入、在带上写下$w$而后停机。 输出$\u0026lt; P_w \u0026gt;$。 接下来将试图给出一个TM：$SELF$，它可以打印出自己的描述，也就是可以实现 自引用（self-reference） ，它含有两个部分$A$和$B$，也就是说要让$SELF$打印出$\u0026lt; SELF \u0026gt;=\u0026lt; AB \u0026gt;$。$A$会先于$B$运行，它的任务是打印出$B$的描述，反过来$B$的任务是打印出$A$的描述，首先使用$P_{\u0026lt; B \u0026gt;}$来定义$A$，也就是说$A$是一个打印出$\u0026lt; B \u0026gt;$的TM，但是不能用$q(\u0026lt; A \u0026gt;)$定义$B$，否则会产生 循环定义（circular definition） ，这是违背逻辑法则的，为此还要找到一种方式定义$N$。\n如果$B$能够获得到$\u0026lt; B \u0026gt;$，那么它自然可以得到$q(\u0026lt; B \u0026gt;)$，也就是$A$，当$A$结束后留下了$\u0026lt; B \u0026gt;$在带子上，也就是说$B$可以从带子上获得$\u0026lt; B \u0026gt;$，在计算得到$\u0026lt; A \u0026gt;$后$B$便将其加在带子的前面，然后将$A$和$B$组合成一个机器写在带子上得到$\u0026lt; AB \u0026gt;=\u0026lt; SELF \u0026gt;$。总之：\n$A=P_{\u0026lt; B \u0026gt;}$，$B=$“对于输入$\u0026lt; M \u0026gt;$，其中$M$是一个TM的一部分”：\n计算$q(\u0026lt; M \u0026gt;)$。 将其结果与$\u0026lt; M \u0026gt;$结婚来组成一个完整的图灵机描述。 打印这个描述，然后停机。 $\\boldsymbol{Example\\ 6.2:}$\n打印下面两个语句的副本，在第二个副本上加引号：\n“打印下面两个语句的副本，在第二个副本上加引号：”\n上面这个句子便是一种自引用,第一行是$B$，第二行是$A$。\n$\\boldsymbol{Example\\ 6.3:}$\nQuine以哲学家Willard van Orman Quine（1908~2000）命名，表示一个可以生成他自己的完全的源代码的程序，图灵奖得主Ken Thompson（1943~）设计了一个可以实现该功能的C语言程序，虽然这段程序忽略了 #include \u0026lt; stdio.h \u0026gt;还假设了双引号的值为ASCII的值，并且要求程序写在同一行。\n1 char*s=\u0026#34;char*s=%c%s%c;main(){printf(s,34,s,34);}\u0026#34;; main(){printf(s,34,s,34);} 那么$A$对应于 \u0026quot;char*s=%c%s%c;main(){printf(s,34,s,34);}\u0026quot;，而$B$对应于 main(){printf(s,34,s,34);}。\n$\\boldsymbol{Theorem\\ 6.4:}$\n递归定理：设$T$是计算函数$t:\\Sigma^{ * }\\times\\Sigma^{ * }\\rightarrow\\Sigma^{ * }$的一个TM。则存在计算函数$r:\\Sigma^{ * }\\rightarrow\\Sigma^{ * }$的一个TM：$R$是的对于每一个$w$都有$r(w)=t(\u0026lt; R \u0026gt;,w)$。\n这个定理表明，为了能够得到自己的描述还能用这个描述来计算的TM，只需要制造一个在这个定理中称为$T$的TM，使之以自己的描述作为输入的一部分，然后递归定理就产生一个新的机器$R$，它和$T$一样运行，只是$R$的描述被自动地装在$T$中，那么$T$便可以利用它自身的描述了。\n$\\boldsymbol{Proof:}$类似于构造$SELF$，分三部分$A,B,C$来构造TM：$R$，其中$T$由定理的叙述得出，$A$是由$q(\u0026lt; BT \u0026gt;)$描述的TM：$P_{\u0026lt; BT \u0026gt;}$，为了保持输入$w$只需要重新设计$q$使得$P_{\u0026lt; BT \u0026gt;}$先打印$w$即可，这样带子上包含$w\u0026lt; BT \u0026gt;$，然后$B$依旧是相同操作得到了$\u0026lt; ABT \u0026gt;=\u0026lt; R \u0026gt;$，最后把$\u0026lt; R,w \u0026gt;$传给$T$。\n递归定理是解决问题的有力工具，现在回到之前证明的一个定理，下面将使用递归定理证明它。\n$\\boldsymbol{Theorem\\ 4.10:}$\n$A_{TM}$是不可判定语言。\n$\\boldsymbol{Proof:}$假设$H$可以判定$A_{TM}$，构造下列TM：$B$：\n$B=$“对于输入$w$，其中$w$是串”：\n由递归定理得到自己的一个描述$\u0026lt; B \u0026gt;$。 在输入$\u0026lt; B,w \u0026gt;$上运行$H$。 如果$H$拒绝则接受，否则拒绝。 产生了矛盾，所以$H$不存在。\n$\\boldsymbol{Theorem\\ 6.5:}$\n递归定理的 不动点（fixed point） 形式：设$t:\\Sigma^{ * }\\rightarrow\\Sigma^{ * }$是一个可计算函数，则存在一个TM：$F$使得$t(\u0026lt; F \u0026gt;)$描述一个与$F$等价的TM。这里假设如果串不是一个正确的图灵机编码，那么它描述的TM立即拒绝。\n$\\boldsymbol{Proof:}$，现在给出TM：$F$：\n$F=$“对于输入$w$”：\n由递归定理得到它自己的一个描述$\u0026lt; F \u0026gt;$。 计算$t(\u0026lt; F \u0026gt;)$得到TM：$G$的描述。 在输入$w$上模拟$G$。 显然$\u0026lt; F \u0026gt;$和$t(\u0026lt; F \u0026gt;)=\u0026lt; G \u0026gt;$都描述了等价的TM。\n","date":"2024-08-06T00:00:00Z","image":"https://0x3a0x29.github.io/p/turingmachine/image_hu3082675700674257570.png","permalink":"https://0x3a0x29.github.io/p/turingmachine/","title":"图灵机TM及可计算性"},{"content":"下推自动机PDA及上下文无关语言CFL 前言 阅读本文需要集合论、图论和数据结构的相关知识，在此不作有关相关知识的赘述。\n笔者水平有限，存在的错误和不足请大家指正。\n文法 文法的形式化定义 语言学家们在研究自然语言的理解的过程中完成了对 文法（grammar） 这一概念的形式化，通过找到一种自然语言的形式化的文法，可以有助于对这个语言的自动理解。例如可以用来帮助实现语言的机器翻译、文章摘要的提取、文稿的校对与更正等。现在给出文法的形式化定义：\n文法$G$是一个四元组$G=(V,T,P,S)$，其中：\n$V$是 变量（variable） 的非空有穷集，$\\forall A\\in V,A$被称为 语法变量（syntactic variable） ，简称变量，或称 终极符号（nonterminal） ，他表示一个 语法范畴（syntactic category） ，记作$L(A)$。\n$T$是 终极符（terminal） 的非空有穷集，$\\forall a\\in T,a$被称为终极符，由于$V$中的符号表示语法范畴，所以有$V\\cap T=\\varnothing$。\n$P$是 产生式（production） （或者称为 替换规则（substitution） ）的非空有穷集，$P$中的元素均有形式$\\alpha\\rightarrow\\beta$，称为产生式，读作$\\alpha$定义为$\\beta$，其中$\\alpha\\in(V\\cup T)^+$，且$\\alpha$中至少有$V$中的一个元素出现，$\\beta\\in (V\\cup T)^ { * }$。其中$\\alpha$被称为产生式$\\alpha\\rightarrow\\beta$的 左部 ，而$\\beta$称为产生式$\\alpha\\rightarrow\\beta$的 右部 。产生式也被称为定义式或者语法规则。\n$S\\in V$被称作$G$的 开始符号（start symbol） 。\n可以说文法的形式定义实际上给出了语言描述的一种模型。\n为了方便描述，对于拥有相同左部的产生式$\\alpha\\rightarrow\\beta_1,\\alpha\\rightarrow\\beta_2,\\cdots,\\alpha\\rightarrow\\beta_n$，可以用更加简便的方式去描述它，写作$\\alpha\\rightarrow\\beta_1|\\beta_2|\\cdots|\\beta_n$，其中的$\\beta_1,\\cdots,\\beta_n$被称作 候选式（candidate） 。\n对于文法$G=(V,T,P,S)$，如果$\\alpha\\rightarrow\\beta\\in P,\\gamma,\\delta\\in(V\\cup T)^{ * }$，则称$\\gamma\\alpha\\delta$在$G$中直接推导出$\\gamma\\beta\\delta$，记作$\\gamma\\alpha\\delta\\Rightarrow_G\\gamma\\beta\\delta$，读作$\\gamma\\alpha\\delta$在文法$G$中直接推导出$\\gamma\\beta\\delta$，可以简称直接推导为 推导（derivation） ，有时候也称作 派生 。与之对应的，也有 归约（reduction） 的概念，即指$\\gamma\\beta\\delta$在文法$G$中直接归约成$\\gamma\\alpha\\delta$，这是因为有产生式$\\alpha\\rightarrow\\beta$。\n很明显$\\Rightarrow_G$是$(V\\cup T)^{ * }$上的一个二元关系，那么可以对其作集合的相关运算，为了方便，我们用$\\Rightarrow^+_G$表示正闭包$(\\Rightarrow_G)^+$，用$\\Rightarrow^ { * }_G$表示克林闭包$(\\Rightarrow_G) ^ { * }$，用$\\Rightarrow^n_G$表示幂运算$(\\Rightarrow_G)^n$。在意义清楚的情况下也可以简写成$\\Rightarrow,\\Rightarrow^+,\\Rightarrow^ { * },\\Rightarrow^n$。类似的，对于归约的过程可以记作$\\mapsto$表示，也有类似的简写记号。\n从二元关系的合成的意义上来看，不难看出：\n$\\alpha\\Rightarrow^n\\beta$表示$\\beta$在$G$中经过$n$步推导出$\\beta$，也就是说存在$\\alpha_1,\\alpha_2,\\cdots,\\alpha_{n-1}\\in(V\\cup T)^{ * }$使得$\\alpha\\Rightarrow\\alpha_1\\Rightarrow\\alpha_2\\Rightarrow\\cdots\\Rightarrow\\alpha_{n-1}\\Rightarrow\\beta$（这里是一种简写的表示，也可以称这样一个替换序列为 派生(derivation) ），对于归约而言也有相应的含义。当$n=0$时也就是说有$\\alpha=\\beta$。\n$\\alpha\\Rightarrow^ +\\beta$表示$\\beta$在$G$中经过至少$1$步推导出$\\beta$，对于归约而言也有相应的含义。\n$\\alpha\\Rightarrow^ { * }\\beta$表示$\\beta$在$G$中经过若干步推导出$\\beta$，对于归约而言也有相应的含义。\n现在给出一个文法的案例以供理解：\n设有文法$G=(${$S,A,B$}$,${$0,1$},{$S\\rightarrow A|AB,A\\rightarrow 0|0A,B\\rightarrow 1|11,S$}$)$，那么$S$在$G$中可以推导出$00011$：\n$S\\Rightarrow AB$，使用产生式$S\\rightarrow AB$ $AB\\Rightarrow 0AB$，使用产生式$A\\rightarrow 0A$ $0AB\\Rightarrow 00AB$，使用产生式$A\\rightarrow 0A$ $00AB\\Rightarrow 000B$，使用产生式$A\\rightarrow 0$ $000B\\Rightarrow 00011$，使用产生式$B\\rightarrow 11$ 上文使用文法得到了一个句子，这说明文法可以用于产生语言，现在给出定义：\n设有文法$G=(V,T,P,S)$，则称$L(G)=${$w|w\\in T^ { * },S\\Rightarrow^{ * }w$}为$G$产生的 语言 ，$\\forall w\\in L(G),w$称为$G$产生的一个 句子（sentence） 。而对于$\\forall\\alpha\\in(V\\cup T)^{ * }$，如果有$S\\Rightarrow^ { * }$，那么称$\\alpha$是$G$产生的一个 句型（sentential form） 。不难发现句子不能含有语法变量，而句型可以含有语法变量。\n关于文法也可以由此引入 等价（equivalence） 的概念，也就是说对于文法$G_1,G_2$，如果有$L(G_1)=L(G_2)$，那么称它们等价。\n上面的这个案例文法所产生的语言$L(G)=L(0^ { * }(\\epsilon+1+11))$（这里使用了正则表达式），也就是说$L(G)$是一个$RL$，但不能说文法产生的语言都是$RL$，很容易可以举出文法$G=(${$A$},{$0,1$},{$A\\rightarrow 01|0A1$}$,A)$，它所产生的语言是{$0^n1^n|n\\geq 1$}，根据正则语言的泵引理，可以发现它不是一个$RL$，为了更好地分析形式文法，可以引入文法的 乔姆斯基体系（Chomsky hierarchy） 。\n乔姆斯基体系 设有文法$G=(V,T,P,S)$，那么有：\n$G$被称为 0型文法（type 0 grammar） ，或者 短语结构文法（phrase structure grammar,PSG） 。对应地，$L(G)$也被称为 0型语言 或者 短语结构语言（PSL） 、 递归可枚举集（recursively enumerable set,r.e.） 。 如果对于$\\forall\\alpha\\rightarrow\\beta\\in P$，均有$|\\beta|\\geq|\\alpha|$成立，则称$G$为 1型文法（type 1 grammar） ，或者 上下文有关文法（context sensitive grammar,CSG） 。对应地，$L(G)$也被称为 1型语言（type 1 language） 或者 上下文有关语言（context sensitive language,CSL） 。 如果对于$\\forall\\alpha\\rightarrow\\beta\\in P$，均有$|\\beta|\\geq|\\alpha|$，并且有$\\alpha\\in V$成立，则称$G$为 2型文法（type 2 grammar） ，或者 上下文无关文法（context free grammar,CFG） 。对应地，$L(G)$也被称为 2型语言（type 2 language） 或者 上下文无关语言（context free language,CFL） 。 如果对于$\\forall\\alpha\\rightarrow\\beta\\in P$，$\\alpha\\rightarrow\\beta$均有形式$A\\rightarrow w,A\\rightarrow wB$，这里的$A\\rightarrow wB$也可以都换成$A\\rightarrow Bw$的形式（符合前者的被称为 右线性文法（right liner grammar） ，符合后者的被称为 左线性文法（left liner grammar） ，两者混用可以生成3型语言以外的语言），其中$A,B\\in V,w\\in T^ { + }$，则称$G$为 3型文法（type 3 grammar） ，或者 正则文法（regular grammar,RG） 、 正规文法 。对应地，$L(G)$也被称为 3型语言（type 3 language） ，而它产生的语言正好是 正则语言（regular language,RL） ，或者称为 正规语言 。 但是先前已经定义RL是DFA识别的语言，为了解释这个矛盾，现在对这个事实进行证明：\nRL能被RG产生：\n设有$DFA$：$M=(Q,\\Sigma,\\delta,q_0,F)$，可以构造$G$使得它是一个RG且有$L(G)=L(M)-${$\\epsilon$}，考虑$G=(Q,\\Sigma,${$q\\rightarrow ap| \\delta(q,a)=p$}$\\cup${$q\\rightarrow a| \\delta(q,a)=p\\in F$}$)$。\nRG产生的语言是RL：\n对于一个RG：$G=(V,T,P,S)$，假设$Z\\notin V$，它表示$FA$的终止状态，可以作一个$FA$：$M=(V\\cup${$Z$}$,T,\\delta,S,${$Z$}$)$，其中$\\delta的$定义为：\n对于$\\forall(A,a)\\in V\\times T$，如果$A\\rightarrow a\\in P$那么有$\\delta(A,a)=${$B|A\\rightarrow aB\\in P$}$\\cup${$Z$}；如果$A\\rightarrow a\\notin P$那么有$\\delta(A,a)=${$B|A\\rightarrow aB\\in P$}。\n综上所述，RG产生的语言就是RL。\n显然，按照PSG、CSG、CFG、RG的顺序一直往后，文法的限制条件也就越多，后面的文法类型中的文法一定也属于前面的文法类型，可以用韦恩图表示（部分语言类之间的关系在后文中将会进一步探究）：\n前文中给出了两个文法，由定义可以知道它们分别为RG和CFG，现在给出其他两种类型的文法的例子：\n$G=(${$S,A,B,C$},{$a,b,c$},{$S\\rightarrow aBC|aSBC,CB\\rightarrow BC,aB\\rightarrow ab,bB\\rightarrow bb,bC\\rightarrow bc,cC\\rightarrow cc$}$,S)$，这是一个CSG，可以证明$L(G)=${$a^nb^nc^n|n\\geq 1$}。\n$G=(${$S$},{$0$},{$S\\rightarrow ABC,ABC\\rightarrow 0$}$,S)$，这是一个PSG，$L(G)=${$0$}，显而易见的可以构造出一个RG：$G\u0026rsquo;=(${$S$},{$0$},{$S\\rightarrow 0$}$,S)$使得$L(G\u0026rsquo;)=${$0$}，也就是说不同类型的文法之间也可以等价。\n按照上述的对四种文法的定义，不难发现RG、CFG和CSG生成的语言都不含有$\\epsilon$。为了方便研究，称形如$A\\rightarrow\\epsilon$的产生式为 空产生式 ，或者称为$\\epsilon$产生式，在RG、CFG和CSG的限制中允许出现空产生式，这样就允许它们产生的语言中也含有$\\epsilon$。\n在引入了空产生式的概念后，不难发现如果$L$是RL、CFL或者CSL，那么$L\\cup${$\\epsilon$}依旧是RL、CFL、CSL。同时如果$L$是RL、CFL或者CSL，那么$L-${$\\epsilon$}依旧是RL、CFL、CSL。\n上下文无关文法 上下文无关文法的相关概念 上下文无关文法在程序设计语言的规范化及编译中有重要应用。程序设计语言的文法犹如外语语法参考书，设计人员在编写程序设计语言的编译器和解释器时，常需要先获取该语言的文法。大多数编译器和解释器都包含一个 语法分析器（parser） ，它在生成编译代码或解释程序执行前，提取出程序的语义。上下文无关语言使得构造语法分析器的工作变得容易，某些工具甚至能根据文法自动地生成语法分析器。\nCFL之所以被称作上下文无关，是指在文法派生的每一步$\\alpha A\\beta\\Rightarrow\\alpha\\gamma\\beta$中$\\gamma$仅根据$A$的产生式派生，而无需依赖$A$的上下文$\\alpha$和$\\beta$。\n为了更好地理解CFL，首先给出一个CFG的例子：\n有文法$G=(${$A,B$},{$0,1,$#},{$A\\rightarrow 0A1|B,B\\rightarrow$#}$)$，它生成字符串$0000$#$111$的派生过程如下：\n$A\\Rightarrow 0A1\\Rightarrow 00A11\\Rightarrow 000A111\\Rightarrow 000B111\\Rightarrow 000$#$111$，为了生动形象地描述派生过程，可以使用 语法分析树（parse tree） ，这样便可以从树中看出整个派生过程和最终产生的字符串：\n现在给出语法分析树的形式化定义，对于一个CFG：$G=(V,T,P,S)$而言，它的语法分析树是这样的一棵树：它的每一个内节点的标记是$V$中的变元符号；每一个叶节点的标记是$V\\cup T\\cup${$\\epsilon$}中的符号；如果内结点的标记是$A$，它的子节点从左至右分别为$X_1,X_2,\\cdots,X_n$，那么$A\\rightarrow X_1X_2\\cdots X_n$肯定是$P$的一个产生式，如果某个$X_i$是$\\epsilon$，那么$X_i$一定是$A$唯一的子节点，且$A\\rightarrow\\epsilon$是一个产生式。\n将语法分析树的全部叶节点从左到右连接起来，称为该树的 产物（yield） 或结果。如果树根节点是初始符号$S$，叶节点是终结符，显然该树的产物属于$L(G)$。\n语法分析树种标记为$A$的内节点及其全部子孙节点构成的子树，称为$A$子树。\n利用数学归纳法可以证明这样一个定理：设有CFG：$G=(V,T,P,S)$且$A\\in V$，那么文法$G$中有$A\\Rightarrow^{ * }$当且仅当在文法$G$中存在以$A$为根节点、产物为$\\alpha$的语法分析树。\n有时候在一个文法中能够用多种不同的方式产生出同一个字符串，在此提供一个案例：\n设有文法$G_{exp}=(${$E,I$},{$a,b,+,* ,(,)$},{$E\\rightarrow I|E+E|E *E|(E),I\\rightarrow a$}$,E)$，这个文法可以用于生成一个含有加法和乘法的代数表达式。但是如果使用这个文法生成字符串$a+a *a$可以发现有多种派生：\n右边的派生很明显不符合数学运算的优先级要求，通过语法分析树可以很明显地看出在派生的过程中产生了歧义，为了形式化歧义的概念，首先给出最左派生的概念：\n对于文法$G$中的一个字符串$w$的派生，如果在每一步都是替换最左边剩下的变元，则称这个派生是 最左派生（leftmost derivation） ，类似的也有最右派生。分别记为$\\Rightarrow_{lm}^{ * },\\Rightarrow_{rm}^{ * }$，显然任何派生都有等价的最左派生和最右派生，也就是说$A\\Rightarrow^{ * }w$当且仅当$A\\Rightarrow_{lm}^{ * }w$当且仅当$A\\Rightarrow_{rm}^{ * }w$。\n结合先前介绍的语法分析树，实际上可以证明如果$\\alpha$是某个CFG的句型，那么$\\alpha$的派生树与最右派生和最左派生是一一对应的，但是这棵语法分析树可以对应多个不同的派生。\n现在给出歧义的形式概念：\n如果字符串$w$在上下文无关文法$G$中有两个或两个以上不同的最左派生，则称$G$ 歧义地（ambiguously） 产生字符串$w$，如果文法$G$歧义地产生某个字符串，则称$G$是 歧义的（ambiguous） 。\n上文作出的文法$G_{exp}$有两个不同的语法分析树，所以它是一个歧义的文法，但是实际上可以作出等价的非歧义文法，现在给出等价的非歧义文法：\n$G_{exp\u0026rsquo;}=(${$E,F,I,T$},{$a,b,+,* ,(,)$},{$E\\rightarrow E+T|T,T\\rightarrow T* F|F,F\\rightarrow (E)|I,I\\rightarrow a$}$,E)$\n但是并非是所有歧义文法都能找到等价的非歧义文法，这样的文法被称为是固有歧义的（inherently ambiguous） 。例如{$a^ib^jc^k|i=j或j=k且i,j,k\\geq 0$}便是固有歧义的，在后文会对这一定理进行证明。\nCFG的化简 在构造CFG的过程中，有时由于某种原因，文法中出现的符号以及使用的产生式并不一定是恰当的，比如下列两个文法实际上是等价的：\n$G_1=(${$S,A,B,C,D,E$},{$0,1,2,$},{$S\\rightarrow 0|0A|E,A\\rightarrow\\epsilon|0A|1A|B,B\\rightarrow $$ C,C\\rightarrow 0|1|0C|1C,D\\rightarrow 1|1D|2D,E\\rightarrow 0E2|E02$}$,S)$\n$G_2=(${$S,A,C$},{$0,1,$},{$S\\rightarrow 0|0A,A\\rightarrow 0|1|0A|1A|$$ C,C\\rightarrow 0|1|0C|1C$}$,S)$\n为了便于便于分析和解决问题，以不改变语言为前提，化简文法和限制文法的格式，现在介绍化简上下文无关语言的三个组成部分：\n消除无用符号（useless symbols）：对文法定义的语言没有贡献的符号（不出现在任何由开始符号在任何由开始符号推导出一个终结符串的过程中的变元或终结符） 消除$\\epsilon$产生式：也就是消除$A\\rightarrow\\epsilon$，这样得到的语言将会是$L-${$\\epsilon$} 消除单元产生式（unit productions）：$A\\rightarrow B$，其中$A$和$B$都是变量。 对于CFG：$G=(V,T,P,S),X\\in V\\cup T$：\n如果$S\\Rightarrow^{ * }\\alpha X\\beta$，则称$X$是可达的（reachable）。\n如果$X\\Rightarrow^{ * }w,w\\in T^{ * }$，称$X$是产生的（generating）。\n如果$X$同时是产生的和可达的，也就是说$S\\Rightarrow^{ * }\\alpha X\\beta\\Rightarrow^{ * }w,w\\in T^{ * }$，则称$X$是有用的，否则称$X$为无用符号。\n存在一种方法得到产生的符号的集合和可达的符号的集合：\n产生的：每一个$T$中的符号都是产生的；如果$A\\rightarrow\\alpha\\in P$且$\\alpha$中的符号都是产生的，那么$A$也是产生的。 可达的：$S$是可达的；如果$A\\rightarrow\\alpha\\in P$且$A$是可达的，则$\\alpha$中的符号都是可达的。 结论是显然的，在此不作证明。在得到了这两个集合后删掉全部含有“非产生的”和“非可达的”符号的产生式即可。\n可以证明，每一个非空的CFL都可以用一个不带无用符号的CFG定义。\n注意：在消除无用符号的过程中要先寻找并消除全部非“产生的”符号，再寻找并消除全部非“可达的”符号，否则可能会出现消除不完整的情况，下面给出一个例子：\n设有文法$G=(${$S,A,B$},{$a,b$},{$S\\rightarrow AB|a,A\\rightarrow b$}$,S)$\n先消除非可达的：可达的符号集为{$S,A,B,a,b$}，故无消除符号。 再消除非产生的：产生的符号集为{$a,b,S,A$}，消除$B$得到$G\u0026rsquo;=(${$S,A,B$},{$a,b$},{$S\\rightarrow a,A\\rightarrow b$}$,S)$。 显然依旧存在无用符号。\n如果按照相反的顺序可以发现不会存在无用符号：\n先消除非产生的：产生的符号集为${a,b,S,A}$，消除$B$得到$P={S\\rightarrow a,A\\rightarrow b}$。 再消除非可达的：可达的符号集为${S,a}$，消除${b,A}$得到$P={S\\rightarrow a}$。 实际上可以证明先消除全部非“产生的”符号，再寻找并消除全部非“可达的”符号可以得到不存在无用符号的文法，在此不作证明。\n如果变元$A$满足$A\\Rightarrow^{ * }\\epsilon$，则称$A$是可空的。现在给出一个确定可空变量的方法：\n如果$A\\rightarrow\\epsilon\\in P$，那么$A$是可空的；如果$B\\rightarrow\\alpha\\in P$且$\\alpha$中的每一个符号都是可空的，则$B$是可空的。\n在确定了可空变量后，给出一种替代方案：\n将含有可空变量的一条产生式$A\\rightarrow X_1X_2\\cdots X_n$用一组产生式$A\\rightarrow Y_1Y_2\\cdots Y_n$代替，其中：\n若$X_i$不是可空的，那么$Y_i$为$X_i$。 若$X_i$是可空的，$Y_i$为$X_i$或者$\\epsilon$（也就是说对于每一个可空变量，它可以出现或不出现在替换后的产生式中）。 但是不能出现$Y_i$全为$\\epsilon$的情况。 满足这样的替代方案的情况下，再消除文法中的$\\epsilon$产生式，便可以得到语言$L-${$\\epsilon$}，下面给出一个例子作为说明：\n设有文法$G=(${$S,A,B$},{$a,b$},{$S\\rightarrow AB,A\\rightarrow AaA|\\epsilon,B\\rightarrow BbB|\\epsilon$}$)$。\n首先可以确定可空的变量是{$S,A,B$}。\n替换全部带有可空变量的表达式：$S\\rightarrow AB$替换成$S\\rightarrow AB|A|B$，$A\\rightarrow AaA|\\epsilon$替换成$A\\rightarrow AaA|Aa|aA|a$，$B\\rightarrow BbB|\\epsilon$替换成$B\\rightarrow BbB|Bb|bB|b$。\n如果两个变量满足$A\\Rightarrow^{ * }B$，则称$[A,B]$为单元对，现在给出一种确定单元对的方法：\n如果$A\\rightarrow B\\in P$，则$[A,B]$是单元对。 如果$[A,B],[B,C]$都是单元对，那么$[A,C]$也是单元对。 消除单元产生式的过程要求删除全部形如$A\\rightarrow B$的单元产生式，并且对每一个单元对$[A,B]$，将$B$的产生式的右部复制给$A$作为产生式。\n下面给出一个例子作为说明：\n设有文法$G=(${$S,A,B$},{$0,1$},{$S\\rightarrow A|B|0S1,A\\rightarrow 0A|0.B\\rightarrow 1B|1$}$,S)$\n确定单元产生式：$S\\rightarrow A,S\\rightarrow B$，非单元产生式$S\\rightarrow 0S1.A\\rightarrow 0A|0,B\\rightarrow 1B|1$。\n将单元产生式代入非单元产生式：$A\\rightarrow 0A|0$代入$S\\rightarrow A$得到$S\\rightarrow 0A|0$，$B\\rightarrow 1B|1$代入$S\\rightarrow B$得到$S\\rightarrow 1B|1$。\n可以证明化简CFG有一个可靠的顺序是：\n消除$\\epsilon$产生式。 消除单元产生式。 消除非产生的无用符号。 消除非可达的无用符号。 也就是说每一个不带$\\epsilon$的CFL都可以由一个不带无用符号、$\\epsilon$产生式和单元产生式的文法来定义，在此不对这一定理进行证明。\n乔姆斯基范式和格雷巴赫范式 不难发现，RG是相当规范的，CFG的形式相较于RG而言并没有这样规范，在完成了对CFG的化简后，还需要进一步找到与之等价的规范文法，这里将要介绍两种规范的文法。\n乔姆斯基范式（Chomsky normal form,CNF） ：一个CFG：$G=(V,T,P,S)$的每一个产生式的形式都为$A\\rightarrow BC$或$A\\rightarrow a$，其中$A,B,C\\in V,a\\in T$。不难发现利用CNF派生长度为$m$的字符串，刚好需要$m+(m-1)=2m-1$步。\n现在给出将一个不带$\\epsilon$的CFG转换成CNF的方法：\n先前已经介绍了如何得到不带无用符号、$\\epsilon$产生式和单元产生式的CFG的方法，这里已经事先进行了化简。\n考虑文法中每一个形式为$A\\rightarrow X_1X_2\\cdots X_m,m\\geq 2$的产生式，若$X_i$为终结符$a$，则引进新变量$C_a$替换$X_i$并增加新产生式$C_a\\rightarrow a$。\n现在需要进行替换的产生式的形式将会变为$A\\rightarrow B_1B_2\\cdots B_m,m\\geq 3$和$B_i\\rightarrow a$。\n对于$A\\rightarrow B_1B_2\\cdots B_m,m\\geq 3$，可以引入新变量$D_1,D_2,\\cdots,D_{m-2}$将其替换成一组产生式$A\\rightarrow B_1D_1,D_1\\rightarrow B_2D_2,\\cdots,D_{m-2}\\rightarrow B_{m-1}B_m$，这样就把CFG变成了CNF的形式。\n在这里给出一个例子以供理解：\n设有CFG：$G=(${$S,A,B$},{$a,b$}$,P,S)$，其中$P=${$S\\rightarrow bA|aB,A\\rightarrow bAA|aS|a,B\\rightarrow aBB|bS|b$}，可以得到与其等价的CNF：$G\u0026rsquo;=(${$S,A,B,D_a,C_b,D_1,D_2$},{$a,b$}$,P\u0026rsquo;,S)$，其中$P\u0026rsquo;=${$S\\rightarrow C_bA|C_aB,A\\rightarrow C_bD_1|C_aS|a,B\\rightarrow C_aD_2|C_bS|b,D_1\\rightarrow AA,D_2\\rightarrow BB,C_a\\rightarrow a,C_b\\rightarrow b$}。\n格雷巴赫范式（Greibach normal form,GNF） ：一个CFG：$G=(V,T,P,S)$的每一个产生式的形式都为$A\\rightarrow a\\alpha$，其中$A\\in V,a\\in T,\\alpha\\in V^{ * }$。不难发现GNF每个产生式都会引入一个终结符，利用GNF派生长度为$m$的字符串，刚好需要$m$步。\n先前已经证明了不带$\\epsilon$的CFG可以转换成CNF，作出与CNF等价的GNF是非常简单的，在此不作说明。也就是说由一个不带$\\epsilon$的CFG可以转换成GNF。\n下推自动机 下推自动机的引入 先前已经介绍了FA，它识别的语言是RL，有着重要的作用，但是在现实中存在着不少只使用FA无法解决的问题，考虑这样一个问题：\n括号匹配问题：要求设计一台自动机识别字母表为$(,),[,],{,}的字符串，当它是合法的括号匹配的时候就接受这个字符串，例如[[]]就是一个合法的括号匹配，而[(])是一个非法的括号匹配。\n但是使用FA是没有办法解决这个问题的，设这个语言是$L_1$，考虑语言$L_2={(^{ * })^{ * }}$，可知$L_1\\cap L_2=${$(^n)^n|n\\geq 0$}，利用正则语言的泵引理可以知道它不是一个RL，所以无法设计一个FA满足问题需求。\n在现实中很容易使用C语言编写程序解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;string.h\u0026gt; #define MaxSize 100 //定义栈中元素最大个数 typedef struct{ char data[MaxSize]; int top; }SqStack; //初始化栈 void InitStack(SqStack *S){ S-\u0026gt;top = -1; } //判断栈是否为空 bool IsEmpty(SqStack S){ if(S.top == -1){ return true; } return false; } //新元素入栈 void Push(SqStack *S,char x){ if(S-\u0026gt;top == MaxSize-1){ printf(\u0026#34;栈已满\u0026#34;); //栈已满 return; } S-\u0026gt;top += 1; S-\u0026gt;data[S-\u0026gt;top] = x; } //栈顶元素出栈，用x返回 void Pop(SqStack *S,char *x){ if(S-\u0026gt;top == -1){ printf(\u0026#34;栈已满\u0026#34;); return; } *x = S-\u0026gt;data[S-\u0026gt;top]; S-\u0026gt;top -= 1; } //匹配算法 bool bracketCheck(char str[],int length){ SqStack S; InitStack(\u0026amp;S); //初始化栈 for(int i=0;i\u0026lt;length;i++){ if(str[i]==\u0026#39;(\u0026#39;||str[i]==\u0026#39;{\u0026#39;||str[i]==\u0026#39;[\u0026#39;){ Push(\u0026amp;S,str[i]); //扫描到左括号就入栈 }else{ if(IsEmpty(S)){ //扫描到右括号，当前栈为空，即右括号单身情况 return false; //匹配失败 } char topElem; //用来保存弹出栈的栈顶元素 Pop(\u0026amp;S,\u0026amp;topElem); //栈顶元素出栈 if(str[i]==\u0026#39;)\u0026#39;\u0026amp;\u0026amp;topElem!=\u0026#39;(\u0026#39;){ return false; } if(str[i]==\u0026#39;}\u0026#39;\u0026amp;\u0026amp;topElem!=\u0026#39;{\u0026#39;){ return false; } if(str[i]==\u0026#39;]\u0026#39;\u0026amp;\u0026amp;topElem!=\u0026#39;[\u0026#39;){ return false; } } } return IsEmpty(S); } int main(){ char s[MaxSize]; printf(\u0026#34;请输入需要判断的括号：\\n\u0026#34;); scanf(\u0026#34;%s\u0026#34;,s); int len = strlen(s); printf(\u0026#34;当前输入的括号个数为：%d\\n\u0026#34;,len); printf(\u0026#34;--------现在开始进行判断--------\\n\u0026#34;); if(bracketCheck(s,len)){ printf(\u0026#34;匹配成功！\u0026#34;); }else{ printf(\u0026#34;匹配失败！\u0026#34;); } return 0; } 在上述的程序中，使用了 栈(stack) 这一结构，如果给FA添加上一个栈会发生什么呢？这就引出了 下推自动机（pushdown automata,PDA） 这一计算模型，相较于FA，它还有一个栈作为额外设备，栈在控制器的有限存储量之外提供了附加的存储，使得下推自动机能够识别某些非正则语言，实际上下推自动机在能力上和CFG是等价的。\n简单地说，下推自动机可以看成是$\\epsilon-NFA$和栈的结合，它的下一步动作由三个要素决定：\n当前$\\epsilon-NFA$的状态 当前的输入符号（或者是$\\epsilon$） 当前的栈顶符号 $\\epsilon-NFA$有着有限状态、非确定性、空转移的性质；栈是一种先进后出（First In Last Out,FILO）的结构，在这里只使用栈顶且栈的长度是无限的，栈有两种操作：弹栈（Pop）也就是仅弹出栈顶的一个符号，压栈（Push）也就是压入一串符号。\n运转过程：\n控制器从输入带读入一个符号$a$，控制栈弹出一个栈顶符号$Z$。\n根据符号$a,Z$和当前所处的状态进行状态的转移并对栈压入$0$个符号（也就相当于是Pop）或者压入一个符号串（也就相当于是Push）。\n下推自动机的形式化定义 现在给出PDA的形式化定义：\n下推自动机$P$是一个七元组$(Q,\\Sigma,\\delta,q_0,Z_0,F)$，其中：\n$Q$是有穷状态集，相应的有状态的概念。 $\\Sigma$是有穷输入符号集（input alphabet），要求$M$的输入字符串都是$\\Sigma$上的字符串，常使用小写字母表示输入的字符串。 $\\Gamma$是有穷栈符号集（stack alphabet），里面的符号被称为栈符号（stack symbols），常使用大写字母表示栈中的符号，用希腊字母表示栈字符串。 $\\delta:Q\\times(\\Sigma\\cup{\\epsilon})\\times\\Gamma\\rightarrow 2^{Q\\times\\Gamma^{ * }}$是状态转移函数。可知对于$(q,a,X)\\in Q\\times(\\Sigma\\cup\\epsilon)\\times\\Gamma,\\delta(q,a,X)={(p_1,\\gamma_1),(p_2,\\gamma_2),\\cdots,(p_m,\\gamma_m)}$，根据当前的$a$和$X$，可以将当前状态由$q$转移到$p_1$，再用$\\gamma_1$代替栈顶的$X$。如果$\\gamma_1=\\epsilon$则弹出$X$，如果$\\gamma_1=\\epsilon$则弹出$X$，如果$\\gamma_1=X$那么栈顶符号依旧为$X$，如果$\\gamma_1=Z_1Z_2\\cdots Z_k$那么弹出$X$再依次压入$Z_k,Z_{k-1},\\cdots,Z_1$。 $_0\\in Q$是初始状态。 $Z_0\\in\\Gamma$是初始栈底符号（start stack symbol），是中国自动机启动的时候栈内唯一的一个符号，用来标志栈底。 $F\\subseteq Q$是接受状态集。 也可以使用状态转移图来表示PDA：\n由正则语言的泵引理可知{$0^n1^n|n\\geq 1$}不能被FA识别，但是可以构造一个PDA识别它：\n为了方便说明，现在引入一些概念：\n设有PDA：$M=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$，$\\forall(q,w,\\gamma)\\in Q\\times\\Sigma^{ * }\\times\\Gamma^{ * }$称为是$M$的一个 即时描述（instantaneous descriptin,ID） 。它表示：$M$处于状态$q$；$w$是剩余的未处理的输入字符串，而且此时$M$正在注视$w$的首字符；栈中的符号串为$\\gamma$，$\\gamma$的最左符号为栈顶符号，越靠右越在栈的较下面。\n在PDA的一个动作下，会发生从ID$\\ I$到ID$\\ J$的变化，称之为ID的转移。\n具体的，如果$(p,\\beta)\\in\\delta(q,a,Z)$，由$(q,aw,Z\\alpha)$到$(p,w,\\beta\\alpha)$的变化称为ID的转移$\\vdash_P$，在不引发混淆的情况下可以记作$\\vdash$，这样ID的转移就可以写为$(q,aw,Z\\alpha)\\vdash(p,w,\\beta\\alpha)$，这是一个二元关系，相应地也可以作出它的克林闭包，为了方便，使用$I\\vdash^{ * }J$表示$I(\\vdash)^{ * }J$\n显然在PDA的ID的转移过程中可以会存在多条转移路径，但是最终只有一条正确的路径可以进入接受状态。\nPDA接受的语言 下推自动机接受一个语言有着不同的方式，现在对此进行介绍：\n设有PDA：$P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$，要求$F\\neq\\varnothing$，称通过终态方式接受的语言$L(P)=${$w|(q_0,w,Z_0)\\vdash^{ * }(p,\\epsilon,\\gamma),p\\in F$}，即能够使PDA到达终态的符号串的集合。\n设有PDA：$P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$，要求$F=\\varnothing$，称通过空栈方式接受的语言$N(P)=${$w|(q_0,w,Z_0)\\vdash^{ * }(p,\\epsilon,\\epsilon)$}，即能够使PDA的栈变空的符号串的集合。\n现在证明这两种接受方式的下推自动机是可以相互转换的：\n先证明对于任意PDA$\\ M_1$，存在PDA$\\ M_2$使得$N(M_2)=L(M_1)$：\n设有PDA$\\ M_1=(Q,\\Sigma,\\Gamma,\\delta_1,q_{01},Z_{01},F)$，考虑构造PDA$\\ M_2=(Q\\cup${$q_{02},q_e$}$,\\Sigma,\\Gamma\\cup${$Z_{02}$}$,\\delta,q_{02},Z_{02},F)$，其中要求$Q\\cap{q_{02},q_e}=\\Gamma\\cap${$Z_{02}$}$=\\varnothing$，而具体地，$\\delta_2$的定义如下：\n在$M_2$启动后立马进入$M_1$的初始ID，也就是说$\\delta_2(q_{02},\\epsilon,Z_{02})={q_{01},Z_{01}Z_{02}}$。 让$M_2$完全模拟$M_1$的非空移动：$\\forall (q,a,Z)\\in Q\\times\\Sigma\\times\\Gamma$有$\\delta_2(q,a,Z)=\\delta_1(q,a,Z)$。 当$M_2$在非终止状态下完全模拟$M_1$的空移动：$\\forall (q,Z)\\in(Q-F)\\times\\Gamma$有$\\delta_2(q,\\epsilon,Z)=\\delta_1(q,\\epsilon,Z)$。 在$M_1$的终止状态下，$M_2$除了模拟$M_1$的空移动外，还需要模拟$M_1$的“接受动作”，由于在此动作后栈可能不是空的，进入清栈状态：$\\forall(q,Z)\\in F\\times\\Gamma,\\delta_2(q,\\epsilon,Z)=\\delta_1(q,\\epsilon,Z)\\cup${$(q_e,\\epsilon)$}。 $M_1$的栈已空，并且已经进入了终止状态，所以$M_2$进入清栈状态$q_e$并将栈清空：$\\forall q\\in F,\\delta_2(q,\\epsilon,Z_{02})\\rightarrow${$(q_e,\\epsilon)$}。 $M_2$进行清栈工作：$\\forall Z\\in\\Gamma\\cup${$Z_{02}$}$,\\delta_2(q_e,\\epsilon)=${$(q_e,\\epsilon)$}。 再证明对于任意PDA$\\ M_1$，存在PDA$\\ M_2$使得$L(M_2)=N(M_1)$：\n设有PDA$\\ M_1=(Q,\\Sigma,\\Gamma,\\delta_1,q_{01},Z_{01},F)$，考虑构造PDA$\\ M_2=(Q\\cup${$q_{02},q_f$}$,\\Sigma,\\Gamma\\cup${$Z_{02}$}$,\\delta,q_{02},Z_{02},${$q_{02}$}$)$，其中要求$Q\\cap${$q_{02},q_e$}$=\\Gamma\\cap${$Z_{02}$}$=\\varnothing$，而具体地，$\\delta_2$的定义如下：\n在$M_2$启动后立马进入$M_1$的初始ID，也就是说$\\delta_2(q_{02},\\epsilon,Z_{02})={q_{01},Z_{01}Z_{02}}$。 让$M_2$完全模拟$M_1$的移动：$\\forall(q,a,Z)\\in Q\\times(\\Sigma\\cup${$\\epsilon$}$)\\times\\Gamma$有$\\delta_2(q,a,Z)=\\delta_1(q,a,Z)$。 当$M_1$的栈已空时，$M_2$的栈底符号成为栈中唯一的符号。因此要让$M_2$进入终止状态：$\\delta_2(q,\\epsilon,Z_{02})=${$(q_f,\\epsilon)$}。 PDA与CFG的等价性 实际上PDA和CFG是等价的，现在对这一定理作出证明。\n对于任何CFL$\\ L$，一定存在PDA$\\ P$使$L=N(P)$。\n证明：对于一个CFG$\\ G=(V,T,P\u0026rsquo;,S)$，可以构造这样的PDA$\\ P_N=(${$q$}$,T,V\\cup T,\\delta,q,S,\\varnothing)$，其中对于$\\forall A\\in V,\\delta(q,\\epsilon,A)=${$(q,\\beta)|A\\rightarrow\\beta\\in P\u0026rsquo;$}，对于$\\forall a\\in T,\\delta(q,a,a)=${$(q,\\epsilon)$}。\n可以证明$S\\Rightarrow^{ * }\\Leftrightarrow(q,w,S)\\vdash^{ * }(q,\\epsilon,\\epsilon)$，也就是说$L(G)=N(P)$，在此不作详细证明。\n对于任何PDA$\\ P$，一定存在CFL$ L$使$L=L(P)$。\n证明：了方便讨论，通过添加中间状态很容易对$P$作出修改使得$P$有唯一的接受状态$q_{accept}$，在$P$接受的时候空栈，每一个转移把一个符号压入栈或者把一个符号弹出栈，但是不能同时做出这两个动作。\n为了找到生成$L$的文法$G$，先考虑设置这样的变量$A_{pq}$，它能产生所有能够让$P$从ID$(p,aw,Z_0)$转移到ID$(q,w,Z_0)$的字符串$a$，这样的字符串自然在栈中还有其他内容的时候也能让$P$实现从状态$p$到状态$q$的转移。\n为了知道$A_{pq}$的产生式，首先要考虑它所产生的字符串$x$输入$P$后它所执行的动作。\n可以知道$P$对$x$的第一个动作一定是压栈、最后一个动作一定是弹栈，那么$P$输入$x$后有两种情况：仅在运算开始和结束的时候$P$存在栈空的情况，在计算的中间过程中存在栈空的情况，很容易想到两个产生式用来模拟这两种情况：$A_{pq}\\rightarrow aA_{rs}b$，其中$a,b$就是在开头和结束时读到的输入符号，$r$是紧跟$p$的状态、$s$是$q$前面的那个状态；$A_{pq}\\rightarrow A_{pr}A_{rs}$，其中$r$就是中间过程中栈空的状态。下面给出具体的构造方式：\n设$P=(Q,\\Sigma,\\Gamma,\\delta,q_0,${$q_{accept}$}$)$，那么可以构造CFG：$G=(${$A_{pq}|p,q\\in Q$}$,\\Sigma,P\u0026rsquo;,A_{q_0,q_{accept}})$,其中$P\u0026rsquo;$满足以下要求：\n对于$\\forall p,q,r,s\\in Q,\\ u\\in\\Gamma,\\ a,b\\in\\Sigma\\cup${$\\epsilon$}，如果$(r,s)\\in\\delta(p,a\\epsilon),(q,\\epsilon)\\in\\delta(s,b,u)$，那么$A_{pq}\\rightarrow aA_{rs}b\\in P\u0026rsquo;$。 对于$\\forall p,q,r\\in Q$，有$A_{pq}\\rightarrow A_{pr}A_{rq}\\in P\u0026rsquo;$。 对于$\\forall p\\in Q$，有$A_{pp}\\rightarrow\\epsilon$。 可以证明$A_{pq}$产生$x$当且仅当$x$能够让$P$从ID$(p,xw,Z_0)$转移到ID$(q,w,Z_0)$，也就是说对于任何PDA$\\ P$，一定存在CFL$ L$使$L=L(P)$，在此不作详细的证明。\n综上所述：PDA和CFG是等价的。\nCFL的性质 CFL的泵引理 按照先前对乔姆斯基文法体系的介绍可以知道，CFL是CSL的子类，但是不能证明CFL是CSL的真子类。为此需要找到一个语言并且判定它属于CSL而不属于CFL。为了确定一个语言是否不属于某个语言类，很容易想到之前介绍的RL的泵引理，而实际上也有CFL的泵引理，类似于RL的泵引理，它也可以对字符串进行“抽取”而保证字符串在语言当中：\n对于任意CFL：$L$，存在仅仅依赖于$L$的正整数$N$（一样也称其为是泵长度），对于$\\forall z\\in L$，只要$|z|\\geq N$时就可以将其分为五部分$z=uvwxy$，满足：\n$|vwx|\\leq N$ $|vx|\u0026gt;0$ $\\forall i\\geq 0,uv^iwx^iy\\in L$ 证明：设CFG：$G=(V,T,P,S)$是接受$L-${$\\epsilon$}的CNF，那么在文法$G$的派生树中，如果最长路径为$k$，那么派生出的句子的长度最多为$2^{k-1}$，取$N=2^m,m=|V|$，那么若有$z\\in L(G),|z|\\geq G$，则$z$的派生树中最长路径长度至少也是$m+1$，同时在这条路径上至少有$m+2$个节点，这条路径经过了$m+1$个内节点，也就是至少有两个节点标记了相同的变量，不妨设这两个节点是$v_1,v_2$，其中前者比后者更加解决树根，以$v_1$为根的子树为$T_1$，以$v_2$为根的子树为$T_2$，设$T_2$的产物是$w$，由于$T_2$是$T_1$的子树，不妨设$T_1$的产物$Z_1=vwx$，那么有$A\\Rightarrow^{ * }vAx$和$A\\Rightarrow^{ * }w$，也就是说$\\forall i\\geq 0,A\\Rightarrow^{ * }v^iwx^i$，不妨设整棵树的产物$z=uvwxy$，那么有$S\\Rightarrow^{ * } uAy\\Rightarrow^{ * }uv^iwx^iy\\in L$，又知道$T_1$的路径长度不超过$m+1$，也就是说$|vwx|\\leq 2^m=N$，最后$T_2$一定处在$B$的树或者$C$的树中，但是$B$和$C$至少产生了一个终结符（这个文法是CNF），也就有$|vx|\u0026gt;0$。\n一个有趣的事实是，泵引理其实还可以加强，只要取更大的$N=2^{2m}$，也就是说在它的最长路径上有三个节点标记了相同的变量，利用这三个节点对整个派生树进行划分，通过恰当的选取$u,v,w,x,y$就可以让泵引理的第二个条件更改为$v\\neq\\epsilon,x\\neq\\epsilon$。这样就得到了”加强“的泵引理。\n前文给出了一个CSG：$G=(${$S,A,B,C$},{$a,b,c$},{$S\\rightarrow aBC|aSBC,CB\\rightarrow BC,aB\\rightarrow ab,bB\\rightarrow bb,bC\\rightarrow bc,cC\\rightarrow cc$}$,S)$，它生成的语言$L(G)=${$a^nb^nc^n|n\\geq 1$}，利用泵引理可以证明它不是CFL，也就是说CFL类是CSL类的真子类。\n前文中提到了一个固有歧义的CFL：$A=${$a^ib^jc^k|i=j或j=k\\ i,j,k\\geq 0$}，在介绍了CFL的泵引理后，现在可以对这一定理进行证明：\n证明：一个文法$G$生成了这个语言$A$，$p$是仅依赖于$G$的泵长度，令$k=p!=p(p-1)(p-2)\\cdots 1,s=a^kb^kc^k$，现在尝试证明$s$始终有两棵不同的派生树。\n令$s_1=a^kb^pc^p,s_2=a^pb^pc^k$，它们是$A$中的字符串，生成它们的派生树是$T_1,T_2$，先考虑$T_1$：\n考虑将$T_1$中子节点中叶节点只包含$a$的节点去除，现在证明这样得到的子树必然是只有$2p$个叶子节点的树，而不包含任何$a$作为叶节点：因为$p+p\u0026gt;p$，所以这个子树中有一条路径经过了重复的变量$R$，可以用变量$R$将字符串分成$s=uvxyz$，并且有$|vxy|\\leq p$，所以$v$和$y$都只能包含一种字符，否则$uv^2xy^2z\\notin A$。同时$y$不可能包含$a$，因为$R$在一条能够生成$a$或$b$或$c$的路径上。因此$v$必须是$b$的字符串、$y$必须是$c$的字符串，并且它们有相同的长度$l$，考虑字符串$vu^dxy^d,d=\\frac{k}{l}$，那么这样的字符串的派生树便是要求的子树。 $T_2$也可以同样证明类似的事实，这就说明$s$有两棵不同的派生树，那么生成$A$的文法$G$必须是歧义的文法。\nCFL的泵引理只是CFL的必要条件，一个满足CFL的泵引理的语言也可能不是CFL，可以找到这样一个语言$F=${$a^ib^jc^kd^m|i,j,k,m\\geq 0且当i=1时有j=k=m$}，可以构造$L=${$ab^ic^jd^k|i,j,k\\geq 0$}，只是一个RL，可知$F\\cap L=${$ab^ic^id^i|i\\geq 0$}，在后文中会证明一个定理：一个CFL和RL的交是CFL，也就是说如果$F$是CFL，那么$F\\cap L$也是CFL，而根据泵引理它显然不是CFL，故而$F$并不是CFL。\nOgden引理 有的时候在使用CFL的泵引理时，希望在$v,x$中至少有一个含有某一个“感兴趣”的字符$a$，称这样的字符为特异点（distinguished position） ，为了实现这样的想法，引入Ogden引理：\n对于任意CFL$\\ L$，存在仅仅依赖于$L$的正整数$N$，对于任意$z\\in L$，当$z$中至少含有$N$的特异点时，存在$u,v,w,x,y$使得$z=uvwxy$，并且有：\n$|vwx|$中特异点的个数小于或等于$N$ $|vx|$中特异点的个数大于或等于$1$ $\\forall i\\geq 0,uv^iwx^iy\\in L$ 证明：设有CFL$\\ L$且有$\\epsilon\\notin L$，从而存在CNF：$G=(V,T,P,S)$使得$L=L(G)$，取$N=2^{|V|}+1$，设$z\\in L$，并且$z$中的特异点个数不少于$N$。定义$z$的语法分析树中这样的非叶子节点为 分支点（branch point） ：两个儿子的后代均有特异点的节点。\n现在构造一条从根节点到叶节点的路径$p$：\n将根结点放入路径中 如果路径上的最后一个点只有一个儿子的后代中有特异点，则将这个儿子放入路径 如果路径上的最后一个点的两个儿子的后代中都有特异点，则将特异点多的那个儿子放入路径（相等则任取一个） 直到将叶子放入路径为止 显然$p$中至少含有$|V|+1$个分支点，至少有两个不同的分支点标记了相同的变量，选取两个距离叶节点最近的节点$v_1,v_2$并且前者是后者的祖先节点，类似于泵引理证明那样，这两个节点将派生的句子$z$分成了$z=uvwxy$。\n注意到路径$p$在$v_1$子树部分所含的分支点的个数小于或等于$|V|+1$，所以$v_1$的结果$vwx$所含的特异点最多为$N$个。再注意到$v_1$是分支点，并且$v_2$是它的后代之一，所以$vx$中至少有一个特异点。那么有$S\\Rightarrow^{ * }uAy\\Rightarrow^{ + }uvAxy\\Rightarrow^{ + }uvwxy$，显然$\\forall i\\geq 0,S\\Rightarrow^{ * }uAy\\Rightarrow^{ + }uv^iAx^iy\\Rightarrow^{ + }uv^iwx^iy$，也就是说$\\forall i\\geq 0,uv^iwx^iy\\in L$。\n证毕。\n读者可以尝试使用Ogden引理证明之前提到的语言是固有歧义语言。\nCFL的封闭性 为了方便研究CFL类的封闭性问题，先证明CFL类对部分代换的封闭性：\n如果有$\\Sigma$上的CFL：$L$和代换$s$，且每个$a\\in\\Sigma$的$s(a)$都是CFL，那么$s(L)$也是CFL。\n证明：设$L=L(G),G=(V,T,P,S)$，每一个$s(a)$的文法$G_a=(V_a,T_a,P_a,S_a)$，那么$s(L)$的文法可以构造为$G\u0026rsquo;=(V\\cup(\\cup_{a\\in T}V_a),\\cup_{a\\in T}T_a,P\u0026rsquo;,S)$，其中$P\u0026rsquo;$包含每一个$P_a$中的产生式和$P$的产生式（但是要替换产生式中的每一个终结符$a$为$S_a$），可以证明$s(L)=L(G\u0026rsquo;)$。\n证明了这一定理后，可以进一步证明CFL类对并、连接、克林闭包、正闭包、同态运算是封闭的：\n证明：设$\\Sigma={1,2},L_1,L_2$为任意CFL，定义代换$s(1)=L_1,s(2)=L_2$，那么{$1,2$},{$12$},$1^{ * }$和$1^{ + }$显然是CFL，那么就有：\n$s(${$1,2$}$)=s(1)\\cup s(2)=L_1\\cup L_2$，所以并运算封闭。 $s(${$12$}$)=s(12)=s(1)s(2)=L_1L_2$，所以连接运算封闭。 $s(1^{ * })=s(${$\\epsilon,1,11,\\cdots$}$)=s(\\epsilon)\\cup s(1)\\cup s(11)\\cup\\cdots=s(\\epsilon)\\cup s(1)\\cup s(1)s(1)\\cup\\cdots=${$\\epsilon$}$\\cup L_1\\cup L_1L_1\\cup\\cdots=L_1^{ * }$，所以克林闭包运算封闭。 $s(1^{ + })=s(${$1,11,\\cdots$}$)=s(1)\\cup s(11)\\cup\\cdots=s(1)\\cup s(1)s(1)\\cup\\cdots=L_1\\cup L_1L_1\\cup\\cdots=L_1^{ + }$，所以正闭包运算封闭。 也可以通过构造相应的文法来证明CFL类对并/连接/闭包/反转运算的封闭性：\n证明：设CFL$\\ L_1,L_2$的文法分别为$G_1=(V_1,T_1,P_1,S_1),G_2=(V_2,T_2,P_2,S_2)$，那么可以构造文法：\n$G_{union}=(V_1\\cup V_2\\cup${$S$}$,T_1\\cup T_2,P_1\\cup P_2\\cup${$S\\rightarrow S_1|S_2$}$,S)$，则$L(G_{union})=L_1\\cup L_2$。 $G_{concat}=(V_1\\cup V_2\\cup${$S$}$,T_1\\cup T_2,P_1\\cup P_2\\cup${$S\\rightarrow S_1S_2$}$,S)$，则$L(G_{concat})=L_1L_2$。 $G_{closure}=(V_1\\cup${$S$}$,T_1,P_1\\cup${$S\\rightarrow S_1S|\\epsilon$}$,S)$，则$L(G_{closure})=L_1^{ * }$。 $G_R=(V,T,${$A\\rightarrow\\alpha^R|A\\rightarrow\\alpha\\in P$}$,S)$，则$L(G_R)=L^R$。 CFL类对同态运算封闭。\n证明：若$h$是$\\Sigma$上的同态，$L$是$\\Sigma$上的CFL，对于$\\forall a\\in\\Sigma$，令代换$s\u0026rsquo;(a)=${$h(a)$}，则$h(L)=${$h(w)|w\\in L$}$=\\cup_{w\\in L}${$h(w)$}$=\\cup_{w\\in L}s\u0026rsquo;(w)=s\u0026rsquo;(L)$，所以同态运算封闭。\nCFL类对逆同态运算封闭。\n证明：如果$L$是字母表$\\Delta$上的CFL，$h$是字母表$\\Sigma$到$\\Delta^{ * }$的同态，那么$h^{-1}(L)$也是CFL。\n设有PDA：$P=(Q,\\Delta,\\Gamma,\\delta,q_0,Z_0,F),L(P)=L$，可以构造PDA满足$L(P\u0026rsquo;)=h^{-1}(L)$，在构造中可以利用设置状态以模拟缓冲（Buffer）用于暂存字符$a\\in\\Sigma$的同态串$h(a)$：\n可以构造这样的PDA：$P\u0026rsquo;=(Q\u0026rsquo;,\\Sigma,\\Gamma,\\delta\u0026rsquo;,[q_0,\\epsilon],Z_0,F\\times${$\\epsilon$}$)$\n$Q\u0026rsquo;$中的状态为$[q,x],q\\in Q$，即$P$的状态和缓冲中还未被消耗的串$x$，也即某个$h(a)$的后缀。 设$q\\in Q$，那么$\\forall [q,\\epsilon]\\in Q\\times${$\\epsilon$}$,\\forall a\\in\\Sigma,\\forall X\\in\\Gamma,\\delta\u0026rsquo;([q,\\epsilon],a,X)=${$([q,h(a)],X)$}，也就是将$h(a)$装载到缓冲中的过程。 模拟$P$处理在缓冲中储存的$h(a)$的过程：$\\forall b\\in\\Delta\\cup${$\\epsilon$}，如果有$\\delta(q,b,X)=${$(p_1,\\beta_1),\\cdots,(p_k,\\beta_k)$}，则有$\\delta\u0026rsquo;([q,bx],\\epsilon,X)=${$([p_1,x],\\beta_1),\\cdots,([p_k,x],\\beta_k)$}，这里的$x$是某个$h(a)$的后缀。 和RL类不同，CFL类在交运算下不是封闭的，证明如下：\n证明：考虑$L_1={0^n1^n2^i|i,n\\geq 1}$，$L_2={0^i1^n2^n|i,n\\geq 1}$，它们显然是CFL，但是$L_1\\cap L_2={0^n1^n2^n|n\\geq 1}$，这不是一个CFL，同样地CFL类在补运算下也不封闭（考虑$L_1\\cap L_2=\\overline{\\overline{L_1}\\cup\\overline{L_2}}$）。\n但是如果$L$是CFL且$R$是正则语言，则$L\\cap R$是CFL，证明如下：\n设有DFA：$D=(Q_1,\\Sigma,\\delta_1,q_1,F_1)$和PDA：$P=(Q_2,\\Sigma,\\Gamma,\\delta_2,q_2,Z_0,F_2)$，同时有$L(D)=R,L(P)=L$，那么可以构造接受$L\\cap R$的PDA：$P\u0026rsquo;=(Q_1\\times Q_2,\\Sigma,\\Gamma,\\delta,(q_1,q_2),Z_0,F_1\\times F_2)$，其中$\\delta$满足下列条件：\n$\\delta((p,q),a,Z)={((p,s),\\beta)|(s,\\beta)\\in\\delta_2(q,a,Z)}$，若有$a=\\epsilon$。 $\\delta((p,q),a,Z)={((r,s),\\beta)|r=\\delta_1(p,a)且(s,\\beta)\\in\\delta_2(q,a,Z)}$，若有$a\\neq\\epsilon$。 CFL的判定性质 关于CFL的判定性质，在此进行简单的说明：\n判定一个CFL是否为空就是看生成它的文法的起始符号是否为无用符号，如果起始符号为无用符号，那么语言为空。\n判定一个CFL是否为无穷语言，先作出CFL$\\ L$对应的文法$G=(V,T,P,S)$，并且去除$G$的无用符号，再用一张有向图来表示$G$，其中图的顶点为$G$中的变量，如果$A\\rightarrow B\\in P$，那么在图中增加一条从$A$到$B$的边，图的源点为$S$，如果图中存在可以从源点出发到达的环，那么这个CFL是一个无穷语言。\n判定一个字符串是否属于CFL可以使用CYK算法，在这里不对CYK算法进行说明。\n确定性上下文无关语言 确定性下推自动机的形式化定义 在程序设计语言编译器中要设计语法分析器，而通常来说，与CFL相比，对 确定型上下文无关语言（Deterministic context free languague,DCFL） 进行语法分析要更加容易，能够被 确定性下推自动机（Deterministic pushdown automata,DPDA） 识别的语言就是DCFL，构造DPDA也就要在PDA的基础上遵循确定性的基本原则：在计算的每一步，根据其转移函数，DPDA只有一种继续的方式，但是定义DPDA比定义DFA更加复杂，因为DPDA可能在不弹出栈符号的情况下读入输入符号，反之也是这样。同样在DPDA的转移函数中存在$\\epsilon$-转移：$\\epsilon$-输入转移（$\\epsilon$-in-put move）对应于$\\delta(q,\\epsilon,x)$，$\\epsilon$-栈转移（$\\epsilon$-stack move）对应于$\\delta(q,a,\\epsilon)$，当然也允许$\\delta(q,\\epsilon,\\epsilon)$。但是一台DPDA不能同时做出多个动作，现在给出DPDA的形式化定义：\nDPDA是一个七元组$P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$，它在满足PDA的形式化定义的前提下还要求满足下列条件：\n对于$\\forall q\\in Q,a\\in\\Sigma\\cup${$\\epsilon$}$,x\\in\\Gamma,\\delta(q,a,x)$至多只能含有一个元素。 对于$\\forall q\\in Q,x\\in\\Gamma$，如果有$\\delta(q,\\epsilon,x)\\neq\\varnothing$，那么对于$\\forall a\\in\\Sigma$都有$\\delta(q,a,x)=\\varnothing$。 DPDA接受一个语言有两种标准：以空栈形式接受和以最终状态接受，这两种方式接受的语言都是非固有歧义的CFL，但是并非所有非固有歧义的CFL都可以被DPDA接受，例如$L(G)$，其中$G=${{$S$},{$0,1$},{$S\\rightarrow 0S0|1S1|\\epsilon$}$,S$}。\n不同于PDA，对于DPDA而言这两种接受方式是不等价的（以空栈形式接受的语言是以最终状态接受的并且满足无前缀性质的语言），故而使用最终状态作为接受标准来定义DCFL。\n如果DPDA在读入字符串的最后一个符号后进入接受状态则接受这个字符串，在其他任何情况下都拒绝这个字符串，也就意味着有两种情况会发生拒绝：要么DPDA读完了全部输入但是无法进入接受状态，要么DPDA没有成功读完全部输入字符串。\n两种特殊情况会导致DPDA无法成功读完全部输入字符串：DPDA试图弹出空栈（hanging）和DPDA执行无尽的$\\epsilon$-转移序列，通过对DPDA进行适当的修改，可以让可能发生这两种情况的DPDA都转为能够读完整个输入字符串的等价DPDA。\n为了简化讨论，可以将一个特定标记符号$\\dashv$放到输入字符串的末尾，称其为 输入结束标记（endmarked input） ，可以证明添加这一个标记不会改变DPDA的能力（也就是说接受的语言依旧是DCFL），然而这为简化设计DPDA提供了帮助，使用结束标记语言$A\\dashv$表示字符串$w\\dashv,w\\in A$的集合。\n很容易构造出DPDA接受语言{$0^n1^n|n\\geq 0$}，也就是说RL类是DCFL类的真子类。但是现在还无法判断DCFL类是否是CFL类的真子类，为此不妨考虑DCFL的封闭性，现在说明DCFL对运算的封闭性。\nDCFL的封闭性 DCFL类在补运算下封闭。\n证明：简单地类比DFA交换接受状态和非接受状态的证明是错误的，因为在输入字符串的末端，DPDA进入转移序列的接受和非接受状态都可能接受输入，在这种情况下，交换接受状态和非接受状态依旧会发生接受。不妨将DPDA：$P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,F)$修改为总是读入全部输入字符串、同时一旦进入一个接受状态它将会停留在接受状态直到读入下一个输入符号。现在给出一种可行的构造：如果DPDA读入字符并且没有弹栈（$\\delta(q,a,\\epsilon)\\neq\\varnothing$），可以称这样一个状态$q$是一个“读入状态”，倘若弹栈了，也就是说$\\delta(q,a,x)=(r,w_1w_2\\cdots w_n)$，那么不妨新增状态并修改$\\delta$使得$\\delta(q,\\epsilon,x)=\\delta(q_{w_1},\\epsilon),\\delta(q_{w_1},\\epsilon)=(q_{w_2},w_1),\\cdots,\\delta(q_{w_n},\\epsilon)=(r,w_n)$，那么认定$q_{w_1},q_{w_2},\\cdots,q_{w_n}$都是“读入状态”，如果又有$q\\in F$，则认定它们都是接受状态。最后从所有非读入状态中移除接受状态的认定，这样再将接受状态和非接受状态互换就可以得到接受DCFL的补的DPDA。\n这个事实说明一些CFL并不是DCFL，如果CFL的补不是一个CFL，那么它就不是一个DCFL，例如$A=${$a^ib^jc^k|i,j,k\\geq 0,i\\neq j或j\\neq k$}便不是一个DCFL但它是一个CFL，否则$\\overline{A}\\cap${$a^ib^jc^k|a,b,c\\geq 0$}={$a^nb^nc^n|n\\geq 0$}将是一个CFL。\nDCFL类在并运算下不封闭。\n证明：可以构造$L_1=${$a^ib^c^k|i,j,k\\geq 0且i\\neq j$}$,L_2=${$a^ib^jc^k|i,j,k\\geq 0且j\\neq k$}，可以构造DPDA识别这两个语言，故而它们都是DCFL，但是有$L_1\\cup L_2=${$a^ib^jc^k|i,j,k\\geq 0,i\\neq j或j\\neq k$}，在先前已经证明了它不是一个DCFL，故DCFL类在并运算下不封闭。\nDCFL类在交运算下不封闭。\n证明：考虑$L_1\\cup L_2=\\overline{(\\overline{L_1}\\cap\\overline{L_2})}$，由于DCFL类在补运算下封闭、在并运算下封闭，所以DCFL类在交运算下不封闭。\n虽然DCFL类在交运算下不封闭，但是类似于CFL类，DCFL与RL的交是一个DCFL，证明如下：\n证明：考虑有DFA：$D=(Q_1,\\Sigma_1,\\delta_1,q_{s1},F_1)$和DPDA：$P=(Q_2,\\Sigma,\\Gamma,\\delta_2,q_{s2},Z_0,F_2)$，那么可以构造DPDA：$P\u0026rsquo;=(Q_1\\times Q_2,\\Sigma,\\Gamma,\\delta_3,(q_{s1},q_{s2}),Z_0,F_1\\times F_2)$，其中$\\delta_3$为$(Q_1\\times Q_2)\\times\\Sigma\\times\\Gamma\\rightarrow(Q_1\\times Q_2)\\times\\Gamma^{ * }$的函数，并且满足$\\forall q_1\\in Q_1,\\forall q_2\\in Q_2,\\delta_3((q_1,q_2),a,b)=(\\delta_1(q_1,a),\\delta_2(q_2,a,b))$，这样一个DPDA识别的语言是$L_1\\cap L_2$，也就说明DCFL与RL的交是一个DCFL。\nDCFL类在连接运算下不封闭。\n证明：设$L_1=${$a^ib^jc^k|i,j,l\\geq 0,i\\neq j$},$L_2=${$a^ib^jc^k|i,j,k\\geq 0,i\\neq k$},$L_3=({d}L_1)\\cup L_2$，很容易构造识别$L_3$的DPDA，也就是说$L_3$是DCFL，已知$d^{ * }$为DCFL，不妨设DCFL类在连接运算下封闭，也就是说$d^{ * }L_3$是DCFL，已知$L_4=${$da^ib^jc^k|i,j,k\\geq 0$}，它是一个RL，也就是说$d^{ * }L_3\\cap L_4$是一个DCFL，但是有$d^{ * }L_3\\cap L_4=dL_1\\cup dL_2=d(L_1\\cup L_2)$，$L_1\\cup L_2$不是DCFL，显然$d(L_1\\cup L_2)$不是DCFL，矛盾，得证。\nDCFL类在克林闭包运算下不封闭。\n证明：设$L_1=${$a^ib^jc^k|i,j,l\\geq 0,i\\neq j$},$L_2=${$a^ib^jc^k|i,j,k\\geq 0,i\\neq k$},$L_3={$d$}\\cup${$d$}$L_1\\cup L_2$，考虑$L_3^{ * }\\cap${$d^{ * }$}$(${$a^{ * }$}{$b^{ * }$}{$c^{ * }$}-{$\\epsilon$}$)=${$d$}$(L_1\\cup L_2)$，如果DCFL类在克林闭包运算下封闭，则导出矛盾，得证。\nDCFL类在反转运算下不封闭。\n证明：设$L_1=(a+b+c)^{ * }wcw^R,L_2=wcw^R(a+b+c)^{ * },w\\in(a+b)^{ + }$，前者不是DCFL，但是反转后得到后者却是DCFL，得证。\n确定性上下文无关文法 在先前的分析中，多考虑的是派生的过程，而为了引出确定性上下文无关文法，要考虑的是归约的过程。\n对以$S$为起始变元的CFG，串$w$属于它的语言，设$w$的最左归约为：$w=u_1\\mapsto u_2\\mapsto\\cdots\\mapsto u_k=S$，如果要确保“确定性”，规定$u_i$决定了下一个步骤$u_{i+1}$，因此$w$决定了整个归约过程，但这只能说明无歧义，因而要进一步要求对于每一个$u_i$，下一个归约步骤必须由$u_i$的前缀唯一确定，且此前缀从头开始并且包含了归约步骤中的归约串（也就是被替换的串，reducing string）$h$。\n令$w$是属于CFG：$G$的一个字符串，$u_i$出现在$w$的最左归约中，在归约步骤$u_i\\mapsto u_{i+1}$中称产生式$T\\rightarrow h$被反向运用。也就是说可以记作$u_i=xhy,u_{i+1}=xTy$，其中$h$是归约串，$x$是$u_i$的一部分并且出现在$h$的左侧，$y$是$u_i$的一部分并且出现在$h$的右侧，也就是有$u_i=x_1\\cdots x_jh_1\\cdots h_jy_1\\cdots y_l\\mapsto x_1\\cdots x_jTy_1\\cdots y_l=u_{i+1}$，现在定义$h$和和它相关的产生式$T\\rightarrow h$称为是$u_i$的一个 句柄（handle） ，在不关注产生式的情况下也可以特指归约串，为方便起见，定义句柄的时候只需要考虑$L(G)$中的句子的最左归约，称归约过程中出现的字符串为 有效串（valid string） 。\n考虑文法$G_1=(${$R,S,T$},{$a,b$},{$R\\rightarrow S|T,S\\rightarrow aSb|ab,T\\rightarrow aTbb|abb$}$)$，很明显它识别的语言是$A\\cup B,A=${$a^mb^m|m\\geq 1$}$,B=${$a^mb^{2m}|m\\geq 1$}，很容易利用PDA的不确定性来识别$L(G_1)$，它将会猜测输入是$B$中的字符串亦或者是$C$中的字符串，它在将$a$压入栈中后将弹出句柄并尝试用句柄匹配$b$或者$bb$。但是对于DPDA而言它不能预先知道输入属于哪个集合，自然不知道如何匹配句柄，实际上可以证明$L(G_1)$不是DCFL。\n从这样一个例子可以发现句柄起着非常重要的作用，为了让DCFG和DPDA相对应，自然要对句柄作出限制。某个串可能有多个句柄的歧义性语法，选择一个特定的句柄可能需要预先知道语法分析树产生了这个串，以及那些对于DPDA一定是无法获得的信息。很明显DCFG理应是非歧义性的，因而句柄是独一无二的，然而独一无二的句柄并不够定义DCFG，考虑刚刚定义的文法$G_1$产生的句子$aabb,aabbbb$，确定这样两个字符串的句柄还需要读完整个输入。\n所以要对句柄施加一个额外的要求：一个有效串的初始部分必须足以决定句柄，也就是说读入有效串的过程中一旦读入了句柄就可以确定获得了句柄，因此，在每一个有效串$xh\\hat{y},\\hat{y}\\in\\Sigma^{ * }$中$h$是独一无二的句柄时，那么称$h$是有效串$v=xhy$的一个 强制句柄（forced handle） 。\n现在可以给出DCFG的定义了： 确定性上下文无关文法（deterministic context free grammar,DCFG） 是能够让每一个有效串都有一个强制句柄的上下文无关文法。\n已经有了DCFG在数学上的精确定义，但是却无法判断一个CFG是否是DCFG，下文将提供一个能够准确实现整个目的的过程，称之为$DK$-测试，它依赖于一个简单但令人惊讶的定理：对于任意CFG：$G$都能够构造一个可以识别句柄的关联DFA：$DK$，如果满足以下条件，$DK$将接受它的输入：\n$z$是某个有效串$v=zy$的前缀。 $z$以$v$的一个句柄作为结束。 首先考虑这样一个NFA：$J$，它接受每一个以任何产生式的右部作为结束的输入串，构造$J$是相当容易的：\n$J$将猜测哪个产生式可以适用，也能猜测从何处开始将输入和产生式的右部相匹配，随着匹配输入，$J$通过已经选好的产生式的右部来追踪它的进程，在这个产生式的右部的对应位置放置句点以表示这个进程，称为加点规则（dotted rule）/项（item），对于$B\\rightarrow u_1u_2\\cdots u_k$将会产生$k+1$个加点规则：$B\\rightarrow.u_1u_2\\cdots u_k,B\\rightarrow u_1.u_2\\cdots u_k,B\\rightarrow u_1u_2\\cdots.u_k,B\\rightarrow u_1u_2\\cdots u_k.$。\n每一个加点规则都对应于$J$的一个状态，句点到产生式末尾时称为是完整规则（completed rule），它对应着$J$的接受状态，它没有向外的转换。\n对于每一个规则$B\\rightarrow u$，为$B\\rightarrow.u$添加一个单独的由所有符号的自循环构成的起始状态和从起始状态到这个状态的$\\epsilon$-转移，这样便完成了$J$的构造。\n现在引入NFA：$K$，它以相似但简捷的方式选择匹配规则，只有可能的归约规则才会被允许。和$J$一样它的状态对应于所有加点规则，接受状态对应着完整规则，它没有向外的转换。它有一个特殊的起始状态$S_1$，该状态对所有包含起始变元$S_1$的规则来说都有到$S_1\\rightarrow.u$的$\\epsilon$-转移，$K$的转移函数$\\delta$满足：\n如果有产生式$B\\rightarrow uav$，那么{$B\\rightarrow ua.v$}$\\subseteq\\delta(B\\rightarrow u.av,a)$。 如果有产生式$B\\rightarrow uCv,C\\rightarrow r$，那么{$C\\rightarrow.r$}$\\subseteq\\delta(B\\rightarrow u.Cv,\\epsilon)$。 可以证明：\n在输入$z$上$K$可能进入状态$T\\rightarrow u.v$当且仅当对于某些$y\\in\\Sigma^{ * },z=xu$且$xuvy$是一个句柄为$uv$、归约规则为$T\\rightarrow uv$的有效串。也就是说在输入$z$上$K$可能进入接受状态$T\\rightarrow h.$当且仅当$z=xh$且$h$是遵循归约规则$T\\rightarrow h$的有效串$xhy$的一个句柄。\n之前已经证明了可以利用子集构造法的方式将一个NFA转换成DFA，现在用子集构造法将$K$转换成$DK$，每一个$DK$的状态包含若干个加点规则，每一个接受状态包含至少一个完整规则，上面的定理依旧可以被应用。现在给出$DK$-测试：\n从一个CFG：$G$开始构造关联的DFA：$DK$，通过检查$DK$的接受状态，判定$G$是否是DCFG，通过$DK$-测试要求每一个接受状态包含：\n有且仅有一个完整规则。 所有加点规则中句点不会紧跟着一个终结符，即没有形如$B\\rightarrow u.av,a\\in\\Sigma^{ * }$的加点规则。 可以证明$G$通过$DK$-测试当且仅当$G$是一个DCFG。\n在实际运用中直接构建$DK$会比事先构造$K$再将其转为NFA更快，下面给出对$G_1=(${$S,E,T$},{$a,+,\\times,\\dashv$},{$S\\rightarrow E\\dashv,E\\rightarrow E+T|T,T\\rightarrow T\\times a|a$}$,S)$使用$DK$-测试的结果。\n可以看到左下侧和右上侧这两个接受状态不符合$DK$-测试的要求，也就是说这个文法不是DCFG。\n再对文法$G_2=${{$S,T$},{$\\dashv,(,)$},{$S\\rightarrow T\\dashv,T\\rightarrow T(T)|\\epsilon$}$,S$}使用$DK$-测试。\n这个文法对应的$DK$的所有接受状态都满足$DK$-测试的条件，也就是说这个文法是DCFG。\nDPDA和DCFG的等价性 之前已经证明了结束标记不会影响DPDA识别的语言类，但是它会影响DCFG产生的语言类。如果没有结束标记，DCFG只会产生DCFL的一个子类————它们都是前缀无关的，值得注意的是所有结束标记语言都是前缀无关的。\n每一个DCFG都有一个等价的DPDA。\n证明：考虑这样的$P$，它将利用之前构造的$DK$进行操作，对于从输入中所读取的符号，它模拟$DK$直到$DK$接受，$DK$的接受状态指明一个特定的加点规则，因为$G$是确定性的，并且这个规则为扩展了目前已知输入的有效串确定一个句柄。此外，因为$G$是确定性的，这个句柄适用于每一个有效扩展，特别地如果输入属于$L(G)$，那么这个句柄适用于对$P$的全部输入。所以$P$能使用这个句柄为它的输入串确定第一个归约步骤，尽管在此时它只是读入了它输入的一部分。为了让$P$执行接下来的归约步骤，可以在栈中存储所有$DK$的状态，当$P$读入一个输入符号并模拟一个在$DK$中的转移时，它通过将其压入栈来记录$DK$的状态。当其使用归约规则$T\\rightarrow u$来执行一个归约步骤时，它从栈中弹出$|u|$个状态，展现在读入$u$之前$DK$的状态。它将$DK$重置为该状态，接下来在输入$T$上模拟$DK$，并将产生的状态压入栈，之后$P$像之前读取和处理输入符号那样继续进行。当$P$将起始变元压入栈时，表明它已经找到了一个输入到起始变元的归约，那么进入一个接受状态。\n对于每一个能够识别结束标记语言的DPDA都有一个等价的DCFG。\n证明：设DPDA：$P=(Q,\\Sigma,\\Gamma,\\delta,q_0,Z_0,${$q_a$}$)$，构造CFG：$G$，其起始变元为$A_{q_0,q_a}$，其产生式按照以下规则产生：\n对于$\\forall p,q,r,s,t\\in Q,\\forall u\\in\\Gamma,\\forall a,b\\in\\Sigma_{\\epsilon}$，如果$\\delta(r,a,\\epsilon)=(s,u)$且$\\delta(t,b,u)=(q,\\epsilon)$，则$A_{pq}\\rightarrow A_{pr}aA_{st}b$是$G$的产生式。 对于$\\forall p\\in Q$，$A_{pp}\\rightarrow\\epsilon$是$G$的产生式。 可以证明如果$P$读入包含一个变量$A_{pq}$的$v_i$，那么它正好在读入$A_{pq}$之前进入状态$p$，从而可以证明$G$可以通过$DK$-测试，也就是说这样构造的CFG是一个DCFG。\n可以得到这样的结论：一个结束标记语言是DCFL当且仅当它可以由一个DCFG产生。\nLR(k)文法 DCFG有时在表达特殊的DCFL时并不方便，其要求所有句柄都是强制句柄，这限制了设计直观的DCFG，解决这一问题可以考虑一个叫做LR(k)的宽泛文法类（首字母的缩略词表示Left to right input processing,Rightmost derivation），它和DCFG非常相似，都允许到DPDA的直接转变，这个文法的赛诺菲引入了前瞻性（lookahead），它的句柄也可能依赖于该句柄后的前$k$个符号。\n令$h$是有效串$v=xhy$的一个句柄，如果$h$对每一个有效串$x\\hat{h}y$（$xh\\hat{y}$满足$\\hat{y}\\in\\Sigma^{ * }$且$y$和$\\hat{y}$在它们的前$k$个符号上是一致的）来说是独一无二的句柄，那么称$h$是 被前瞻k所强制的（forced by lookahead k） 。（如果其中某个串的长度小于$k$，那么一致的长度和这个短串的长度相同）\n现在给出对LR(k)文法的定义：LR(k)文法是一种每一个有效串的句柄都是被前瞻$k$所强制的上下文无关语法。\nLR(0)文法实际上就是DCFG，同时也能证明对于任何一个$k$，都能将文法LR(k)转换为DPDA，也就是说LR(k)文法对所有$k$和所有DCFL的准确描述在能力上是等价的。\n类似于DCFG，现在给出$DK_1$-测试（前瞻为1的$DK$-测试）的定义，先构造一个NFA：$K_1$并将其转换成DFA：$DK_1$。$K_1$的每一个状态是一个加点规则$T\\rightarrow u.v$和称为 前瞻符号（lookahead symbol） 的终结符$a$构成的二元组，这说明$K_1$最近读入了串$u$，如果$v$在$u$后出现并且$a$在$v$之后出现，那么$u$可能为句柄$uv$的一部分。\n对每一个包括起始变元$S_1$和所有$a\\in\\Sigma$的产生式，开始状态有个到$(S_1\\rightarrow.u,a)$的$\\epsilon$-转移，同样也有{$(T\\rightarrow ux.v,a)$}$\\subseteq\\delta((T\\rightarrow u.xv,a),x)$和{$(C\\rightarrow.r,b)$}$\\subseteq\\delta((T\\rightarrow u.Cv,a),\\epsilon)$，这里的$b$是能从$v$中派生出来的任意终结符串的第一个符号。如果$v$派生出$\\epsilon$，那么添加$b=a$。对完整规则$B\\rightarrow u.$和$a\\in\\Sigma$，所有的接受状态都是$(B\\rightarrow u.,a)$。\n令$R_1$是带前瞻符号$a_1$的完整规则，$R_2$是带前瞻符号$a_2$的加点规则，满足以下其中任意一个条件则称$R_1,R_2$是 一致的（consistent） ，如果有：\n$R_2$是完整的且$a_1=a_2$。 $R_2$不是完整的且$a_1$紧跟在句点后面。 那么$DK_1$-测试就是将$K_1$转换成DFA并且要求每一个接受状态一定不包含任意两个一致的加点规则。可以证明文法$G$通过$DK_1$测试当且仅当$G$是一个LR(1)文法。考虑文法$G_1=(${$S,E,T$},{$a,+,\\times,\\dashv$},{$S\\rightarrow E\\dashv,E\\rightarrow E+T|T,T\\rightarrow T\\times a|a$}$,S)$，对它使用$DK_1$-测试，那么有：\n可以知道它是一个LR(1)文法而非DCFG。\n","date":"2024-07-12T00:00:00Z","image":"https://0x3a0x29.github.io/p/contextfree/image_hu9117791808388664113.png","permalink":"https://0x3a0x29.github.io/p/contextfree/","title":"下推自动机PDA及上下文无关语言CFL"},{"content":"有穷自动机FA及正则语言RL 前言 阅读本文需要集合论和图论的相关知识，在此不作有关集合论和图论相关知识的赘述。 笔者水平有限，存在的错误和不足请大家指正。\n字符串和语言 字母表（alphabet）：一个非空有穷集合，其成员被称为该字母表的符号（symbol），通常用大写希腊字母$\\Sigma,\\Gamma$来表示字母表和字母表中符号的打印字体。\n字符串（string）：字母表中符号的有穷序列，通常写为一个符号挨着一个符号，不用逗号分隔，如果一个字符串$w$由字符$w_1,\\cdots,w_n$一个挨着一个表示，称$w=w_1\\cdots w_n$。一个字符串$w$所包含的符号数目称为它的长度（length），记作$|w|$。长度为零的字符串称为空串（empty string），记作$\\epsilon$。若$\\alpha$为$\\alpha_1\\cdots\\alpha_m$、$\\beta$为$\\beta_1\\cdots\\beta_n$，它们都是某个字母表$\\Sigma$的字符串，若$m=n$且对于每个$j,1\\leq j\\leq n$都有$\\alpha_j$与$\\beta_j$相同，称$\\alpha=\\beta$。\n反转（reverse）：按照相反的顺序写$w$所得到的字符串，记作$w^R$，例如$w=w_1w_2\\cdots w_n$，那么有$w^R=w_nw_{n-1}\\cdots w_1$。\n连接（concatenation）：若有字符串$x=x_1\\cdots x_m,y=y_1\\cdots y_n$，那么连接运算记作$xy=x_1\\cdots x_my_1\\cdots y_n$，也即把$y$附加在$x$得到的字符串。\n不难发现全体字符串集$W$对连接运算构成了一个以字母表$\\Sigma$为基的自由含幺半群/自由独异点，也即：\n对于字符串$x,y,z\\in W$，结合律$(xy)z=x(yz)$成立。 对于字符串$x\\in W$，$\\epsilon x=x\\epsilon=x$，即$\\epsilon$为单位元。 对于字符串$x\\in W$，可以唯一地表示为$x=x_1\\cdots x_n$，此处的$x_1,\\cdots,x_n\\in\\Sigma$。 对于字符串$x,y,z\\in W$，若有$xy=xz$，则$y=z$；若有$xz=yz$，则$x=y$。即满足左、右消去律。 因为结合律成立，可以定义一个字符串自身连接多次为$x^k=x\\cdots x$，共有$k$个$x$连接。\n子串（substring）：若有$\\beta=\\gamma\\alpha\\theta$，其中$\\alpha,\\beta,\\gamma,\\theta$都是某个字母表上的字符串，那么称$\\alpha$为$\\beta$的子串。\n字典序（lexicographic order）：类似于大家熟悉的字典顺序，而一般采用字符串顺序（string order），它在字典序的基础上将短的字符串排在长的字符串的前面，例如字母表$\\Sigma=${$0,1$}上的字符串顺序为$(\\epsilon,0,1,00,01,10,11,000,\\cdots)$。\n前缀（prefix）：如果有字符串$x,y,z$满足$xz=y$，则称$x$是$y$的前缀，并且若$x\\neq y$，则称$x$是$y$的真前缀（proper prefix）。\n语言（language）：字符串的集合，称不含字符串的语言为空语言，记作$\\varnothing$。如果语言中任何一个成员都不是其他成员的真前缀，那么该语言是无前缀的（prefix-free）。\n有穷自动机 有穷自动机的引入 有穷自动机（finite automaton,FA） 是描述能力和资源极其有限的计算机的模型，但是它也可以做到很多的事情。以一个生活中的例子为例：\n想象一个电视机，在处在开启状态时接收到关闭指令时它的状态会变为关闭，在处在关闭状态时接收到关闭指令时它的状态会变为开启，电视机有两个状态：开启状态和关闭状态，而指令是外部输入，这是一种有穷自动机。\n为了更好地描述FA，可以设想一种物理模型————FA的物理模型，现在对其进行描述。首先它带有一个输入带，在输入带上有一系列方格，每个方格里都储存了一个字符，约定输入串从输入带的左端点开始存放，而输入带的右端是无穷的。其次系统有一个有穷状态控制器（finite state control，FSC），带有有穷个状态，FSC控制了一个读头，每读入一个字符就将读头指向输入带的后一个字符。系统的运行按照3个节拍进行：读入读头指向的字符，FSC根据当前的状态和读入的字符改变状态，读头向右移动一格。\n而在很多地方FA都有它的应用，如在时序电路设计当中有摩尔机（Moore Machine）：时序电路的输出是现态的函数。米利机（Mealy Machine）：输出是现态和输入的函数。它们两个也都是FA,下面使用Verilog语言编写的三段式代码描述了一个时序电路中的Moore机，它包含在物理模型当中提到的读入输入，改变状态，等待下一个输入的过程。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 //状态寄存器 always @ (posedge clk or negedge rst_n) begin if(!rst_n) state \u0026lt;= IDLE; else state \u0026lt;= next_state; end //次态的组合逻辑 always @ (*) begin case(state) IDLE：begin if(w_i) next_state = S0; else next_state = IDLE; end S0: begin if(w_i) next_state = S1; else next_state = IDLE; end S1: begin if(w_i) next_state = S1; else next_state = IDLE; end default : next_state = 2\u0026#39;bxx; endcase end //输出逻辑 always @ (*) beign case(current) IDLE: z = 1\u0026#39;b0; S0: z = 1\u0026#39;b0; S1: z = 1\u0026#39;b1; default: z = 1\u0026#39;b0; endcase end 上面的这种FA也被称为有穷状态转换器（Finite-state transducer，FST），读者可以尝试自己给出它的形式化定义，在此不作相关说明。\n为了更好地描述FA的工作，先不给出FA的形式化定义，首先给出一个有穷自动机$M_1$：\n上面这个图被称为$M_1$的状态图（state diagram），它总共有三个状态$q_0,q_1,q_2$，起始状态（start state）$q_0$用一个单独的箭头表明出来，接受状态（accept state）$q_1$带有一个双圈，从一个状态指向另一个状态的箭头称为转移（transition）。当这个自动机接收到字符串后它会处理这个字符串并给出一个输出，或是接受或是拒绝。常用状态转移表来描述可能的转移过程：\n0 1 $q_0$ $q_0$ $q_1$ $q_1$ $q_2$ $q_1$ $q_2$ $q_2$ $q_2$ 现在来看两个字符串输入的例子：\n输入字符串011：\n开始时处在状态$q_0$。 读到0，沿着转移从$q_0$到$q_0$。 读到1，沿着转移从$q_0$到$q_1$。 读到1，沿着转移从$q_1$到$q_1$。 输出接受，因为在输入字符串的末端$M$正处在一个接受状态$q_1$。 输入字符串1100：\n开始时处在状态$q_0$。 读到1，沿着转移从$q_0$到$q_1$。 读到1，沿着转移从$q_1$到$q_1$。 读到0，沿着转移从$q_1$到$q_2$。 读到0，沿着转移从$q_2$到$q_2$。 输出拒绝，因为在输入字符串的末端$M$不处在一个接受状态。 有穷自动机的形式化定义 上面的例子说明，一台FA可以描述成一张含5个部分的表：状态集、输入字母表、动作规则、起始状态集和接受状态集。而用 转移函数（transition function） 来定义动作规则，常记作$\\delta$。\nFA是一个5元组$M=(Q,\\Sigma,\\delta,q_0,F)$，其中：\n$Q$是一个有穷集合，称为状态集。 $\\Sigma$是一个有穷集合，称为字母表。 $\\delta:Q\\times\\Sigma\\rightarrow Q$，称为转移函数。 $q_0\\in Q$是起始状态。 $F\\subseteq Q$是接受状态集。 这样就可以给出上面的例子$M_1$的形式化描述：\n$Q=${$q_0,q_1,q_2$}。 $\\Sigma=${$0,1$}。 $\\delta(q_0,0)=q_0,\\delta(q_0,1)=q_1,\\delta(q_1,0)=q_2,\\delta(q_1,1)=q_1,\\delta(q_2,0)=q_2,\\delta(q_2,1)=q_1$。 $q_0$是起始状态。 $F=${$q_1$}。 若$A$是机器$M$所接受的全部字符串集，则称$A$是机器$M$的语言，记作$L(M)=A$，又称$M$识别$A$或$M$接受$A$。\n转移函数处理的是一个字符，为了在理论分析时更加便于处理字符串，定义扩展转移函数$\\hat{\\delta}$：当$w=\\epsilon$时$\\hat{\\delta}(q,w)=q$，当$w=xa$时$\\hat{\\delta}(q,w)=\\delta(\\hat{\\delta}(q,x),a)$，其中$w,x$是字符串，$a$是字符。可知机器$M$接受$w$当且仅当$\\hat{\\delta}(q_0,w)\\in F$。\n正则运算 正则语言（regular language，RL）：如果一个语言被一台FA识别，则称它为正则语言。\n为了更好的研究RL，引入 正则运算（regular operation） 以便研究它的性质，设$A,B$为两个语言，那么有：\n并（union）：$A\\cup B=${$x|x\\in A或x\\in B$}，也有写作$A+B$的。 连接（concatenation）：$A\\circ B=${$xy|x\\in A且y\\in B$}，在不产生混淆的情况下可以写为$AB$。 幂（power）：$A^0=${$\\epsilon$}$,A^1=A,A^n=A^{n-1}\\circ A$。 克林闭包（Kleene star）：$A^{ * }=\\cup^\\infty_{i=0}A^i$，也有一种定义称$A^+=\\cup^\\infty_{i=1}A^i$为正闭包。 除了正则运算外，也有一些常用的运算，在此也作出介绍：\n对于两个语言$A,B$，那么有交运算：$A\\cap B=${$x|x\\in A且x\\in B$}。 对于两个语言$A,B$，那么有差运算：$A-B=${$x|x\\in A且x\\notin B$}。 对于字母表$\\Sigma$上的一个语言$L$，称这个语言的补运算为：$\\overline{L}=\\Sigma^{ * }-L$，显然有$L-M=L\\cap\\overline{M}$。 对于字母表$\\Sigma$上的语言$L$，称它的反转为$L^R=${$w^R\\in\\Sigma^{ * }|w\\in L$}。 对于字母表$\\Sigma$上的语言$L_1,L_2$，称**商（quotient）**为：$L_1/L_2=${$x|\\exists y\\in L_2使得xy\\in L_1$}，这里是$L_2$除以$L_1$的商。 为了更好地研究语言和运算之间的性质，引入封闭性的概念：\n如果任意的属于某一语言类的语言在某一特定运算下所得的结果任然是该类语言，则称该语言类对此运算是封闭的，并称该语言类对此运算有封闭性（closure property）。\n给定一个语言类的若干语言的描述。如果存在一个算法，它可以构造出这些语言在给定运算下所获得的运算结果的相应形式的语言描述，则称此语言类对相应的运算是有效封闭的，并称此语言类对相应的运算具有有效封闭性（valid closure property）。\n可以证明RL在并运算下是封闭的：\n设有RL：$A_1,A_2$，识别它们的有穷状态机分别为$M_1=(Q_1,\\Sigma,\\delta_1,q_1,F_1),M_2=(Q_2,\\Sigma,\\delta_2,q_2,F_2)$（两者的字母表不同时也可以构造相应的证明过程），那么可以构造这样一台FA$M=(Q_1\\times Q_2,\\Sigma,\\delta,(q_1,q_2),(F_1\\times Q_2)\\cup(Q_1\\times F_2))$，其中对于每一对$(r_1,r_2)\\in Q,a\\in\\Sigma$，$\\delta((r_1,r_2),a)=(\\delta_1(r_1,a),\\delta_2(r_2,a))$，这台自动机可以识别$A_1\\cup A_2$。\nRL在连接运算下也是封闭的，但是如果想要证明这个事实，就会面临一个问题，该如何让需要构造的自动机$M$知道哪里才能将输入的字符串$w=w_1w_2$分为$w_1$和$w_2$，从而让两者分别被两台自动机接受呢？为了解决这个问题要引入非确定性。\n非确定性 非确定性的引入 在刚刚定义的FA可以被称为确定的有穷自动机（deterministic finite automaton,DFA），它进行的是确定性计算（deterministic computation），现在要介绍的是带空移动的不确定的有穷自动机（non-deterministic finite automaton with $\\epsilon$,$\\epsilon$-NFA），这种机器是前者的推广，而在任何一点，其下一个状态可能存在若干个选择。\n首先给出一个$\\epsilon$-NFA的例子，记其为$N_1$：\n与DFA相比，这里某些状态对字母表中的某些符号产生了多个转移箭头，也有些符号没有对应的转移箭头，而这里出现了不取自于字母表的符号$\\epsilon$。一般而言，$\\epsilon$-NFA的箭头可以标记为字母表中的元素或$\\epsilon$，从一个状态可能射出0个、1个或若干个标有$\\epsilon$的箭头。\n$\\epsilon$-NFA进行运算的过程像是多线程工作，当读入一个字符对应多个转移箭头时，$\\epsilon$-NFA便会“复制”自己以进行多个方向的工作，当没有可以转移的箭头时这个$\\epsilon$-NFA的“备份”便结束工作，而遇到带有$\\epsilon$的箭头时$\\epsilon$-NFA直接“复制”一份自身进行工作，也可以借助树的结构来观察这个过程。\n以$N_1$为例，输入字符串010110：\n开始时处在状态$q_1$。 读到0，沿着转移从$q_1$到$q_1$。 读到1，沿着转移从$q_1$到$q_1,q_2,q_3$。 读到0，沿着转移从$q_1$到$q_1$，从$q_2$到$q_3$，$q_3$无法进行转移。 读到1，沿着转移从$q_1$到$q_1,q_2,q_3$，从$q_3$到$q_4$。 读到1，沿着转移从$q_1$到$q_1,q_2,q_3$，从$q_3$到$q_4$，从$q_3$到$q_4$，$q_2$无法进行转移。 读到0，沿着转移从$q_1$到$q_1$，从$q_2$到$q_3$，从$q_4$到$q_4$，$q_3$无法进行转移。 输出接受，因为存在一个NFA的“备份”能够到达接受状态$q_4$。 利用树的结构来观察这个过程如下： 非确定性的形式化定义 现在给出$\\epsilon$-NFA的形式化定义，$\\epsilon$-NFA是一个五元组$(Q,\\Sigma,\\delta,q_0,F)$：\n$Q$是一个有穷集合，称为状态集。 $\\Sigma$是一个有穷集合，称为字母表。 $\\delta:Q\\times\\Sigma_\\epsilon\\rightarrow 2^Q$，称为转移函数，其中$2^Q$表示$Q$的幂集，即$Q$的全体子集的集合，$\\Sigma_\\epsilon=\\Sigma\\cup${$\\epsilon$}。 $q_0\\in Q$是起始状态。 $F\\subseteq Q$是接受状态集。 当$\\epsilon$-NFA中不含有有$\\epsilon$的转移箭头时得到了 不确定的有穷自动机（non-deterministic finite automaton,NFA） 的定义，在此不作赘述。\n为了方便研究，引入$\\epsilon$-闭包（$\\epsilon$-Closure）的概念，记为$ECLOSE(q)$，表示经过0个或多于0个空转移到达的全部状态的集合，其递归定义如下：\n$q\\in ECLOSE(q)$（包含当前状态本身）\n$\\forall p\\in ECLOSE(q),$如果有$r\\in\\theta(p,\\epsilon)$，那么$r\\in ECLOSE(q)$。\n在$N_1$中可以发现$ECLOSE(q_0)=${$q_0$}$,ECLOSE(q_1)=${$q_1,q_2$}。\n对$\\epsilon$-闭包进行推广，状态集$S$的$\\epsilon$-闭包为：$ECLOSE(S)=\\cup_{q\\in S}ECLOSE(q)$，即一个状态集$S$的$\\epsilon$-闭包为$S$中每一个状态的$\\epsilon$-闭包的并集。\n类似于先前做的那样，也给出扩展转移函数$\\hat{\\delta}$：\n$\\hat{\\delta}$：当$w=\\epsilon$时$\\hat{\\delta}(q,w)=ECLOSE(q)$，当$w=xa$时$\\hat{\\delta}(q,w)=ECLOSE(\\cup_{p\\in\\hat{\\delta}(q,x)}\\delta(p,a))$，其中$w,x$是字符串，$a$是字符。可知机器$N$接受$w$当且仅当$\\hat{\\delta}(q_0,w)\\cap F\\neq\\varnothing$。\nDFA和ε-NFA的等价性 当两台机器识别同样的语言，则称它们是等价的，乍一看上去仿佛$\\epsilon$-NFA有着比DFA更加强大的能力，因为DFA本身便符合$\\epsilon$-NFA的定义，但是两者实际上是等价的，为此，需要找到用DFA表示$\\epsilon$-NFA的方法，这样的构造如下：\n设有$\\epsilon$-NFA：$N=(Q,\\Sigma,\\delta,q_0,F)$，其识别了语言$A$，那么可以构造一台DFA识别语言$A$：$D=(2^Q,\\Sigma,\\delta_D,ECLOSE(q_0),F_D)$，其中$\\forall S\\subseteq Q,\\forall a\\in\\Sigma,\\delta_D(S,a)=ECLOSE(\\cup_{p\\in S}\\delta(p,a))$，$F_D=${$S|S\\subseteq Q,S\\cap F\\neq\\varnothing$}。\nNFA是$\\epsilon$-NFA的特殊情形，同时DFA一定是NFA，故这三种FA都是等价的。\n知道了两者的等价性后，可以得到推论：一个语言是正则的当且仅当有一台$\\epsilon$-NFA可以识别它。\n在正则运算下的封闭性 有了关于$\\epsilon$-NFA的知识后，可以回过头来看看之前所未解决的问题，也即证明RL在正则运算下的封闭性，在此通过构造三个$\\epsilon$-NFA将这个问题解决：\n（1）正则语言在并运算下封闭：\n设有RL：$A_1,A_2$被它们对应的两个$\\epsilon$-NFA识别：$N_1=(Q_1,\\Sigma,\\delta_1,q_1,F_1),N_2=(Q_2,\\Sigma,\\delta_2,q_2,F_2)$，那么可以识别$A_1\\cup A_2$的$\\epsilon$-NFA构造为：$N=(${$q_0$}$\\cup Q_1\\cup Q_2,\\Sigma,\\delta,q_0,F_1\\cup F_2)$，其中$\\forall q\\in Q,a\\in \\Sigma_\\epsilon$\n当$q\\in Q_1$时$\\delta(q,a)=\\delta_1(q,a)$\n当$q\\in Q_2$时$\\delta(q,a)=\\delta_2(q,a)$\n当$q=q_0$且$a=\\epsilon$时$\\delta(q,a)=${$q_1,q_2$}\n当$q=q_0$且$a\\neq\\epsilon$时$\\delta(q,a)=\\varnothing$\n（2）正则语言在连接运算下封闭：\n设有RL：$A_1,A_2$被它们对应的两个$\\epsilon$-NFA识别：$N_1=(Q_1,\\Sigma,\\delta_1,q_1,F_1),N_2=(Q_2,\\Sigma,\\delta_2,q_2,F_2)$，那么可以识别$A_1\\circ A_2$的$\\epsilon$-NFA构造为：$N=(Q_1\\cup Q_2,\\Sigma,\\delta,q_1,F_2)$，其中$\\forall q\\in Q,a\\in \\Sigma_\\epsilon$\n当$q\\in Q_1$且$q\\notin F_1$时$\\delta(q,a)=\\delta_1(q,a)$\n当$q\\in F_1$且$a\\neq\\epsilon$时$\\delta(q,a)=\\delta_1(q,a)$\n当$q\\in F_1$且$a=\\epsilon$时$\\delta(q,a)=\\delta_1(q,a)\\cup${$q_2$}\n当$q\\in Q_2$时$\\delta(q,a)=\\delta_2(q,a)$ （3）正则语言在克林闭包运算下封闭：\n设有RL：$A_1$被对应的$\\epsilon$-NFA识别：$N_1=(Q_1,\\Sigma,\\delta_1,q_1,F_1)$，那么可以识别$A_1^{ * }$的$\\epsilon$-NFA构造为：$N=(${$q_0$}$\\cup Q_1,\\Sigma,\\delta,q_0,${$q_0$}$\\cup F_1)$，其中$\\forall q\\in Q,a\\in \\Sigma_\\epsilon$\n当$q\\in Q_1$且$q\\notin F_1$时$\\delta(q,a)=\\delta_1(q,a)$\n当$q\\in F_1$且$a\\neq\\epsilon$时$\\delta(q,a)=\\delta_1(q,a)$\n当$q\\in F_1$且$a=\\epsilon$时$\\delta(q,a)=\\delta_1(q,a)\\cup${$q_1$}\n当$q=q_0$且$a=\\epsilon$时$\\delta(q,a)=${$q_1$}\n当$q=q_0$且$a\\neq\\epsilon$时$\\delta(q,a)=\\varnothing$\n在其他运算下的封闭性 RL除了在这些正则运算下保持封闭，在其他运算下也有保持封闭的性质，在此选取了常用的性质进行说明：\n（1）RL在补运算下封闭：\n设有RL：$A$被对应的DFA识别：$D=(Q,\\Sigma,\\delta,q_0,F)$，那么可以识别$\\overline{L}=\\Sigma^{ * }-L$的DFA构造为$D\u0026rsquo;=(Q,\\Sigma,\\delta,q_0,Q-F)$。\n（2）RL在交运算下封闭：\n如果$L,M$是RL，考虑事实$L\\cap M=\\overline{\\overline{L}\\cup\\overline{M}}$。\n也可以通过构造自动机证明这一事实，设有RL：$A_1,A_2$被对应的两个DFA识别：$M_1=(Q_1,\\Sigma,\\delta_1,q_1,F_1),M_2=(Q_2,\\Sigma,\\delta_2,q_2,F_2)$，那么可以构造识别$A_1\\cap A_2$的DFA：$M=(Q_1\\times Q_2,\\Sigma,\\delta,(q_1,q_2),F_1\\times F_2)$。其中$\\forall (p,q)\\in Q_1\\times Q_2,\\forall a\\in\\Sigma,\\delta((p,q),a)=(\\delta_1(p,a),\\delta_2(q,a))$。\n（3）RL在差运算下封闭：\n如果$L,M$是RL，考虑事实$L-M=L\\cap\\overline{M}$。\n（4）RL在反转运算下封闭：\n设有RL：$A$被相应的DFA：$D=(Q,\\Sigma,\\delta,q_0,F)$识别，可以构造识别$A^R$的$\\epsilon$-NFA：$N=(Q,\\Sigma,\\delta\u0026rsquo;,q_R,${$q_0$}$)$，如果有$\\delta(q,a)=p$，那么作$\\delta\u0026rsquo;(p,a)=q$，同时要求$\\delta\u0026rsquo;(q_R,\\epsilon)=F$，恰好满足这两个条件即可。\n（5）正则代换：\n可以引入代换（substitution） 的概念，设有两个字母表$\\Sigma,\\Delta$，那么映射$f:\\Sigma\\rightarrow 2^{\\Delta^{ * }}$称为从$\\Sigma$到$\\Delta$的一个代换，如果对于$\\forall a\\in\\Sigma,f(a)$是$\\Delta$上的RL，则称$f$为正则代换（regular substitution）。\n可以进一步扩展$f$的定义域，首先将其定义域拓展到$\\Sigma^{ * } $上，也就是说定义字符串的代换，$f:\\Sigma^{ * }\\rightarrow 2^{\\Delta^{ * }}$：\n$f(\\epsilon)=${$\\epsilon$}。 $f(xa)=f(x)f(a)$。 再将定义域拓展到$2^{\\Sigma^{ * } }$上，也就是定义语言的代换，$f:2^{\\Sigma^{ * }}\\rightarrow 2^{\\Delta^{ * } }$： 对于$\\forall L\\subseteq\\Sigma^{ * } $，有$f(L)=\\cup_{x\\in L}f(x)$。 为了方便研究，也给出正则表达式上的正则代换： 设$\\Sigma,\\Delta$是两个字母表，映射$f:\\Sigma\\rightarrow 2^{\\Delta^{ * }}$为正则代换，那么有：\n$f(\\varnothing)=\\varnothing$。 $f(\\epsilon)=\\epsilon$。 对于$\\forall a\\in\\Sigma,f(a)$是$\\Delta$上的正则表达式 如果$r,s$是$\\Sigma$上的正则表达式，那么有:$f(r\\cup s)=f(r)\\cup f(s),f(r\\circ s)=f(r)\\circ f(s),f(r^{ * })=f(r)^{ * }$。 使用数学归纳法很容易证明：设$L$是$\\Sigma$上的一个RL，有正则代换$f:\\Sigma\\rightarrow 2^{\\Delta^{ * }}$，则$f(L)$也是RL。\n可以引入 同态（homomorphism） 的概念，设有两个字母表$\\Sigma,\\Delta$，有映射$f:\\Sigma\\rightarrow\\Delta^{ * } $。如果对于$\\forall x,y\\in\\Sigma^{ * } $有$f(xy)=f(x)f(y)$，则称$f$为从$\\Sigma$到$\\Delta^{ * } $的同态映射。\n对于$\\forall L\\subseteq\\Sigma^{ * }$，$L$的同态像$f(L)=\\cup_{x\\in L}${$f(x)$}。\n对于$\\forall w\\subseteq\\Delta^{ * } $，$w$的同态原像$f^{-1}(w)=${$x|f(x)=w且x\\in\\Sigma^{ * }$}。\n对于$\\forall L\\subseteq\\Delta^{ * } $，$L$的同态原像$f^{-1}(L)=${$x|f(x)\\in L$}。\n（6）RL在同态像运算下封闭：\n不难发现同态映射是正则代换的特例。\n（7）RL在同态原像运算下封闭：\n设有$L$是RL，有同态映射$h:\\Sigma\\rightarrow\\Delta^{ * } $，识别它的DFA：$D=(Q,\\Gamma,\\delta,q_0,F)$，那么可以构造识别$h^{-1}(A)$的DFA：$D\u0026rsquo;=(Q,\\Sigma,\\delta\u0026rsquo;,q_0,F)$，其中对$\\forall (q,a)\\in Q\\times\\Sigma$，都有$\\delta\u0026rsquo;(q,a)=\\delta(q,h(a))$。\n（8）RL在商运算下封闭:\n设$L_1,L_2\\in\\Sigma^{ * } $，如果$L_1$是RL，则$L_1/L_2$也是RL。 设有识别$L_1$的DFA：$M_1=(Q,\\Sigma,\\delta,q_0,F_1)$，那么可以构造识别$L_1/L_2$的DFA：$M_2=(Q,\\Sigma,\\delta,q_0,${$q|\\exists y\\in L_2,\\delta(q,y)\\in F$}$)$。\n必须要指出的是，这里的$L_2$可以是各种语言，故这种封闭性不是有效封闭性。\n正则表达式 正则表达式的形式化定义 正则表达式（regular expression，RE）：类似于算术中的运算存在着对应的表达式，如$5+4$，也可以使用正则运算描述语言的表达式，称为正则表达式，例如$(0\\cup 1)0^{ * }$，现在给出它的形式化定义：\n称$R$是一个正则表达式，如果$R$是：\n$a$，要求$a\\in\\Sigma$，$\\Sigma$是字母表，表示语言{$a$}。 $\\epsilon$，表示语言{$\\epsilon$}。 $\\varnothing$，表示空语言。 $(R_1\\cup R_2)$，其中$R_1,R_2$都是正则表达式，表示这两个语言作并运算得到的语言，也有写成$(R_1+R_2)$的。 $(R_1\\circ R_2)$，其中$R_1,R_2$都是正则表达式，表示这两个语言作连接运算得到的语言，在不产生混淆的情况下可以写为$(R_1R_2)$。 $(R_1)^{ * }$，其中$R_1$是正则表达式，表示这个语言作克林闭包运算得到的语言。 上述的定义是有效的、可以避免循环的，被称为归纳定义（inductive defination）。\n表达式中的括号可以被略去，如果略去括号，可以按照下述优先顺序进行运算：克林闭包，连接，并。\n正则表达式$R$所描述的语言记作$L(R)$。\n正则表达式和这里使用到的三种运算形成了Kleene代数（例如对并运算和连接运算形成了一个半环），在此指出有关正则表达式的一些代数定律：\n并运算满足交换律和结合律。 连接运算满足结合律，但不满足交换律。 $\\varnothing$是并运算的单位元，是连接运算的零元，也就是说对于正则表达式$L$始终有$\\varnothing\\cup L=L\\cup\\varnothing=L,\\varnothing\\circ L=L\\circ\\varnothing=\\varnothing$。 $\\epsilon$是连接运算的单位元，也就是说对于正则表达式$L$始终有$\\epsilon L=L\\epsilon =L$。 连接运算对并运算满足左右分配律。 并运算满足幂等律。 对任意语言$L$都有$(L^{ * })^{ * }=L^{ * }$。 $\\varnothing^{ * }=\\epsilon$。 $\\epsilon^{ * }=\\epsilon$。 对任意语言$L$都有$L^{ * }L^{ * }=L^{ * }$。 对任意语言$L,M$都有$(L\\cup M)^{ * }=(L^{ * }M^{ * })^{ * }$。 与有穷自动机的等价性 现在要说明一个正则语言一定可以用正则表达式描述，反之亦然，也就是说要证明两个命题，下面给出这两个命题的证明。\n（1）如果一个语言可以用正则表达式描述，那么它是正则的。\n可以使用归纳法证明这个结论，归纳基础如下：\n归纳递推如下：\n这样的三种构造恰好可以与三种正则运算相对应\n那么找到了将正则表达式转化为对应的$\\epsilon$-NFA的方法，证明完毕。\n（2）如果一个语言是正则的，那么可以用正则表达式描述它。\n首先，给出一种方法证明这个问题，设有DFA：$M=(\\cup_{i=1}^n${$q_i$}$,\\Sigma,\\delta,q_1,F)$\n令$R^k_{ij}=${$x|\\hat{\\delta}(q_i,x)=q_j,而且对于x的任意前缀y(y\\neq x,y\\neq\\epsilon),如果\\hat{\\delta}(q_i,y)=q_j,则l\\leq k$}\n也就是说$R^k_{ij}$是所有那些将DFA从给定状态$q_i$引导到状态$q_j$并且中途不经过下标大于$k$的状态的那些字符串，可以发现有递归关系：\n如果$i\\neq j$那么有$R^0_{ij}=${$a|\\hat{\\delta}(q_i,a)=q_j$}，如果$i=j$那么有$R^0_{ij}=${$a|\\hat{\\delta}(q_i,a)=q_j$}$\\cup${$\\epsilon$}。\n$R^k_{ij}=R^{k-1}{ik}(R^{k-1}{kk})^{ * } R^{k-1}{kj}\\cup R^{k-1}{ij}$\n显然有$L(M)=\\cup_{q_j\\in F}R^n_{1f}$。\n上述这种做法不太直观，为此可以通过引入一个新的自动机：广义非确定型有穷自动机（generalized nondeterministic finite automaton，GNFA） 来解决这个问题，下面给出一个例子对这种自动机进行说明：\n可以发现GNFA的转移箭头可以用任何正则表达式作标号，而不是只能用字母表的成员或者$\\epsilon$作为标号。相较于NFA一次最多只能读入一个符号，GNFA可以一次读入一段输入符号，沿着连接两个状态的箭头移动，而这段输入符号正好是那个转移箭头上的正则表达式所描述的一个字符串。\n为了方便，对GNFA作出一些特殊形式的条件要求：\n起始状态有射到其他每一个状态的箭头，但是没有从任何其他状态射入的箭头。 有唯一的接受状态，并且它有从其他每一个状态射入的箭头，但是没有射到任何其他状态的箭头。此外，这个接受状态和起始状态不同。 除了起始状态和接受状态之外，每一个状态到自身和其他每一个状态都有一个箭头。 把DFA转换成GNFA是容易的，只需要新添加初始状态和接受状态，新初始状态到原初始状态有一个$\\epsilon$箭头，每一个原接受状态到新接受状态有一个$\\epsilon$箭头，把有多个标记的箭头换成并运算的正则表达式形式，最后将需要补上箭头的原先无箭头的地方补上$\\varnothing$的箭头即可，因为这个箭头始终无法被使用。\n现在给出GNFA的形式化定义：\n广义非确定型有穷自动机是一个5元组$(Q,\\Sigma,\\delta,q_{start},q_{accept})$\n$Q$是一个有穷的状态集。 $\\Sigma$是一个有穷的字母表。 $\\delta:(Q-${$q_{accept}$}$)\\times(Q-${$q_{start}$}$)\\rightarrow \\mathcal{R} $，即转移函数。 $q_{start}\\in Q$是起始状态。 $q_{accept}$是接受状态。 如果字符串$w=w_1w_2\\cdots w_k$，其中的每一个$w_i\\in\\Sigma^{ * }$，并且存在状态序列$q_0,q_1,\\cdots,q_k$使得\n$q_0=q_{start}$是起始状态。 $q_k=q_{accept}$是接受状态。 对于每一个$i,w_i\\in L(R_i)$，其中$R_i=\\delta(q_{i-1},q_i)$，即$R_i$是从$q_{i-1}$到$q_i$的箭头上的正则表达式。 那么称这个GNFA接受字符串$w$。\n而对于GNFA，存在一种算法可以不断减少它所拥有的状态数目，最后将会剩下它的初始状态和接受状态，同时也只有一个从初始状态到接受状态的箭头，这个箭头的标记就说等价的正则表达式，现在给出这样一个算法CONVERT(G)，它通过每轮减少一个状态的方式实现了状态的缩减：\n设$k$为$G$的状态数，如果$k=2$则$G$一定是一个起始状态、一个接受状态和连接两者的箭头组成，返回箭头上标记的正则表达式$R$。\n如果$k\u0026gt;2$，则任取一个状态$q_{rip}\\in Q-${$q_{start},q_{accept}$}，并且令一个新的GNFA：$G\u0026rsquo;=(Q\u0026rsquo;,\\Sigma,\\delta\u0026rsquo;,q_{start},q_{accept})$，其中$Q\u0026rsquo;=Q-${$q_{rip}$}，而对于每一个$q_i\\in Q\u0026rsquo;-${$q_{accept}$}$,q_j\\in Q\u0026rsquo;-${$q_{start}$}，令$\\delta\u0026rsquo;(q_i,q_j)=(R_1)(R_2)^{ * }(R_3)\\cup(R_4)$，其中$R_1=\\delta(q_i,q_{rip}),R_2=\\delta(q_{rip},q_{rip}),R_3=\\delta(q_{rip},q_j),R_4=\\delta(q_i,q_j)$，计算CONVERT(G)并返回这个值。\n实际上当$k\u0026gt;2$时CONVERT(G)所做的事情是将某个状态去掉，用能够经过这个状态的路径对应的正则表达式取代了它，从而不影响整个状态机的运行。\n可以证明对于任意的GNFA G，都有CONVERT(G)等价于G，也就是说所有GNFA都有与其等价的一个含有两个状态的GNFA。证明了任何RL都可以用正则表达式来描述它。\nMyhill-Nerode定理和DFA的极小化 Myhill-Nerode定理 知道任何GNFA都可以被化简为只有两个状态的形式，但是这不意味着DFA和$\\epsilon$-NFA可以被化简为只有两个状态的形式，实际上总能找到这样的语言$L_n$使得能够接受它的DFA和$\\epsilon$-NFA拥有至少$n$个状态（考虑只含有一个字符串的形如{$0^k$}的语言）。\n但是可以对这些自动机进行化简，在此给出减少DFA的状态以化简它的方法。\n设DFA：$M=(Q,\\Sigma,\\delta,q_0,F)$，由$M$确定的$\\Sigma^{ * } $上的关系$R_M$定义为：对于$\\forall x,y\\in\\Sigma^{ * } $都有$xR_My\\Leftrightarrow\\hat{\\delta}(q_0,x)=\\hat{\\delta}(q_0,y)$。\n设$L\\subseteq\\Sigma^{ * } $，$L$确定的$\\Sigma^{ * } $上的关系$R_L$定义为：对于$\\forall x,y\\in\\Sigma^{ * } $，$xR_Ly\\Leftrightarrow(对\\forall z\\in\\Sigma^{ * } ,xz\\in L\\Leftrightarrow yz\\in L)$。可以证明$xR_My\\Rightarrow xR_{L(M)}y$，但是反之不成立。\n设$R$是$\\Sigma^{ * } $上的等价关系，对于$\\forall x,y\\in\\Sigma^{ * } $，如果$xRy$则$\\forall z\\in\\Sigma^{ * } $都有$xzRyz$，那么称$R$是右不变的（right invariant） 等价关系。可以证明上面定义的两个关系都是右不变的等价关系。\n设$R$是$\\Sigma^{ * } $上的等价关系，则称$|\\Sigma^{ * } /R|$是$R$关于$\\Sigma^{ * } $的指数（index）（也就是一个集合的等价类的个数），简称为$R$的指数。$\\Sigma^{ * } $关于$R$的一个等价类，也就是$\\Sigma^{ * } /R$的任意一个元素，简称为$R$的一个等价类。\n由于$xR_My\\Rightarrow xR_{L(M)}y$，可以证明对于任意DFA：$M=(Q,\\Sigma,\\delta,q_0,F)$都有$|\\Sigma^{ * } /R_{L(M)}|\\leq|\\Sigma^{ * } /R_M|\\leq|Q|$。同时可以看出$R_M$对$\\Sigma^{ * } $的划分比$R_{L(M)}$更加“细”，$R_M$可以将$R_{L(M)}$所划分的等价类进一步划分，称$R_M$是$R_{L(M)}$的加细（refinement）。\nMyhill-Nerode定理：有三个等价的命题：\n$L\\subseteq\\Sigma^{ * } $是RL。 $L$是$\\Sigma^{ * } $上的某个具有有穷指数的右不变等价关系$R$的某些等价类的并。 $R_L$具有有穷指数。 证明：不妨证明从（1）到（2）、从（2）到（3）、从（3）到（1）都是成立的。\n从（1）到（2）：\n由于$L$是RL，存在识别它的DFA：$M=(Q,\\Sigma,\\delta,q_0,F)$，由于$R_M$是$\\Sigma^{ * } $上的右不变的等价关系，同时$|\\Sigma^{ * } |\\leq|Q|$，故$R_M$有有穷指数，$R_M$即为满足要求的一个右不变等价关系。\n从（2）到（3）：\n设$L$是$\\Sigma^{ * } $上具有有穷指数的右不变等价关系$R$的某些等价类的并，不妨证明$R$是$R_L$的加细，也就是证明$\\forall x,y\\in\\Sigma^{ * } ,xRy\\Rightarrow xR_Ly$。由于$R$的右不变性，可知对于$\\forall z\\in\\Sigma^{ * } $都有$xzRyz$，而$L$又是$R$的某些等价类的并，所以$xz\\in L\\Leftrightarrow yz\\in L$，也就是说$xR_Ly$。\n从（3）到（1）：\n设$R_L$有有穷指数，构造DFA：$M\u0026rsquo;=(\\Sigma^{ * } /R_L,\\Sigma,\\delta\u0026rsquo;,[\\epsilon],${$[x]|x\\in L$}$)$，其中$[\\epsilon]$表示$\\epsilon$所在的等价类所对应的状态，$[x]$表示$x$所在的等价类所对应的状态。对于任意$([x],a)\\in(\\Sigma^{ * } /R_L)\\times\\Sigma$都有$\\delta\u0026rsquo;([x],a)=[xa]$，那么有$L(M\u0026rsquo;)=L$，这里构造的$M\u0026rsquo;$称为最小DFA。\n由Myhill-Nerode定理可以得到两个推论，在此不对两个推论作出证明：\n$L$是RL，识别它的DFA：$M=(Q,\\Sigma,\\delta,q_0,F)$，则$|\\Sigma^{ * } /R_L|\\leq|Q|$。\n$L$是RL，在同构意义下，接受$L$的最小DFA是唯一的。\n定理得到证明，这个定理可以用于证明一个语言是RL，也可以证明一个语言不是RL。 例如语言{$0^n1^n|n\\geq 0$}，可以发现它的等价关系$R_L$的指数是无穷的，因此$L$不是RL。\nDFA的极小化 设DFA：$M=(Q,\\Sigma,\\delta,q_0,F)$，如果$\\exists x\\in\\Sigma^{ * } $使得$Q$中的两个状态$q$和$p$，在$\\delta(q,x)\\in F$和$\\delta(p,x)\\in F$中有且仅有一个成立，则称$q$和$p$是可以区分的（distinguishable）；否则称$q$和$p$等价，记作$q\\equiv p$。\n为了让DFA极小化，实际上只需要找到一个DFA中全部的可区分状态对，再将不可区分的状态对合并为一个状态，同时保留被合并的状态到其他的状态的转移箭头，同时去掉DFA中的不可达状态，就得到了最小DFA。\n正则语言的泵引理 正则语言的泵引理是如此的重要和有影响力，以至于人们一直将其称为引理而未改称其为定理。正则语言的泵引理是它的一种特殊性质：语言中的所有字符串只要它的长度不小于某个特定值————泵长度（pumping length），就可以被“抽取”，也就是说字符串中有一段字串，无论字串重复多少次，得到的字符串依旧在这个语言里。下面给出其形式化表述和相应证明：\n泵引理（pumping lemma）：若$L$是一个RL，则存在一个正整数$N$，对$w\\in L$，只要$|w|\u0026gt;N$，就可以将$w$分为三部分$w=xyz$使得：\n$y\\neq\\epsilon$ $|xy|\\leq N$ $\\forall k\\geq 0,xy^kz\\in L$ 证明：设$M=(Q,\\Sigma,\\delta,q_0,F)$识别语言$L$，其中$|Q|=N$，在读入长度为$m$的串时（$m\\geq N$），它所经过的状态有$q_0,q_1,\\cdots,q_m$，根据鸽巢原理，必然有两个状态是相同的，不妨设$q_i=q_j,0\\leq i\u0026lt; j\\leq N$，那么可以划分$w$为$x=a_1a_2 \\cdots a_i,y=a_{i+1}\\cdots a_j,z=a_{i+1} \\cdots a_M$，找到了这样一种划分符合泵引理的要求，证毕。\n有了泵引理后，可以发现并不是所有语言都是RL，例如{$0^n1^n|n\\geq 0$}这样一个语言便不是一个RL，它不满足泵引理的条件。\n但是值得注意的是泵引理是某个语言是RL的必要条件而不是充分条件，例如{$0^i1^j2^k|i,j,k\\geq 0,并且若i=1,则j=k$}，记这个语言为$F$，考虑语言$L=L(01^{ * }2^{ * })$，那么$L\\cap F=${$01^n2^n|n\\geq 0$}，很明显后者不是RL，由于RL在交运算下封闭，所以$F$不是RL，但它满足泵引理。\n八、正则语言的判定性质 任何语言都有3个经典的判定问题：\n以某种形式化模型描述的语言是否为空？是否无穷？ 某个特定的串$w$是否属于所描述的语言？ 以两种方式描述的语言，是否是相同的？ 下面给出了这三个问题的相关回答：\n设DFA：$M=(Q,\\Sigma,\\delta,q_0,F)$\n那么$L=L(M)$非空的充分必要条件是：存在$x\\in\\Sigma^{ * } ,|x|\u0026lt;|Q|,\\hat{\\delta}(q_0,x)\\in F$。\n$L=L(M)$无穷的充分必要条件是：存在$x\\in\\Sigma^{ * } ,|Q|\\leq|x|\u0026lt;2|Q|,\\hat{\\delta}(q_0,x)\\in F$。\n设DFA：$M_1=(Q_1,\\Sigma,\\delta_1,q_1,F_1),M_2=(Q_2,\\Sigma,\\delta_2,q_2,F_2)$，则存在判断$L(M_1),L(M_2)$是否相同的算法。\n记$L_1=L(M_1),L_2=L(M_2)$，那么$(L_1\\cap\\overline{L_2})\\cup(\\overline{L_1}\\cap L_2)$是正则的，可以被某个有穷自动机$M_3$接受，而$M_3$接受某个串当且仅当$L_1\\neq L_2$，已经证明了存在算法判断$L(M_3)$是否为空，得证。\n设$L$是字母表$\\Sigma$上的RL，对于任意的$w\\in\\Sigma^{ * } $，存在判定$w$是否为$L$的句子的算法。\n由于$L$是RL，故存在DFA使得它接受这个语言。\n","date":"2024-06-20T00:00:00Z","image":"https://0x3a0x29.github.io/p/regular/image_hu14408693445100236650.png","permalink":"https://0x3a0x29.github.io/p/regular/","title":"有穷自动机FA及正则语言RL"},{"content":"FC及其相关定理 前言 水平有限，存在的错误和不足请大家指正。\n本篇所述皆来自于笔者于23年学校开设的《数理逻辑》课程中讲解内容。\n在先前已经给出了命题逻辑的相关介绍，但是命题逻辑存在着不可避免的缺陷，在命题逻辑中我们将原子命题看成是不可再分的基本单位，这就体现不出命题中研究对象的特性以及研究对象之间的逻辑关系，而有些推理的正确性依赖于命题的内部结构，我们以著名的苏格拉底三段论为例：\n所有的人都是要死的。 苏格拉底是人。 所以苏格拉底是要死的。 我们引入三个命题变元$P,Q,R$，我们可以写出推理的命题形式：$P\\wedge Q\\rightarrow R$，但是很明显这个公式并非永真式，我们不能看出原来正确的推理。 为此，我们必须引入谓词逻辑，以帮助我们研究相关的推理形式和规律。\n基础知识 部分基础概念如定理、证明、演绎等在此不作赘述。\n个体词：用于表示研究对象的词，分为个体常元（通常用字母表靠前的小写字母表示）和个体变元（通常用字母表靠后的小写字母表示）。\n谓词：表示研究对象的性质（一个个体变元）或研究对象（多个个体变元）之间关系的词（通常用大写字母来表示）。那么我们可以得到n元谓词的概念，为了增加可读性，我们可以写作$P^{(n)}(t_1,t_2,\\cdots,t_n)$。\n个体域（论域）：个体变元的取值范围。\n函词：用于描述从一个论域到另一个论域的映射，不难发现函词的定义类似于函数的定义，常用小写字母或小写英文单词来表示，对于含有n个个体变元的函词常记作$f^{(n)}$，为了增加可读性，我们可以写作$f^{(n)}(t_1,t_2,\\cdots,t_n)$。\n量词：用于限制个体词的数量，分为全称量词和存在量词。\n全称量词$\\forall$：表任意的，从量上表示“所有的”。 特称量词$\\exists$：表存在的，从量上表示“至少有一个”。 在量词之间显然有着这样的对应关系：\n（1）$\\forall xP(x)\\Leftrightarrow\\neg\\exists x\\neg P(x)$\n（2）$\\exists xP(x)\\Leftrightarrow\\neg\\forall x\\neg P(x)$\n（3）$\\neg\\forall xP(x)\\Leftrightarrow\\exists x\\neg P(x)$\n（4）$\\neg\\exists xP(x)\\Leftrightarrow\\forall x\\neg P(x)$\n项：类似于之前命题公式的定义，现在给出项的定义：\n（1）个体变元和个体常元是项。\n（2）若$f^{(n)}$是一个n元函词，且$t_1,t_2\\cdots,t_n$是项，那么$f^{(n)}(t_1,t_2,\\cdots,t_n)$是项。\n（3）有限次的使用（1）（2）进行复合得到的结果也是项。\n在此定义的项的概念在我们将介绍的FC中也是同理的。\n约束变元：受量词约束的个体变元。\n自由变元：不受量词约束的个体变元。\n例如$\\forall x(P(x,y)\\rightarrow Q(x,y))\\rightarrow R(x,y)$中，记前件为$A$，记后件为$B$。在前件中存在指导变元$x$，故$x$为约束变元，在后件中$x$为自由变元，在前件和后件中$y$均为自由变元。\n辖域：量词所约束的范围。\n合式公式：合式公式也称谓词公式，或简称公式，定义如下：\n（1）不含联结词的单个谓词即原子谓词公式是合式公式。\n（2）若$A$为合式公式，那么$\\neg A$也是合式公式。\n（3）若$A,B$为合式公式，且无变元$x$在$A,B$中的一个是约束的，而另一个是自由的，则$A\\wedge B,A\\vee B,A\\rightarrow B,A\\leftrightarrow B$都是合式公式。\n（4）若$A$为合式公式，而$x$在$A$中为自由变元，则$\\forall xP(x),\\exists xP(X)$均为合式公式。\n（5）由（1）~（4）有限次复合所形成的公式均为合式公式。\n在此定义的公式的概念在我们将介绍的FC中也是同理的。\n子公式：如果公式$A$为形如$wBw\u0026rsquo;$的符号串，其中$w,w\u0026rsquo;$都是符号串，$B$是公式，那么$B$就称为公式$A$的子公式。当$w,w\u0026rsquo;$中存在非空串时我们称$B$为真子公式。\n易名规则：将量词辖域中出现的某个约束变元改为另一个在该辖域中未出现的个体变元，公式中的其余部分保持不变，改名后的公式称为原公式的改名式，例如$\\forall xP(x)$的改名式可以是$\\forall yP(x)^x_y$。在使用易名规则时需要注意待改名的变元在其辖域内的此变元都应该被改掉，而其余的保持不变，另外新引进的变元符不应该在该量词的辖域内出现。\n可代入：设$v$为谓词公式$A$中的自由变元，且项$t$中不含$A$的约束变元符（若有可以使用易名规则），则称项$t$对$v$是可代入的。\n例如$A=\\forall v_1P(v_1,v_2)$中，若$t$不含约束变元$v$的项，那么$t$对$v_2$是可代入的。若$t=f(v_1)$，其中$f$为函词，那么$t$对$v_2$是不可代入的。\n代入：对公式$A$中的自由变元$v$的所有自由出现都换为项$t$（必须是可代入的），记为$A^v_t$。若$A$中无$v$的出现则$A^v_t=A$。值得注意的是：我们使用记号$A^{v_1,v_2,\\cdots,v_n}{t_1,t_2,\\cdots,t_n}$表示对$A$的变元$v_1,v_2,\\cdots,v_n$同时做代入，即将$v_i$代为$t_i$，而不同于$(\\cdots((A^{v_1}{t_1})^{v_2}{t_2})^{v_3}{t_3}\\cdots)^{v_n}_{t_n}$。\n全称化：设$v_1,v_2,\\cdots,v_n$为公式$A$中的自由变元，则公式$\\forall v_{i_1}\\forall v_{i_2}\\cdots\\forall v_{i_r}A$称为$A$的全称化，其中$1\\leq i_1,i_2,\\cdots,i_r\\leq n,1\\leq r\\leq n$。当$r=n$时即为$A$的全称封闭式。\n有了这些基础知识后，我们便可以将自然语句形式化，例如：\n命题“过平面上两个不同点有且仅有一条直线通过”，令：\n谓词$D(x)$表示：$x$为平面上的点\n谓词$G(x)$表示：$x$为平面上的直线\n谓词$L(x,y,z)$表示：$z$通过$x,y$\n谓词$E(x,y)$表示：$x$与$y$相等\n那么我们可以将语句形式化为：\n$\\forall x\\forall y(D(x)\\wedge D(y)\\wedge\\neg E(x,y)\\rightarrow \\exists z(G(z)\\wedge L(x,y,z)\\wedge\\forall u(G(u)\\wedge L(x,y,u)\\rightarrow E(u,z))))$\n一阶谓词形式系统的语义 个体常元、变元、项、函词、谓词等属于语法范畴的概念，它们只是一些字符串，并不具备实际意义。为了讨论谓词演算公式的真值，就需要对函词、谓词进行指称，对个体常元、变元取值的指派，即赋予它们一定的意义。\n在一阶谓词演算系统中，证明和推演只是公式符号组合的形式变糊，并未考虑到其语义，但是建立一个形式系统正是为了研究正确的逻辑推理形式及其规律，为此，在予以解释后，其中的公理和定理应当是逻辑规律的反映。\n由于相较于命题逻辑我们引入了谓词、函词、量词等符号，对谓词公式的解释会更加复杂，其语义解释通常是一个数学结构，包括论域$D$及对常元、函词、谓词进行指称的解释$I$，我们得到了一个结构$U=\u0026lt; D,I \u0026gt;$，全体结构的集合记为$T$（这样的结构通常称为$Tarski$语义类）。\n解释I的组成 一个解释就是一个映射$I$，它指称常元、函词和谓词为：\n（1）对任一常元$a$指定为论域$D$的一个个体，记为$I(a)$，简记为$\\overline{a}$。\n（2）对每一n元函词$f^{(n)}$指定为$D$上的一个n元函数，记为$I(f^{(n)})$，简记为$\\overline{f}^{(n)}$。\n（3）对每一n元谓词$P^{(n)}$指定为$D$上的一个n元关系，记为$I(P^{(n)})$，简记为$\\overline{P}^{(n)}$。\n指派 一阶谓词演算中的指派是对个体变元指定为论域$D$中的个体作为其取值，即为映射$s:${$v_1,v_2,\\cdots$}$\\rightarrow D$。即对任一变元$v_i,s(v_i)\\in D$。\n指派$s$可以扩展为从项集合到个体域的映射$\\overline{s}$：对于任意的项$t$，\n（1）$\\overline{s}(t)=s(v)$，当$t$为变元$v$时。\n（2）$\\overline{s}(t)=\\overline{a}$，当$t$为常元$a$时。\n（3）$\\overline{s}(t)=\\overline{f}^{(n)}(\\overline{s}(t_1),\\overline{s}(t_2),\\cdots,\\overline{s}(t_n))$，当$t$为n元函词$f^{(n)}(t_1,t_2,\\cdots,t_n)$时。\n不难发现指派$s$域解释$I$是相互独立的，但是指派$\\overline{s}$却是依赖于解释$I$的。\n有了结构$U=\u0026lt; D,I \u0026gt;$及指派$s$，于是对公式$A$在结构$U=\u0026lt; D,I \u0026gt;$及指派$s$下取值为真记为$\\models_UA[s]$，反之记为$\\nvDash_UA[s]$。而$\\models_UA$则表示在结构$U$中对一切可能的指派$s$，公式$A$皆为真；而$\\models A$或者$\\models_TA$表示公式$A$在一切结构$U$中均为真，即$A$永真。\n$\\models_UA[s]$的严格定义 除了解释和指派，我们还需要对量词和联结词的意义作出规定，为此我们给出递归定义来明确$\\models_UA[s]$的严格定义。\n（1）当$A$为原子公式$P^{(n)}(t_1,\\cdots,t_n)$时$\\models_UA[s]$当且仅当$\u0026lt; \\overline{s}(t_1),\\cdots,\\overline{s}(t_n) \u0026gt;\\in\\overline{P}^{(n)}$，即此时n元谓词所描述的n元关系成立。\n（2）当$A$为公式$\\neg B$时$\\models_UA[s]$当且仅当$\\nvDash_UB[s]$。\n（3）当$A$为公式$B\\rightarrow C$时$\\models_UA[s]$当且仅当$\\nvDash_UB[s]$或$\\models_UC[s]$。\n（4）当$A$为公式$\\forall vB$时$\\models_UA[s]$当且仅当对每一个$d\\in D$都有$\\models_UB[s(v|d)]$，其中指派$s(v|d)$表示除了对变元$v$用指定元素$d$赋值外，对其他变元的指派与$s$相同。\n当我们使用联结词$\\vee,\\wedge$和存在量词$\\exists$时可以补充：\n（1）$\\models_UB\\vee C[s]$当且仅当$\\models_UB[s]$或$\\models_UC[s]$。\n（2）$\\models_UB\\wedge C[s]$当且仅当$\\models_UB[s]$且$\\models_UC[s]$。\n（3）$\\models_U\\exists vB[s]$当且仅当存在$d\\in D$使得$\\models_UB[s(v|d)]$。\n一阶谓词演算形式系统FC的简单介绍 一阶谓词演算形式系统FC（First order predicate Calculus）是一种形式系统，我们先简单介绍一下FC的组成部分：\n字母表$\\Sigma=L_v\\cup L_a\\cup L_f\\cup L_p\\cup L_l$，其中$L_v$即个体变元，$L_a$即个体常元，$L_f$即各种函词，$L_p$即各种谓词，$L_l$包括了真值联结词$\\rightarrow,\\neg$，量词$\\forall$和括号$(,)$。\n（1）在这里其他的联结词和存在量词$\\exists$都被视作是缩写符号。\n（2）这里的介绍中未引入等词$=$。\n（3）$L_f=\\varnothing$时称之为纯谓词演算系统。\n（4）如果我们引入0元谓词符号，那么实际上我们就得到了PC，故可以将PC视作FC的子系统，在PC中成立的定理可以迁移到FC中。\n形式规则：上文提到的合式公式的定义\n公理：设$A,B,C$为代表FC中任意公式的语法变元，$v$为任意变元，$t$为任意项，那么FC中有六个公理模式 $A1:A\\rightarrow (B\\rightarrow A)$ $A2:(A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$ $A3:(\\neg A\\rightarrow\\neg B)\\rightarrow (B\\rightarrow A)$ $A4:\\forall vA\\rightarrow A^v_t$，若$t$对$A$中的变元$v$可代入 $A5:\\forall v(A\\rightarrow B)\\rightarrow(\\forall vA\\rightarrow\\forall vB)$ $A6:A\\rightarrow\\forall vA$，若$v$在$A$中无自由出现 FC的公理包含上述六个公理模式和他们对应的全称化，同时后面的3个公理也是永真式，在此不作证明。\n推理规则：同PC中的规则$r_{mp}$：即若有$A$和$A\\rightarrow B$成立，那么$B$也成立，形式化的推理序列为：$A,A\\rightarrow B,B$。 可以记作$\\displaystyle{\\frac{A,A\\rightarrow B}{B}}$\nFC是完备的，也就是说所有永真式均为FC的定理，$G\\ddot{o}del$首先发现并证明了这一事实，即$G\\ddot{o}del$完备性定理。\nFC中的基本定理 FC的定理 下列总结了FC中12个基本定理，并给出了部分证明：\n$Th1$：对于FC中的任何公式$A$和变元$v$，$\\vdash_{FC}\\forall vA\\rightarrow A$\n$\\forall vA\\rightarrow A^v_v$,$A4$，后者即$A$ $Th2$：对于FC中的任何公式$A$和变元$v$，$\\vdash_{FC}A\\rightarrow\\neg\\forall v\\neg A$，即$\\vdash_{FC}A\\rightarrow\\exists vA$\n$\\forall v\\neg A\\rightarrow\\neg A$,$A4$ $(\\forall v\\neg A\\rightarrow\\neg A)\\rightarrow(A\\rightarrow\\neg\\forall v\\neg A)$,$PC$中的定理 $A\\rightarrow\\neg\\forall v\\neg A$,$r_{mp}(1)(2)$ $Th3$：对于FC中的任何公式$A$和变元$v$，$\\vdash_{FC}\\forall vA\\rightarrow\\exists vA$\n$\\forall vA\\rightarrow A$,$Th1$ $A\\rightarrow\\exists vA$,$Th2$ $\\forall vA\\rightarrow\\exists vA$,三段论 $Th4$：（普化定理/全称推广定理）对于FC中的任何公式$A$和变元$v$，如果$\\vdash_{FC}A$，那么$\\vdash_{FC}\\forall vA$ 需要注意的是$\\vdash_{FC}A\\rightarrow\\forall vA$并不一定成立，故在$A6$中我们作出了额外的要求：$v$在$A$中无自由出现。\n证明：设$A_1,A_2,\\cdots,A_n(=A)$是FC中公式$A$的证明序列，对证明的长度n使用归纳法。 （1）当n=1时，$A$只能是公理。若$v$在$A$中自由出现，那么$\\forall vA$也是公理；若$v$不在$A$中自由出现，则$A\\rightarrow\\forall vA$为公理，由$r_{mp}$知$\\forall vA$为公理。 （2）当n\u0026gt;1时，若$A$为公理，仿照（1）的证明可知$\\forall vA$为定理。若$A_n$为$A_j(i\u0026lt; n)$，则由归纳假设可知$\\forall vA_j=\\forall vA$为定理。若$A_n$是由$A_i,A_j$通过$r_{mp}$推得，不妨设$A_j=A_i\\rightarrow A$，则由归纳假设$\\forall vA_i,\\forall v(A_i\\rightarrow A)$都是定理。再由公理$\\forall v(A_i\\rightarrow A)\\rightarrow(\\forall vA_i\\rightarrow\\forall vA)$知$\\forall vA_i\\rightarrow\\forall vA$为定理，使用$r_{mp}$则知$\\forall vA$为定理。\n$Th5$：对于FC中的任何公式集合$\\Gamma$，公式$A$和不在$\\Gamma$的任意公式中自由出现的变元$v$，对$Th4$进行推广，得到：如果$\\Gamma\\vdash_{FC}A$，那么$\\Gamma\\vdash_{FC}\\forall vA$。\n证明：设$A_1,A_2,\\cdots,A_n(=A)$是FC中公式$A$的演绎序列，对证明的长度n使用归纳法。 （1）当n=1时，若$A$是公理。若$v$在$A$中自由出现，那么$\\forall vA$也是公理；若$v$不在$A$中自由出现，则$A\\rightarrow\\forall vA$为公理，由$r_{mp}$知$\\forall vA$为公理。于是当$A$为公理时，都有$\\Gamma\\vdash\\forall vA$。若$A\\in\\Gamma$，则$v$不在$A$中自由出现，从而$A\\rightarrow\\forall vA$为公理，从而由$r_{mp}$知$\\Gamma\\vdash\\forall vA$。 （2）当n\u0026gt;1时，若$A$为公理或者$A\\in\\Gamma$，仿照（1）的证明可知$\\forall vA$为定理。若$A_n$为$A_j(i\u0026lt; n)$，则由归纳假设可知$\\forall vA_j=\\forall vA$为定理。若$A_n$是由$A_i,A_j$通过$r_{mp}$推得，不妨设$A_j=A_i\\rightarrow A$，则由归纳假设$\\forall vA_i,\\forall v(A_i\\rightarrow A)$都是定理。再由公理$\\forall v(A_i\\rightarrow A)\\rightarrow(\\forall vA_i\\rightarrow\\forall vA)$知$\\forall vA_i\\rightarrow\\forall vA$为定理，使用$r_{mp}$则知$\\forall vA$为定理。\n$Th6$：（演绎定理）在FC中演绎定理也成立，对于FC中任何公式集合$\\Gamma$和FC中的任意两个公式$A,B$，那么$\\Gamma;A\\vdash_{FC}B$当且仅当$\\Gamma\\vdash_{FC}A\\rightarrow B$。\n证明：类似于在PC中演绎定理的证明，在此不作说明。\n$Th7$：设$\\Gamma$为FC中的任一公式集合，$A,B$为FC中任意两个公式，$\\Gamma;A\\vdash_{FC}\\neg B$当且仅当$\\Gamma;B\\vdash_{FC}\\neg A$。\n$\\Gamma;A\\vdash\\neg B$ $\\Gamma\\vdash A\\rightarrow\\neg B$,$Th6$ $\\Gamma\\vdash(A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg A)$,$PC$中的定理 $\\Gamma\\vdash B\\rightarrow\\neg A$,$r_{mp}(2)(3)$ $\\Gamma;B\\vdash\\neg A$,$Th6$ $Th8$：（反证法）如果FC中的公式集合$\\Gamma\\cup${$A$}是不一致的，则$\\Gamma\\vdash_{FC}\\neg A$。\n证明：由于$\\Gamma\\cup${$A$}不一致，则存在公式$B$使得$\\Gamma;A\\vdash B$和$\\Gamma;A\\vdash\\neg B$。由于$\\neg B\\rightarrow(B\\rightarrow\\neg A)$为定理，所以$\\Gamma;A\\vdash\\neg A$，由演绎定理得$\\Gamma\\vdash A\\rightarrow\\neg A$，又因为$(A\\rightarrow\\neg A)\\rightarrow\\neg A$为定理，从而$\\Gamma\\vdash\\neg A$。\n$Th9$：设$\\Gamma$为FC中的任一公式集合，$A,B$为FC中的任意两个公式，并且变元$v$不在$\\Gamma$的任何公式里面自由出现，那么$\\Gamma;A\\vdash_{FC}B$蕴含$\\Gamma;\\forall vA\\vdash_{FC}B$和$\\Gamma;\\forall vA\\vdash_{FC}\\forall vB$。\n$\\Gamma;A\\vdash B$ $\\Gamma\\vdash A\\rightarrow B$,$Th6$ $\\Gamma\\vdash\\forall v(A\\rightarrow B)$,$Th4$ $\\Gamma\\vdash\\forall v(A\\rightarrow B)\\rightarrow(\\forall vA\\rightarrow\\forall vB)$,$A5$ $\\Gamma\\vdash\\forall vA\\rightarrow\\forall vB$,$r_{mp}(3)(4)$ $\\Gamma;\\forall vA\\vdash\\forall vB$,$Th6$ $\\Gamma;\\forall vA\\vdash B$,$Th1$ $Th10$：（存在消除）设$\\Gamma$为FC中的任一公式集合，$A,B$为FC中的任意两个公式，并且变元$v$不在$\\Gamma$的任何公式以及公式$B$里面自由出现，那么由$\\Gamma\\vdash_{FC}\\exists vA$以及$\\Gamma;A\\vdash_{FC}B$可以推出$\\Gamma\\vdash_{FC}B$。\n$\\Gamma;A\\vdash B$ $\\Gamma\\vdash A\\rightarrow B$ $\\Gamma\\vdash(A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow A)$,$PC$中的定理 $\\Gamma\\vdash\\neg B\\rightarrow\\neg A$,$r_{mp}(2)(3)$ $\\Gamma\\vdash;\\neg B\\vdash\\neg A$ $\\Gamma;\\neg B\\vdash\\forall v\\neg A$,$Th2$ $\\Gamma\\vdash\\neg B\\rightarrow\\forall v\\neg A$ $\\Gamma\\vdash(\\neg B\\rightarrow\\forall v\\neg A)\\rightarrow(\\neg\\forall v\\neg A\\rightarrow B)$,$PC$中的定理 $\\Gamma\\vdash\\neg\\forall v\\neg A\\rightarrow B$,$r_{mp}(7)(8)$ $\\Gamma\\vdash\\exists vA\\rightarrow B$ $\\Gamma\\vdash\\exists vA$ $\\Gamma\\vdash B$,$r_{mp}(10)(11)$ $Th11$：（替换原理）设$A,B$为FC的公式，且满足$A\\vdash\\dashv_{FC}B$，$A$是$C$的子公式，$D$是将$C$中$A$的若干出现换为公式$B$得到的公式，则$C\\vdash\\dashv_{FC}D$。\n证明：略\n$Th12$：（改名定理）在FC中若$A\u0026rsquo;$是$A$的改名式，且$A\u0026rsquo;$改用的变元不在$A$中出现，则$A\\vdash\\dashv_{FC}A\u0026rsquo;$。\n证明：略\n例题 证明：$\\vdash A\\rightarrow B$且变元$v$在$B$中无自由出现，则$\\vdash\\exists vA\\rightarrow B$。\n$\\vdash A\\rightarrow B$ $\\vdash\\neg B\\rightarrow\\neg A$,$PC$中的定理 $\\vdash\\forall v(\\neg B\\rightarrow\\neg A)$,$Th1$ $\\vdash\\forall v(\\neg B\\rightarrow\\neg A)\\rightarrow(\\forall v\\neg B\\rightarrow\\forall v\\neg A)$,$A5$ $\\vdash\\forall v\\neg B\\rightarrow\\forall v\\neg A$,$r_{mp}(3)(4)$ $\\vdash\\neg B\\rightarrow\\forall v\\neg B$,$A6$ $\\vdash\\neg B\\rightarrow\\forall v\\neg A$,三段论 $\\vdash(\\neg B\\rightarrow\\forall v\\neg A)\\rightarrow(\\neg\\forall v\\neg A\\rightarrow B)$,$PC$中的定理 $\\vdash\\neg\\forall v\\neg A\\rightarrow B$,$r_{mp}(7)(8)$ 证明：$\\vdash(A\\rightarrow\\exists vB)\\rightarrow\\exists v(A\\rightarrow B)$，其中$v$在$A$中无自由出现。\n$A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\forall v\\neg(A\\rightarrow B)$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\neg(A\\rightarrow B)$,$Th1$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\neg(A\\rightarrow B)\\rightarrow\\neg B$,$PC$中的定理 $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\neg B$,$r_{mp}(2)(3)$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\forall v\\neg B$,$Th1$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\neg(A\\rightarrow B)\\rightarrow A$,$PC$中的定理 $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash A$,$r_{mp}(2)(6)$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash A\\rightarrow\\exists vB$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\exists vB$,$r_{mp}(7)(8)$ $A\\rightarrow\\exists vB,\\forall v\\neg(A\\rightarrow B)\\vdash\\neg\\forall v\\neg B$ $A\\rightarrow\\exists vB\\vdash\\neg\\forall v\\neg(A\\rightarrow B)$,对(5)和(10)使用反证法 $A\\rightarrow\\exists vB\\vdash\\exists v(A\\rightarrow B)$ $\\vdash(A\\rightarrow\\exists vB)\\rightarrow\\exists v(A\\rightarrow B)$ 其他形式的一阶谓词演算系统 FC的形式是简洁的，但是正如PC所具有的问题那样，在实际应用中FC并不方便，因为它所使用的联结词、量词和公理数量太少了。故类似于先前在介绍完PC后引入了ND，本文将引入FCM和FND两个形式系统，以便让我们的推理更加直观。\nFCM形式系统 FCM形式系统是由莫绍揆教授提出的使用五个逻辑联结词（$\\neg,\\rightarrow,\\vee,\\wedge,\\leftrightarrow$）和两个量词（$\\forall,\\exists$）的一阶谓词演算形式系统：\n公理：设$A,B,C$为代表FC中任意公式的语法变元，$v$为任意变元，$t$为任意项，那么FCM的公理包含下列七组公理模式及其对应的全称化\n$A1.1:A\\rightarrow A$\n$A1.2:(A\\rightarrow(B\\rightarrow C))\\rightarrow(B\\rightarrow(A\\rightarrow C))$\n$A1.3:(A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$\n$A1.4:(A\\rightarrow(A\\rightarrow B))\\rightarrow(A\\rightarrow B)$\n$A2.1:(A\\leftrightarrow B)\\rightarrow(A\\rightarrow B)$\n$A2.2:(A\\leftrightarrow B)\\rightarrow(B\\rightarrow A)$\n$A2.3:(A\\rightarrow B)\\rightarrow((B\\rightarrow A)\\rightarrow(A\\leftrightarrow B))$\n$A3.1:A\\rightarrow(A\\vee B)$\n$A3.2:B\\rightarrow(A\\vee B)$\n$A3.3:(A\\rightarrow C)\\rightarrow((B\\rightarrow C)\\rightarrow(A\\vee B\\rightarrow C))$\n$A4.1:A\\wedge B\\rightarrow A$\n$A4.2:A\\wedge B\\rightarrow B$\n$A4.3:A\\rightarrow(B\\rightarrow A\\wedge B)$\n$A5.1:(A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg A)$\n$A5.2:\\neg\\neg A\\rightarrow A$\n$A6.1:\\forall vA\\rightarrow A^v_t$，若$t$对$A$中的变元$v$可代入\n$A6.2:\\forall v(A\\rightarrow B)\\rightarrow(\\forall vA\\rightarrow\\forall vB)$\n$A6.3:A\\rightarrow\\forall vA$，若$v$在$A$中无自由出现\n$A7.1:\\exists vA\\rightarrow\\neg\\forall v\\neg A$\n$A7.2:\\neg\\forall v\\neg A\\rightarrow\\exists vA$\n这七组公理模式是显然的，很多在之前已经进行了证明。\n推理规则：$r_{mp}$\nFND形式系统 在ND的基础上，很容易扩展出一个谓词演算的自然推理系统，我们称作FND，FND在ND的基础上新增添了一些规则，主要是增加了有关量词的推理规则，其余规则保持不变。\n$\\forall$引入规则${\\frac{\\Gamma\\vdash A}{\\Gamma\\vdash\\forall vA}}(\\forall+)$ $\\forall$消除规则${\\frac{\\Gamma\\vdash\\forall vA}{\\Gamma\\vdash A^v_t}}(\\forall-)$，若$t$对$A$中的变元$v$可代入 $\\exists$引入规则${\\frac{\\Gamma\\vdash A^t_t}{\\Gamma\\vdash\\exists vA}}(\\exists+)$，若$t$对$A$中的变元$v$可代入 $\\exists$消除规则${\\frac{\\Gamma\\vdash\\exists vA,\\Gamma;A^v_t\\vdash B}{\\Gamma\\vdash B}}(\\exists-)$，其中常元$c$在$\\Gamma$及公式$A,B$中均无自由出现 我们现在对这里的推理规则的意义进行解释：\n$(\\forall+)$规则：考虑FC中的全称引入定理。 $(\\forall-)$规则：考虑FC的公理$\\forall vA\\rightarrow A^v_t$，若$t$对$A$中的变元$v$可代入。 $(\\exists+)$规则：考虑FC的定理$A^v_t\\rightarrow\\exists vA$，若$t$对$A$中的变元$v$可代入。 $(\\exists-)$规则：考虑FC的存在消除定理。 例题 证明：$\\exists x(A\\vee B)\\vdash\\dashv\\exists xA\\vee\\exists xB$\n$\\exists x(A\\vee B),A\\vee B,A\\vdash A$,$(\\in)$ $\\exists x(A\\vee B),A\\vee B,A\\vdash\\exists xA$,$(\\exists+)(1)$ $\\exists x(A\\vee B),A\\vee B,A\\vdash\\exists xA\\vee\\exists xB$,$(\\vee+)(2)$ $\\exists x(A\\vee B),A\\vee B,B\\vdash B$,$(\\in)$ $\\exists x(A\\vee B),A\\vee B,B\\vdash\\exists xB$,$(\\exists+)(4)$ $\\exists x(A\\vee B),A\\vee B,B\\vdash\\exists xA\\vee\\exists xB$,$(\\vee+)(5)$ $\\exists x(A\\vee B),A\\vee B\\vdash A\\vee B$,$(\\in)$ $\\exists x(A\\vee B),A\\vee B\\vdash\\exists xA\\vee\\exists xB$,$(\\vee-)(3)(6)(7)$ $\\exists x(A\\vee B)\\vdash\\exists x(A\\vee B)$,$(\\in)$ $\\exists x(A\\vee B)\\vdash\\exists xA\\vee\\exists xB$,$(\\exists-)(8)(9)$ $\\exists xA\\vee\\exists xB,\\exists xA,A\\vdash A$,$(\\in)$ $\\exists xA\\vee\\exists xB,\\exists xA,A\\vdash A\\vee B$,$(\\vee+)(11)$ $\\exists xA\\vee\\exists xB,\\exists xA,A\\vdash\\exists x(A\\vee B)$,$(\\exists+)(12)$ $\\exists xA\\vee\\exists xB,\\exists xA\\vdash\\exists xA$,$(\\in)$ $\\exists xA\\vee\\exists xB,\\exists xA\\vdash\\exists x(A\\vee B)$,$(\\exists-)(13)(14)$ $\\exists xA\\vee\\exists xB,\\exists xB,B\\vdash B$,$(\\in)$ $\\exists xA\\vee\\exists xB,\\exists xB,B\\vdash A\\vee B$,$(\\vee+)(16)$ $\\exists xA\\vee\\exists xB,\\exists xB,B\\vdash\\exists x(A\\vee B)$,$(\\exists+)(17)$ $\\exists xA\\vee\\exists xB,\\exists xB\\vdash\\exists xB$,$(\\in)$ $\\exists xA\\vee\\exists xB,\\exists xB\\vdash\\exists x(A\\vee B)$,$(\\exists-)(18)(19)$ $\\exists xA\\vee\\exists xB\\vdash\\exists xA\\vee\\exists xB$,$(\\in)$ $\\exists xA\\vee\\exists xB\\vdash\\exists x(A\\vee B)$,$(\\vee-)(15)(20)(21)$ $\\exists x(A\\vee B)\\vdash\\dashv\\exists xA\\vee\\exists xB$ FC定理证明习题选 下面给出了八道FC定理习题供读者练习使用：\n证明：$\\forall x(A\\rightarrow B)\\vdash A\\rightarrow\\forall xB$，其中$x$在$A$中无自由出现。 证明: $\\vdash\\exists v(A\\rightarrow B)\\rightarrow(A\\rightarrow\\exists vB)$，其中$v$在$A$中无自由出现。 证明：存在一种方法能击败所有敌人，那么所有敌人都存在一种方法让其被击败。 证明：$\\exists x(A\\wedge B)\\vdash\\exists xA\\wedge\\exists xB$ 证明：$\\Gamma=${$\\exists x(P(x)\\wedge\\forall y(D(y)\\rightarrow L(x,y))),\\forall x\\forall y(P(x)\\wedge Q(y)\\rightarrow\\neg L(x,y))$}，则有$\\Gamma\\vdash\\forall y(D(y)\\rightarrow\\neg Q(y))$。 证明：$\\Gamma=${$P(Sam),G(Clyde)\\wedge L(Clyde,Oscar),(P(Oscar)\\oplus G(Oscar))\\wedge L(Oscar,Sam)$}，则有$\\Gamma\\vdash\\exists x\\exists y(G(x)\\wedge P(y)\\wedge L(x,y))$，注：$\\oplus$表示联结词中的“异或”。 证明：$\\Gamma=${$\\forall x(N(x)\\rightarrow E(x)\\oplus O(x)),\\forall x(N(x)\\rightarrow(E(x)\\leftrightarrow G(x))),\\neg\\forall x(N(x)\\rightarrow G(x))$}，则有$\\Gamma\\vdash\\exists x(N(x)\\wedge O(x))$。 证明：有二元关系$R$，若$R$是传递且反自反的，那么它是非对称的。 ","date":"2024-06-17T00:00:00Z","image":"https://0x3a0x29.github.io/p/firstorderpredicatecalculus/image_hu9853517623640821107.png","permalink":"https://0x3a0x29.github.io/p/firstorderpredicatecalculus/","title":"FC(一阶谓词演算系统)及其相关定理"},{"content":"ND及其相关定理 前言 水平有限，存在的错误和不足请大家指正。\n本篇所述皆来自于笔者于23年学校开设的《数理逻辑》课程中讲解内容。\n基础知识 命题：能唯一确定真假值的陈述句。\n原子命题：不能分解为更简单的陈述句的命题。\n复合命题：由联结词及简单命题构成的命题。\n命题变元：用来表示命题的英文字母。\n联结词：（下列的$A,B$为命题变元）\n否定词$\\neg$：表示“非”，如$\\neg A$表示“对$A$的否定”。 合取词$\\wedge$：表示“与”，如$A\\wedge B$表示“$A$与$B$”。 析取词$\\vee$：表示“或”，如$A\\vee B$表示“$A$或$B$”。 蕴涵词$\\rightarrow$：表示“如果……那么”，如$A\\rightarrow B$表示“如果$A$，那么$B$”，其中$A$被称为前件，$B$被称为后件。 双条件词$\\leftrightarrow$：表示“当且仅当”，如$A\\leftrightarrow B$表示“$A$当且仅当$B$”。 为表示方便，我们约定联结词的运算优先级从高到低为$\\neg,(\\wedge,\\vee),\\rightarrow,\\leftrightarrow$\n命题公式的定义：\n（1）原子命题是命题公式\n（2）若$A,B$是命题公式，那么$\\neg A,A\\wedge B,A\\vee B,A\\rightarrow B,A\\leftrightarrow B$也是命题公式\n（3）有限次的使用（1）（2）进行复合得到的结果也是命题公式\n自然演绎推理系统ND的简单介绍 与之前介绍的PC一样，自然演绎推理系统ND（natural deduction）也是一种形式系统，相较于PC而言，ND是一个更加实用、比较符合人的思维模式的推理演算系统，ND的规则和直观含义都比较明显，我们先简单介绍一下ND的组成部分：\n字符集：包括原子变元符$p_1,p_2,\\cdots,p_n,\\cdots$、联结词完备集{$\\neg,\\wedge,\\vee,\\rightarrow,\\leftrightarrow$}、辅助符号$(,)$ 形成规则：由原子变元符及联结词形成命题公式的规则，即上文提到的命题公式的定义 公理：设$A$为可以表达任意命题公式的语法变元，$\\Gamma$是一个公式集，在ND中只有一个公理（也有人把这个公理变形为推理规则，这样的ND的公理集就是$\\varnothing$）： $\\Gamma;A\\vdash A(\\in)$ 推理规则：用于从已有的公理和已推出的结论来推理另一结论。相较于PC，在ND中多了很多推理规则，这也使得ND更加符合我们的思维模式。 假设引入规则${\\frac{\\Gamma\\vdash B}{\\Gamma;A\\vdash B}}(+)$ 假设消除规则${\\frac{\\Gamma;A\\vdash B,\\Gamma;\\neg A\\vdash B}{\\Gamma\\vdash B}}(-)$ $\\vee$引入规则${\\frac{\\Gamma\\vdash A}{\\Gamma\\vdash A\\vee B},\\frac{\\Gamma\\vdash A}{\\Gamma\\vdash B\\vee A}}(\\vee+)$ $\\vee$消除规则${\\frac{\\Gamma;A\\vdash C,\\Gamma;B\\vdash C,\\Gamma\\vdash A\\vee B}{\\Gamma\\vdash C}}(\\vee-)$ $\\wedge$引入规则${\\frac{\\Gamma\\vdash A,\\Gamma\\vdash B}{\\Gamma\\vdash A\\wedge B}}(\\wedge+)$ $\\wedge$消除规则${\\frac{\\Gamma\\vdash A\\wedge B}{\\Gamma\\vdash A},\\frac{\\Gamma\\vdash A\\wedge B}{\\Gamma\\vdash B}}(\\wedge -)$ $\\rightarrow$引入规则${\\frac{\\Gamma;A\\vdash B}{\\Gamma\\vdash A\\rightarrow B}}(\\rightarrow+)$ $\\rightarrow$消除规则${\\frac{\\Gamma\\vdash A,\\Gamma\\vdash A\\rightarrow B}{\\Gamma\\vdash B}}(\\rightarrow-)$ $\\neg$引入规则${\\frac{\\Gamma;A\\vdash B,\\Gamma;A\\vdash\\neg B}{\\Gamma\\vdash\\neg A}}(\\neg+)$ $\\neg$消除规则${\\frac{\\Gamma\\vdash A,\\Gamma\\vdash\\neg A}{\\Gamma\\vdash B}}(\\neg-)$ $\\neg\\neg$引入规则${\\frac{\\Gamma\\vdash A}{\\Gamma\\vdash\\neg\\neg A}}(\\neg\\neg+)$ $\\neg\\neg$消除规则${\\frac{\\Gamma\\vdash\\neg\\neg A}{\\Gamma\\vdash A}}(\\neg\\neg-)$ $\\leftrightarrow$引入规则${\\frac{\\Gamma\\vdash A\\rightarrow B,\\Gamma\\vdash B\\rightarrow A}{\\Gamma\\vdash A\\leftrightarrow B}}(\\leftrightarrow+)$ $\\leftrightarrow$消除规则${\\frac{\\Gamma\\vdash A\\leftrightarrow B}{\\Gamma\\vdash A\\rightarrow B},\\frac{\\Gamma\\vdash A\\leftrightarrow B}{\\Gamma\\vdash B\\rightarrow A}}(\\leftrightarrow-)$ 定理推导：包括所有的推理结论及其推理过程。 我们现在对这里的14个推理规则的意义进行解释：\n$(+)$规则：考虑重言式$B\\rightarrow(A\\rightarrow B)$ $(-)$规则：人在推理中引入假设$A$或者引入假设$\\neg A$并不影响$B$的推导 $(\\vee+)$规则：考虑重言式$A\\rightarrow A\\vee B$和$A\\rightarrow B\\vee A$ $(\\vee-)$规则：考虑重言式$(A\\rightarrow C)\\wedge(B\\rightarrow C)(A\\vee B)\\rightarrow C$ $(\\wedge+)$规则：考虑重言式$A\\rightarrow(B\\rightarrow A\\wedge B)$ $(\\wedge-)$规则：考虑重言式$A\\wedge B\\rightarrow A$和$A\\wedge B\\rightarrow B$ $(\\rightarrow+)$规则：考虑PC中的演绎定理 $(\\rightarrow-)$规则：考虑PC中的分离规则 $(\\neg+)$规则：实际上就是反证法 $(\\neg-)$规则：考虑重言式$\\neg A\\rightarrow(A\\rightarrow B)$ $(\\neg\\neg+)$规则：考虑重言式$A\\rightarrow\\neg\\neg A$ $(\\neg\\neg-)$规则：考虑重言式$\\neg\\neg A\\rightarrow A$ $(\\leftrightarrow+)$规则：考虑重言式$((A\\rightarrow B)\\wedge(B\\rightarrow A))\\rightarrow(A\\leftrightarrow B)$ $(\\leftrightarrow-)$规则：考虑重言式$(A\\leftrightarrow B)\\rightarrow((A\\rightarrow B)\\wedge(B\\rightarrow A))$ 逻辑推理相关的基本定义 演绎：在ND中，若有$\\Gamma\\vdash_{ND}A$，即存在序列：$\\Gamma_1\\vdash A_1,\\Gamma_2\\vdash A_2,\\cdots,\\Gamma_m\\vdash A_m$使得$\\Gamma_i\\vdash A_i$或为ND的公理，或为$\\Gamma_i\\vdash A_i(j\u0026lt; i)$，或为$\\Gamma_{j_1}\\vdash A_{j_1},\\cdots,\\Gamma_{j_k}\\vdash A_{j_k}(j_1,\\cdots,j_k\u0026lt; i)$使用推理规则导出的。当$\\Gamma=\\varnothing$时我们记作$\\vdash_{ND}A$，称$A$为ND的定理。\n例：证明$A\\vdash_{ND}B\\rightarrow A$（这个定理说明了我们对一个定理增添前件后任旧是一个定理）。也就是说我们已经知道$A$成立了，现在要推出$B\\rightarrow A$也成立，这个过程都要在ND中进行，故我们要在ND中构造一个演绎序列使得最后一个是$\\vdash A\\rightarrow(B\\rightarrow A)$，一个可行的序列如下：\n$A,B\\vdash A$,$(\\in)$ （这是公理$(\\in)$） $A\\vdash B\\rightarrow A$,$(\\rightarrow+)(1)$ （对$(1)$使用$\\rightarrow+$规则） $\\vdash A\\rightarrow(B\\rightarrow A)$,$(\\rightarrow)(2)$ （对$(2)$使用$\\rightarrow+$规则） ND中的基本定理 在ND中直接使用公理和推理规则得出ND中的定理会非常繁琐，其中有不少步骤遵循相同的模式，下列总结了ND中10个基本定理，用于帮助寻找ND的定理：\n$Th1$：$\\vdash_{ND}A\\vee\\neg A$\n$A\\vdash A$,$(\\in)$ $A\\vdash A\\wedge\\neg A$,$(\\vee+)(1)$ $\\neg A\\vdash\\neg A$,$(\\in)$ $\\neg A\\vdash A\\vee\\neg A$,$(\\vee+)(3)$ $\\vdash A\\vee\\neg A$,$(-)(2)(4)$ $Th2$：$\\vdash_{ND}\\neg(A\\vee B)\\leftrightarrow(\\neg A\\wedge\\neg B)$\n$\\neg(A\\vee B),A\\vdash A$,$(\\in)$ $\\neg(A\\vee B),A\\vdash A\\vee B$,$(\\vee+)(1)$ $\\neg(A\\vee B),A\\vdash\\neg(A\\vee B)$,$(\\in)$ $\\neg(A\\vee B)\\vdash\\neg A$,$(\\neg+)(2)(3)$ $\\neg(A\\vee B),B\\vdash B$,$(\\in)$ $\\neg(A\\vee B),B\\vdash A\\vee B$,$(\\vee+)(5)$ $\\neg(A\\vee B),B\\vdash\\neg(A\\vee B)$,$(\\in)$ $\\neg(A\\vee B)\\vdash\\neg B$,$(\\neg+)(6)(7)$ $\\neg(A\\vee B)\\vdash\\neg A\\wedge\\neg B$,$(\\wedge+)(4)(8)$ $\\vdash\\neg(A\\vee B)\\rightarrow(\\neg A\\wedge\\neg B)$,$(\\rightarrow+)(9)$ $\\neg A\\wedge\\neg B,A\\vee B,A\\vdash A$,$(\\in)$ $\\neg A\\wedge\\neg B,A\\vee B,A\\vdash\\neg A\\wedge\\neg B$,$(\\in)$ $\\neg A\\wedge\\neg B,A\\vee B,A\\vdash\\neg A$,$(\\wedge-)(12)$ $\\neg A\\wedge\\neg B,A\\vee B,A\\vdash A\\wedge\\neg A$,$(\\wedge+)(11)(13)$ $\\neg A\\wedge\\neg B,A\\vee B,B\\vdash B$,$(\\in)$ $\\neg A\\wedge\\neg B,A\\vee B,B\\vdash\\neg A\\wedge\\neg B$,$(\\in)$ $\\neg A\\wedge\\neg B,A\\vee B,B\\vdash\\neg B$,$(\\wedge-)(16)$ $\\neg A\\wedge\\neg B,A\\vee B,A\\vdash A\\wedge\\neg A$,$(\\neg-)(15)(17)$ $\\neg A\\wedge\\neg B,A\\vee B\\vdash A\\vee B$,$(\\in)$ $\\neg A\\wedge\\neg B,A\\vee B\\vdash A\\wedge\\neg A$,$(\\vee-)(14)(18)(19)$ $\\neg A\\wedge\\neg B,A\\vee B\\vdash A$,$(\\wedge-)(20)$ $\\neg A\\wedge\\neg B,A\\vee B\\vdash\\neg A$,$(\\wedge-)(20)$ $\\neg A\\wedge\\neg B\\vdash\\neg(A\\vee B)$,$(\\neg+)(21)(22)$ $\\vdash(\\neg A\\wedge\\neg B)\\rightarrow\\neg(A\\vee B)$,$(\\rightarrow+)(23)$ $\\vdash\\neg(A\\vee B)\\leftrightarrow(\\neg A\\wedge\\neg B)$,$(\\leftrightarrow+)(10)(24)$ $Th3$：$\\vdash_{ND}\\neg(A\\wedge B)\\leftrightarrow(\\neg A\\vee\\neg B)$\n$\\neg(A\\wedge B),A,B\\vdash A$,$(\\in)$ $\\neg(A\\wedge B),A,B\\vdash B$,$(\\in)$ $\\neg(A\\wedge B),A,B\\vdash A\\wedge B$,$(\\wedge+)(1)(2)$ $\\neg(A\\wedge B),A,B\\vdash\\neg(A\\wedge B)$,$(\\in)$ $\\neg(A\\wedge B),A\\vdash\\neg B$,$(\\neg+)(3)(4)$ $\\neg(A\\wedge B),A\\vdash\\neg A\\vee\\neg B$,$(\\vee+)(5)$ $\\neg(A\\wedge B),\\neg A\\vdash\\neg A$,$(\\in)$ $\\neg(A\\wedge B),\\neg A\\vdash\\neg A\\vee\\neg B$,$(\\vee+)(7)$ $\\neg(A\\wedge B)\\vdash\\neg A\\vee\\neg B$,$(-)(6)(8)$ $\\vdash\\neg(A\\wedge B)\\rightarrow(\\neg A\\vee\\neg B)$,$(\\rightarrow+)(9)$ $\\neg A\\vee\\neg B,\\neg A,A\\wedge B\\vdash\\neg A$,$(\\in)$ $\\neg A\\vee\\neg B,\\neg A,A\\wedge B\\vdash A\\wedge B$,$(\\in)$ $\\neg A\\vee\\neg B,\\neg A,A\\wedge B\\vdash A$,$(\\wedge-)(12)$ $\\neg A\\vee\\neg B,\\neg A\\vdash\\neg(A\\wedge B)$,$(\\neg+)(11)(13)$ $\\neg A\\vee\\neg B,\\neg B,A\\wedge B\\vdash\\neg B$,$(\\in)$ $\\neg A\\vee\\neg B,\\neg B,A\\wedge B\\vdash A\\wedge B$,$(\\in)$ $\\neg A\\vee\\neg B,\\neg B,A\\wedge B\\vdash B$,$(\\wedge-)(16)$ $\\neg A\\vee\\neg B,\\neg B\\vdash\\neg(A\\wedge B)$,$(\\neg+)(15)(17)$ $\\neg A\\vee\\neg B\\vdash\\neg A\\vee\\neg B$,$(\\in)$ $\\neg A\\vee\\neg B\\vdash\\neg(A\\wedge B)$,$(\\vee-)(14)(18)(19)$ $\\vdash(\\neg A\\vee\\neg B)\\rightarrow\\neg(A\\wedge B)$,$(\\rightarrow+)(20)$ $\\vdash(\\neg A\\vee\\neg b)\\leftrightarrow\\neg(A\\wedge B)$,$(\\leftrightarrow+)(10)(21)$ $Th4$：$\\neg A\\rightarrow B\\vdash\\dashv_{ND} A\\vee B$，这里的$P\\vdash\\dashv_{ND}Q$当且仅当$P\\vdash_{ND}Q$且$Q\\vdash_{ND}P$\n$\\neg A\\rightarrow B,\\neg A\\vdash\\neg A$,$(\\in)$ $\\neg A\\rightarrow B,\\neg A\\vdash\\neg A\\rightarrow B$,$(\\in)$ $\\neg A\\rightarrow B,\\neg A\\vdash B$,$(\\rightarrow-)(1)(2)$ $\\neg A\\rightarrow B,\\neg A\\vdash A\\vee B$,$(\\vee+)(3)$ $\\neg A\\rightarrow B,A\\vdash A$,$(\\in)$ $\\neg A\\rightarrow B,A\\vdash A\\vee B$,$(\\vee+)(5)$ $\\neg A\\rightarrow B\\vdash A\\vee B$,$(-)(4)(6)$ $A\\vee B,\\neg A,A\\vdash A$,$(\\in)$ $A\\vee B,\\neg A,A\\vdash\\neg A$,$(\\in)$ $A\\vee B,\\neg A,A\\vdash B$,$(\\neg-)(8)(9)$ $A\\vee B,\\neg A,B\\vdash B$,$(\\in)$ $A\\vee B,\\neg A\\vdash A\\vee B$,$(\\in)$ $A\\vee B,\\neg A\\vdash B$,$(\\vee-)(8)(11)(12)$ $A\\vee B\\vdash \\neg A\\rightarrow B$,$(\\rightarrow+)(13)$ $Th5$：$A\\rightarrow B\\vdash\\dashv_{ND}\\neg A\\vee B$\n$A\\rightarrow B,A\\vdash A$,$(\\in)$ $A\\rightarrow B,A\\vdash A\\rightarrow B$,$(\\in)$ $A\\rightarrow B,A\\vdash B$,$(\\rightarrow-)(1)(2)$ $A\\rightarrow B,A\\vdash\\neg A\\vee B$,$(\\vee+)(3)$ $A\\rightarrow B,\\neg A\\vdash\\neg A$,$(\\in)$ $A\\rightarrow B,\\neg A\\vdash\\neg A\\vee B$,$(\\vee+)(5)$ $A\\rightarrow B\\vdash\\neg A\\vee B$,$(-)(4)(6)$ $\\neg A\\vee B,\\neg A,A\\vdash A$,$(\\in)$ $\\neg A\\vee B,\\neg A,A\\vdash\\neg A$,$(\\in)$ $\\neg A\\vee B,\\neg A,A\\vdash B$,$(\\neg-)(8)(9)$ $\\neg A\\vee B,A,B\\vdash B$,$(\\in)$ $\\neg A\\vee B,A\\vdash\\neg A\\vee B$,$(\\in)$ $\\neg A\\vee B,A\\vdash B$,$(\\vee-)(8)(11)(12)$ $\\neg A\\vee B\\vdash A\\rightarrow B$,$(\\rightarrow+)(13)$ $Th6$：$\\vdash_{ND}A\\wedge(B\\vee C)\\leftrightarrow(A\\wedge B)\\vee(A\\wedge C)$\n$A\\wedge(B\\vee C),B\\vdash A\\wedge(B\\vee C)$,$(\\in)$ $A\\wedge(B\\vee C),B\\vdash A$,$(\\wedge-)(1)$ $A\\wedge(B\\vee C),B\\vdash B$,$(\\in)$ $A\\wedge(B\\vee C),B\\vdash A\\wedge B$,$(\\wedge+)(2)(3)$ $A\\wedge(B\\vee C),B\\vdash(A\\wedge B)\\vee(A\\wedge C)$,$(\\vee+)(4)$ $A\\wedge(B\\vee C),C\\vdash A\\wedge(B\\vee C)$,$(\\in)$ $A\\wedge(B\\vee C),C\\vdash A$,$(\\wedge-)(6)$ $A\\wedge(B\\vee C),C\\vdash C$,$(\\in)$ $A\\wedge(B\\vee C),C\\vdash A\\wedge C$,$(\\wedge+)(7)(8)$ $A\\wedge(B\\vee C),C\\vdash(A\\wedge B)\\vee(A\\wedge C)$,$(\\vee+)(9)$ $A\\wedge(B\\vee C)\\vdash A\\wedge(B\\vee C)$,$(\\in)$ $A\\wedge(B\\vee C)\\vdash B\\vee C$,$(\\wedge-)(11)$ $A\\wedge(B\\vee C)\\vdash(A\\wedge B)\\vee(A\\wedge C)$,$(\\vee-)(5)(10)(12)$ $\\vdash A\\wedge(B\\vee C)\\rightarrow(A\\wedge B)\\vee(A\\wedge C)$,$(\\rightarrow+)(13)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge B\\vdash A\\wedge B$,$(\\in)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge B\\vdash B$,$(\\wedge-)(15)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge B\\vdash B\\vee C$,$(\\vee+)(16)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge B\\vdash A$,$(\\wedge-)(15)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge B\\vdash A\\wedge(B\\vee C)$,$(\\wedge+)(17)(18)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge C\\vdash A\\wedge C$,$(\\in)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge C\\vdash C$,$(\\wedge-)(20)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge C\\vdash B\\vee C$,$(\\vee+)(21)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge C\\vdash A$,$(\\wedge-)(20)$ $(A\\wedge B)\\vee(A\\wedge C),A\\wedge C\\vdash A\\wedge(B\\vee C)$,$(\\wedge+)(22)(23)$ $(A\\wedge B)\\vee(A\\wedge C)\\vdash(A\\wedge B)\\vee(A\\wedge C)$,$(\\in)$ $(A\\wedge B)\\vee(A\\wedge C)\\vdash A\\wedge(B\\vee C)$,$(\\vee-)(19)(24)(25)$ $\\vdash(A\\wedge B)\\vee(A\\wedge C)\\rightarrow A\\wedge(B\\vee C)$,$(\\rightarrow+)(26)$ $\\vdash A\\wedge(B\\vee C)\\leftrightarrow(A\\wedge B)\\vee(A\\wedge C)$,$(\\leftrightarrow+)(14)(27)$ $Th7$：$\\vdash_{HD}A\\vee(B\\wedge C)\\leftrightarrow(A\\vee B)\\wedge(A\\vee C)$\n$A\\vee(B\\wedge C),B\\wedge C\\vdash B\\wedge C$,$(\\in)$ $A\\vee(B\\wedge C),B\\wedge C\\vdash B$,$(\\wedge-)(1)$ $A\\vee(B\\wedge C),B\\wedge C\\vdash A\\vee B$,$(\\vee+)(2)$ $A\\vee(B\\wedge C),B\\wedge C\\vdash C$,$(\\wedge-)(1)$ $A\\vee(B\\wedge C),B\\wedge C\\vdash A\\vee C$,$(\\vee+)(4)$ $A\\vee(B\\wedge C),B\\wedge C\\vdash (A\\vee B)\\wedge(A\\vee C)$,$(\\wedge+)(3)(5)$ $A\\vee(B\\wedge C),A\\vdash A$,$(\\in)$ $A\\vee(B\\wedge C),A\\vdash A\\vee B$,$(\\vee+)(7)$ $A\\vee(B\\wedge C),A\\vdash A\\vee C$,$(\\vee+)(7)$ $A\\vee(B\\wedge C),A\\vdash(A\\vee B)\\wedge(A\\vee C)$,$(\\wedge+)(8)(9)$ $A\\vee(B\\wedge C)\\vdash A\\vee(B\\wedge C)$,$(\\in)$ $A\\vee(B\\wedge C)\\vdash(A\\vee B)\\wedge(A\\vee C)$,$(\\vee-)(6)(10)(11)$ $\\vdash A\\vee(B\\wedge C)\\rightarrow(A\\vee B)\\wedge(A\\vee C)$,$(\\rightarrow+)(12)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A,A\\vee B\\vdash\\neg A\\rightarrow B$,$Th4$（这里存在着一个对应的演绎序列，这里实际上是一种简写，后面的证明中我们也这样简写） $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash(A\\vee B)\\rightarrow(\\neg A\\rightarrow B)$,$(\\rightarrow+)(14)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash(A\\vee B)\\wedge(A\\vee C)$,$(\\in)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash A\\vee B$,$(\\wedge-)(16)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash\\neg A\\rightarrow B$,$(\\rightarrow-)(15)(17)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash\\neg A$,$(\\in)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash B$,$(\\rightarrow-)(18)(19)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A,A\\vee C\\vdash\\neg A\\rightarrow C$,$Th4$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash(A\\vee C)\\rightarrow(\\neg A\\rightarrow C)$,$(\\rightarrow+)(21)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash A\\vee C$,$(\\wedge-)(16)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash\\neg A\\rightarrow C$,$(\\rightarrow-)(22)(23)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash C$,$(\\rightarrow-)(19)(24)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash B\\wedge C$,$(\\wedge+)(20)(25)$ $(A\\vee B)\\wedge(A\\vee C),\\neg A\\vdash A\\vee(B\\wedge C)$,$(\\vee+)(26)$ $(A\\vee B)\\wedge(A\\vee C),A\\vdash A$,$(\\in)$ $(A\\vee B)\\wedge(A\\vee C),A\\vdash A\\vee(B\\wedge C)$,$(\\vee+)(28)$ $(A\\vee B)\\wedge(A\\vee C),\\vdash A\\vee(B\\wedge C)$,$(-)(27)(29)$ $\\vdash(A\\vee B)\\wedge(A\\vee C)\\rightarrow A\\vee(B\\wedge C)$,$(\\rightarrow+)(30)$ $\\vdash A\\vee(B\\wedge C)\\leftrightarrow(A\\vee B)\\wedge(A\\vee C)$,$(\\leftrightarrow+)(13)(31)$ 从上面的7个定理的证明中我们可以发现，和PC相比，ND的证明思路更加符合我们的思维模式，事实上能通过PC证明的定理在ND中也可以证明出来，为了证明这个事实，我们不妨在ND中尝试证明PC中使用到的3个公理。\n$Th8$：$\\vdash_{ND}A\\rightarrow(B\\rightarrow A)$\n$A,B\\vdash A$,$(\\in)$ $A\\vdash B\\rightarrow A$,$(\\rightarrow+)(1)$ $\\vdash A\\rightarrow(B\\rightarrow A)$,$(\\rightarrow+)(2)$ $Th9$：$\\vdash_{ND}(A\\rightarrow(B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$\n$A\\rightarrow(B\\rightarrow C),A\\rightarrow B,A\\vdash A$,$(\\in)$ $A\\rightarrow(B\\rightarrow C),A\\rightarrow B,A\\vdash A\\rightarrow B$,$(\\in)$ $A\\rightarrow(B\\rightarrow C),A\\rightarrow B,A\\vdash B$,$(\\rightarrow-)(1)(2)$ $A\\rightarrow(B\\rightarrow C),A\\rightarrow B,A\\vdash A\\rightarrow(B\\rightarrow C)$,$(\\in)$ $A\\rightarrow(B\\rightarrow C),A\\rightarrow B,A\\vdash B\\rightarrow C$,$(\\rightarrow-)(1)(4)$ $A\\rightarrow(B\\rightarrow C),A\\rightarrow B,A\\vdash C$,$(\\rightarrow-)(3)(5)$ $A\\rightarrow(B\\rightarrow C),A\\rightarrow B\\vdash A\\rightarrow C$,$(\\rightarrow+)(6)$ $A\\rightarrow(B\\rightarrow C),\\vdash(A\\rightarrow B)\\rightarrow(A\\rightarrow C)$,$(\\rightarrow+)(7)$ $\\vdash(A\\rightarrow(B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$(\\rightarrow+)(8)$ $Th10$：$\\vdash_{ND}(\\neg A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow A)$\n$\\neg A\\rightarrow\\neg B,\\neg A,B\\vdash\\neg A$,$(\\in)$ $\\neg A\\rightarrow\\neg B,\\neg A,B\\vdash\\neg A\\rightarrow\\neg B$,$(\\in)$ $\\neg A\\rightarrow\\neg B,\\neg A,B\\vdash\\neg B$,$(\\rightarrow-)(1)(2)$ $\\neg A\\rightarrow\\neg B,\\neg A,B\\vdash B$,$(\\in)$ $\\neg A\\rightarrow\\neg B,\\neg A,B\\vdash A$,$(\\neg-)(3)(4)$ $\\neg A\\rightarrow\\neg B,A,B\\vdash A$,$(\\in)$ $\\neg A\\rightarrow\\neg B,B\\vdash A$,$(-)(5)(6)$ $\\neg A\\rightarrow\\neg B\\vdash B\\rightarrow A$,$(\\rightarrow+)(7)$ $\\vdash(\\neg A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow A)$,$(\\rightarrow+)(8)$ ND定理证明习题选 下面给出了六道ND定理习题供读者练习使用：\n证明：$\\vdash_{ND}A\\rightarrow(B\\rightarrow C)\\leftrightarrow(A\\wedge B\\rightarrow C)$ 证明：$A\\rightarrow B,\\neg(B\\rightarrow C)\\rightarrow\\neg A\\vdash_{ND}A\\rightarrow C$ 证明：$\\vdash_{ND}(A\\vee B)\\wedge(\\neg B\\vee C)\\rightarrow A\\vee C$ 证明：$\\vdash_{ND}(A\\wedge B)\\leftrightarrow A\\wedge(\\neg A\\vee B)$ 证明：$\\vdash_{ND}((A\\leftrightarrow B)\\leftrightarrow A)\\leftrightarrow B$ 证明：$\\vdash_{ND}(A\\leftrightarrow\\neg B)\\leftrightarrow\\neg(A\\leftrightarrow B)$ ","date":"2023-12-19T00:00:00Z","image":"https://0x3a0x29.github.io/p/naturaldeduction/image_hu6405441338273122434.png","permalink":"https://0x3a0x29.github.io/p/naturaldeduction/","title":"ND(自然演绎推理系统)及其相关定理"},{"content":"PC及其相关定理 前言 水平有限，存在的错误和不足请大家指正。\n本篇所述皆来自于笔者于23年学校开设的《数理逻辑》课程中讲解内容。\n基础知识 命题：能唯一确定真假值的陈述句。\n原子命题：不能分解为更简单的陈述句的命题。\n复合命题：由联结词及简单命题构成的命题。\n命题变元：用来表示命题的英文字母。（下列的$A,B$为命题变元）\n联结词：有五种常用的联结词，如下所示。\n否定词$\\neg$：表示“非”，如$\\neg A$表示“对$A$的否定”。 合取词$\\wedge$：表示“与”，如$A\\wedge B$表示“$A$与$B$”。 析取词$\\vee$：表示“或”，如$A\\vee B$表示“$A$或$B$”。 蕴涵词$\\rightarrow$：表示“如果……那么”，如$A\\rightarrow B$表示“如果$A$，那么$B$”，其中$A$被称为前件，$B$被称为后件。 双条件词$\\leftrightarrow$：表示“当且仅当”，如$A\\leftrightarrow B$表示“$A$当且仅当$B$”。 为表示方便，我们约定联结词的运算优先级从高到低为$\\neg,(\\wedge,\\vee),\\rightarrow,\\leftrightarrow$\n命题公式的定义：\n（1）原子命题是命题公式。\n（2）若$A,B$是命题公式，那么$\\neg A,A\\wedge B,A\\vee B,A\\rightarrow B,A\\leftrightarrow B$也是命题公式。\n（3）有限次的使用（1）（2）进行复合得到的结果也是命题公式。\n命题逻辑演算形式系统PC的简单介绍 命题逻辑演算形式系统PC（propositional calculus）是一种形式系统，我们先简单介绍一下PC的组成部分：\n字符集：包括原子变元符$p_1,p_2,\\cdots,p_n,\\cdots$、联结词完备集{$\\neg,\\rightarrow$}、辅助符号$(,)$\n形成规则：由原子变元符及联结词形成命题公式的规则，即上文提到的命题公式的定义\n公理：设$A,B,C$为可以表达任意命题公式的语法变元，那么PC中有三个公理 $A1:A\\rightarrow (B\\rightarrow A)$\n$A2:(A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$\n$A3:(\\neg A\\rightarrow\\neg B)\\rightarrow (B\\rightarrow A)$\n$A1$的含义是：如果$A$成立，那么已知$B$成立的前提下$A$任旧成立。\n$A2$的含义是：如果$A$成立能使得只需要$B$成立那么$C$就会成立，那么如果$A$能推出$B$、$A$就能推出$C$。\n$A3$的含义是：如果$A$不成立能推出$B$不成立，那么$B$成立就能推出$A$成立。\n推理规则：用于从已有的公理和已推出的结论来推理另一结论。 在PC中只有分离规则$r_{mp}$：即若有$A$和$A\\rightarrow B$成立，那么$B$也成立，形式化的推理序列为：$A,A\\rightarrow B,B$。 可以记作$\\displaystyle{\\frac{A,A\\rightarrow B}{B}}$\n定理推导：包括所有的推理结论及其推理过程。\n逻辑推理相关的基本定义 证明：称以下公式序列为公式$A$在PC中的一个证明：$A_1,A_2,\\cdots,A_{m-1},A$，其中$A_i$或为PC的公理、或为$A_j(j\u0026lt; i)$、或为$A_j,A_k(j,k\u0026lt; i)$通过形成规则得到的。 定理：公式$A$在PC中有一个证明序列，那么它就是PC的定理，我们记为$\\vdash_{PC}A$。 演绎：设$\\Gamma$为PC中若干公式构成的公式集，则称下列公式序列为公式$A$以$\\Gamma$为前提的演绎：$A_1,A_2,\\cdots,A_{m-1},A$，其中$A_i$或为PC的公理、或为$\\Gamma$中的成员、或为$A_j(j\u0026lt; i)$、或为$A_j,A_k(j,k\u0026lt; i)$通过分离规则得到的。我们可以记为$\\Gamma\\vdash_{PC}A$。 例：证明$A\\vdash_{PC}B\\rightarrow A$（这个定理说明了我们对一个定理增添前件后任旧是一个定理）。也就是说我们已经知道$A$成立了，现在要推出$B\\rightarrow A$也成立，这个过程都要在PC中进行，故我们要在PC中构造一个演绎序列使得最后一个公式是$B\\rightarrow A$，一个可行的公式序列如下：\n$A$ （$A$是演绎前提中的成员） $A\\rightarrow(B\\rightarrow A)$,$A1$ （$A\\rightarrow(B\\rightarrow A)$是公理中的$A1$） $B\\rightarrow A$,$r_{mp}(1)(2)$ （对公式序列中的$(1)(2)$使用分离规则得到结论$B\\rightarrow A$） 上面我们成功构造了一个符合演绎要求的公式序列，也就是说有$A\\vdash_{PC}B\\rightarrow A$，我们完成了这个例子的证明。\n实际上我们可以证明PC有合理性、一致性、完备性，这表明PC中的定理是永真的、从$\\Gamma$演绎出$A$就会有$\\Gamma\\Rightarrow A$（合理性），PC不会推出相互矛盾的结论（一致性），任何PC中的永真式都是PC的定理（完备性）。\nPC的基本定理 在PC中直接使用公理和推理规则得出PC中的定理会非常繁琐，其中有不少步骤遵循相同的模式，下列总结了PC中35个基本定理（其中7个定理较为重要），用于帮助寻找PC的定理：\n$Th1$：$\\vdash_{PC}A\\rightarrow A$\n$A\\rightarrow(B\\rightarrow A)$,$A1$ $A\\rightarrow((B\\rightarrow A)\\rightarrow A)$,$A1$ $(A\\rightarrow((B\\rightarrow A)\\rightarrow A))\\rightarrow((A\\rightarrow(B\\rightarrow A))\\rightarrow(A\\rightarrow A))$,$A2$ $(A\\rightarrow(B\\rightarrow A))\\rightarrow(A\\rightarrow A)$,$r_{mp}(2)(3)$ $A\\rightarrow A$,$r_{mp}(1)(4)$ 前件互换定理 $Th2$：若$\\vdash_{PC}A\\rightarrow(B\\rightarrow C)$，则$\\vdash_{PC}B\\rightarrow(A\\rightarrow C)$\n$A\\rightarrow(B\\rightarrow C)$ $(A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$A2$ $(A\\rightarrow B)\\rightarrow(A\\rightarrow C)$,$r_{mp}(1)(2)$ $((A\\rightarrow B)\\rightarrow(A\\rightarrow C))\\rightarrow(B\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C)))$,$A1$ $B\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$r_{mp}(3)(4)$ $(B\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C)))\\rightarrow((B\\rightarrow(A\\rightarrow B))\\rightarrow(B\\rightarrow(A\\rightarrow C)))$,$A2$ $(B\\rightarrow(A\\rightarrow B))\\rightarrow(B\\rightarrow(A\\rightarrow C))$,$r_{mp}(5)(6)$ $B\\rightarrow(A\\rightarrow B)$,$A1$ $B\\rightarrow(A\\rightarrow C)$,$r_{mp}(7)(8)$ $Th3$：$\\vdash_{PC}(A\\rightarrow(B\\rightarrow C))\\rightarrow(B\\rightarrow(A\\rightarrow C))$\n$(A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$A1$ $(A\\rightarrow B)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C))$,$Th2$（因为这是PC中的一个定理，所以它存在一个对应的证明序列，这里实际上是一种简写，不将这个定理对应的证明序列写出，后续的证明中我们也这样简写） $((A\\rightarrow B)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C)))\\rightarrow(B\\rightarrow((A\\rightarrow B)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C))))$,$A1$ $B\\rightarrow((A\\rightarrow B)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C)))$,$r_{mp}(2)(3)$ $(B\\rightarrow((A\\rightarrow B)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C))))\\rightarrow((B\\rightarrow(A\\rightarrow B))\\rightarrow(B\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C))))$,$A2$ $(B\\rightarrow(A\\rightarrow B))\\rightarrow(B\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C)))$,$r_{mp}(4)(5)$ $B\\rightarrow(A\\rightarrow B)$,$A1$ $B\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow(A\\rightarrow C))$,$r_{mp}(6)(7)$ $(A\\rightarrow (B\\rightarrow C))\\rightarrow(B\\rightarrow(A\\rightarrow C))$,$Th2$ 加前件定理 $Th4$：$\\vdash_{PC}(B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$\n$(A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$A2$ $((A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C)))\\rightarrow((B\\rightarrow C)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))))$,$A1$ $(B\\rightarrow C)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C)))$,$r_{mp}(1)(2)$ $((B\\rightarrow C)\\rightarrow((A\\rightarrow (B\\rightarrow C))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))))\\rightarrow(((B\\rightarrow C)\\rightarrow((A\\rightarrow (B\\rightarrow C))))\\rightarrow((B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))))$,$A2$ $((B\\rightarrow C)\\rightarrow((A\\rightarrow (B\\rightarrow C))))\\rightarrow((B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C)))$,$r_{mp}(3)(4)$ $(B\\rightarrow C)\\rightarrow((A\\rightarrow (B\\rightarrow C)))$,$A1$ $(B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$r_{mp}(5)(6)$ 加后件定理 $Th5$：$\\vdash_{PC}(A\\rightarrow B)\\rightarrow((B\\rightarrow C)\\rightarrow(A\\rightarrow C))$\n$(B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$Th4$ $(A\\rightarrow B)\\rightarrow((B\\rightarrow C)\\rightarrow(A\\rightarrow C))$,$Th2$ 三段论定理 $Th6$：$\\vdash_{PC}A\\rightarrow B,\\vdash_{PC}B\\rightarrow C$，那么$\\vdash_{PC}A\\rightarrow C$\n$(B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$Th4$ $B\\rightarrow C$ $(A\\rightarrow B)\\rightarrow(A\\rightarrow C)$,$r_{mp}(1)(2)$ $A\\rightarrow B$ $A\\rightarrow C$,$r_{mp}(3)(4)$ $Th7$：$\\vdash_{PC}\\neg A\\rightarrow (A\\rightarrow B)$\n$\\neg A\\rightarrow(\\neg B\\rightarrow\\neg A)$,$A1$ $(\\neg B\\rightarrow\\neg A)\\rightarrow (A\\rightarrow B)$,$A3$ $\\neg A\\rightarrow(A\\rightarrow B)$,$Th6$ $Th8$：$\\vdash_{PC}A\\rightarrow(\\neg A\\rightarrow B)$\n$\\neg A\\rightarrow (A\\rightarrow B)$,$Th7$ $A\\rightarrow(\\neg A\\rightarrow B)$,$Th2$ $Th9$：$\\vdash_{PC}(\\neg A\\rightarrow A)\\rightarrow A$\n$\\neg A\\rightarrow(A\\rightarrow\\neg(\\neg A\\rightarrow A))$,$Th7$ $(\\neg A\\rightarrow(A\\rightarrow\\neg(\\neg A\\rightarrow A)))\\rightarrow((\\neg A\\rightarrow A)\\rightarrow(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow A)))$,$A2$ $(\\neg A\\rightarrow A)\\rightarrow(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow A))$,$r_{mp}(1)(2)$ $(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow A))\\rightarrow((\\neg A\\rightarrow A)\\rightarrow A)$,$A3$ $(\\neg A\\rightarrow A)\\rightarrow((\\neg A\\rightarrow A)\\rightarrow A)$,$Th6$ $((\\neg A\\rightarrow A)\\rightarrow((\\neg A\\rightarrow A)\\rightarrow A))\\rightarrow(((\\neg A\\rightarrow A)\\rightarrow(\\neg A\\rightarrow A))\\rightarrow((\\neg A\\rightarrow A)\\rightarrow A))$,$A2$ $((\\neg A\\rightarrow A)\\rightarrow(\\neg A\\rightarrow A))\\rightarrow((\\neg A\\rightarrow A)\\rightarrow A)$,$r_{mp}(5)(6)$ $(\\neg A\\rightarrow A)\\rightarrow(\\neg A\\rightarrow A)$,$Th1$ $(\\neg A\\rightarrow A)\\rightarrow A$,$r_{mp}(7)(8)$ $Th10$：$\\vdash_{PC}\\neg\\neg A\\rightarrow A$\n$\\neg\\neg A\\rightarrow(\\neg A\\rightarrow\\neg\\neg\\neg A)$,$Th7$ $(\\neg A\\rightarrow\\neg\\neg\\neg A)\\rightarrow(\\neg\\neg A\\rightarrow A)$,$A3$ $\\neg\\neg A\\rightarrow(\\neg\\neg A\\rightarrow A)$,$Th6$ $(\\neg\\neg A\\rightarrow(\\neg\\neg A\\rightarrow A))\\rightarrow((\\neg\\neg A\\rightarrow\\neg\\neg A)\\rightarrow(\\neg\\neg A\\rightarrow A))$,$A2$ $(\\neg\\neg A\\rightarrow\\neg\\neg A)\\rightarrow(\\neg\\neg A\\rightarrow A)$,$r_{mp}(3)(4)$ $\\neg\\neg A\\rightarrow\\neg\\neg A$,$Th1$ $\\neg\\neg A\\rightarrow A$,$r_{mp}(5)(6)$ $Th11$：$\\vdash_{PC}(A\\rightarrow\\neg A)\\rightarrow\\neg A$\n$\\neg\\neg A\\rightarrow A$,$Th10$ $(\\neg\\neg A\\rightarrow A)\\rightarrow((A\\rightarrow\\neg A)\\rightarrow(\\neg\\neg A\\rightarrow\\neg A))$,$Th5$ $(A\\rightarrow\\neg A)\\rightarrow(\\neg\\neg A\\rightarrow\\neg A)$,$r_{mp}(1)(2)$ $(\\neg\\neg A\\rightarrow\\neg A)\\rightarrow\\neg A$,$Th9$ $(A\\rightarrow\\neg A)\\rightarrow\\neg A$,$Th6$ $Th12$：$\\vdash_{PC}A\\rightarrow\\neg\\neg A$\n$A\\rightarrow(\\neg A\\rightarrow\\neg\\neg A)$,$Th8$ $(\\neg A\\rightarrow\\neg\\neg A)\\rightarrow\\neg\\neg A$,$Th11$ $A\\rightarrow\\neg\\neg A$,$r_{mp}(1)(2)$ $Th13$：$\\vdash_{PC}(A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow\\neg A)$\n$(\\neg\\neg A\\rightarrow\\neg\\neg B)\\rightarrow(\\neg B\\rightarrow\\neg A)$,$A3$ $B\\rightarrow\\neg\\neg B$,$Th12$ $(B\\rightarrow\\neg\\neg B)\\rightarrow((\\neg\\neg A\\rightarrow B)\\rightarrow(\\neg\\neg A\\rightarrow\\neg\\neg B))$,$A2$ $(\\neg\\neg A\\rightarrow B)\\rightarrow(\\neg\\neg A\\rightarrow\\neg\\neg B)$,$r_{mp}(2)(3)$ $(\\neg\\neg A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow\\neg A)$,$Th6$ $\\neg\\neg A\\rightarrow A$,$Th10$ $(\\neg\\neg A\\rightarrow A)\\rightarrow((A\\rightarrow B)\\rightarrow(\\neg\\neg A\\rightarrow B))$,$Th5$ $(A\\rightarrow B)\\rightarrow(\\neg\\neg A\\rightarrow B)$,$r_{mp}(6)(7)$ $(A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow\\neg A)$,$Th6$ $Th14$：$\\vdash_{PC}(\\neg A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow A)$\n$(\\neg A\\rightarrow\\neg\\neg B)\\rightarrow(\\neg B\\rightarrow A)$,$A3$ $B\\rightarrow\\neg\\neg B$,$Th12$ $(B\\rightarrow\\neg\\neg B)\\rightarrow((\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow\\neg\\neg B))$,$Th4$ $(\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow\\neg\\neg B)$,$r_{mp}(2)(3)$ $(\\neg A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow A)$,$Th6$ $Th15$：$\\vdash_{PC}(A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg A)$\n$(\\neg\\neg A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg A)$,$A3$ $\\neg\\neg A\\rightarrow A$,$Th10$ $(\\neg\\neg A\\rightarrow A)\\rightarrow((A\\rightarrow\\neg B)\\rightarrow(\\neg\\neg A\\rightarrow\\neg B))$,$Th5$ $(A\\rightarrow\\neg B)\\rightarrow(\\neg\\neg A\\rightarrow\\neg B)$,$r_{mp}(2)(3)$ $(A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg A)$,$Th6$ 反证法 $Th16$：$\\vdash_{PC}(\\neg A\\rightarrow B)\\rightarrow((\\neg A\\rightarrow\\neg B)\\rightarrow A)$\n$(\\neg A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow A)$,$A3$ $B\\rightarrow((\\neg A\\rightarrow\\neg B)\\rightarrow A)$,$Th2$ $((\\neg A\\rightarrow\\neg B)\\rightarrow A)\\rightarrow(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow\\neg B))$,$Th13$ $B\\rightarrow(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow\\neg B))$,$r_{mp}(2)(3)$ $\\neg A\\rightarrow(B\\rightarrow\\neg(\\neg A\\rightarrow\\neg B))$,$Th2$ $(\\neg A\\rightarrow(B\\rightarrow\\neg(\\neg A\\rightarrow\\neg B)))\\rightarrow((\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow\\neg B)))$,$A2$ $(\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow\\neg B))$,$r_{mp}(5)(6)$ $(\\neg A\\rightarrow\\neg(\\neg A\\rightarrow\\neg B))\\rightarrow((\\neg A\\rightarrow\\neg B)\\rightarrow A)$,$A3$ $(\\neg A\\rightarrow B)\\rightarrow((\\neg A\\rightarrow\\neg B)\\rightarrow A)$,$Th6$ $Th17$：$\\vdash_{PC}(A\\rightarrow B)\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg A)$\n$(A\\rightarrow\\neg B)\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg A)$,$Th15$ $B\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg A)$,$Th3$ $((A\\rightarrow\\neg B)\\rightarrow\\neg A)\\rightarrow(A\\rightarrow\\neg(A\\rightarrow\\neg B))$,$Th15$ $B\\rightarrow(A\\rightarrow\\neg(A\\rightarrow\\neg B))$,$Th6$ $A\\rightarrow(B\\rightarrow\\neg(A\\rightarrow\\neg B))$,$Th2$ $(A\\rightarrow(B\\rightarrow\\neg(A\\rightarrow\\neg B)))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow\\neg(A\\rightarrow\\neg B)))$,$A2$ $(A\\rightarrow B)\\rightarrow(A\\rightarrow\\neg(A\\rightarrow\\neg B))$,$r_{mp}(5)(6)$ $(A\\rightarrow\\neg(A\\rightarrow\\neg B))\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg A)$,$Th15$ $(A\\rightarrow B)\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg A)$,$Th6$ →拆分 $Th18$：$\\vdash_{PC}\\neg A\\rightarrow C,\\vdash_{PC}B\\rightarrow C$当且仅当$\\vdash_{PC}(A\\rightarrow B)\\rightarrow C$\n当$\\vdash_{PC}(A\\rightarrow B)\\rightarrow C$时：\n$(A\\rightarrow B)\\rightarrow C$ $B\\rightarrow(A\\rightarrow B)$,$A1$ $B\\rightarrow C$,$Th6$ $\\neg A\\rightarrow(A\\rightarrow B)$,$Th7$ $\\neg A\\rightarrow C$,$Th6$ 当$\\vdash_{PC}\\neg A\\rightarrow C,\\vdash_{PC}B\\rightarrow C$时：\n$\\neg A\\rightarrow C$ $B\\rightarrow C$ $(B\\rightarrow C)\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow C))$,$Th4$ $(A\\rightarrow B)\\rightarrow(A\\rightarrow C)$,$r_{mp}(2)(3)$ $(\\neg A\\rightarrow C)\\rightarrow(\\neg C\\rightarrow A)$,$Th14$ $\\neg C\\rightarrow A$,$r_{mp}(1)(5)$ $(\\neg C\\rightarrow A)\\rightarrow((A\\rightarrow C)\\rightarrow(\\neg C\\rightarrow C))$,$Th5$ $(A\\rightarrow C)\\rightarrow(\\neg C\\rightarrow C)$,$r_{mp}(6)(7)$ $(A\\rightarrow B)\\rightarrow(\\neg C\\rightarrow C)$,$Th2$ $(\\neg C\\rightarrow C)\\rightarrow C$,$Th9$ $(A\\rightarrow B)\\rightarrow C$,$Th6$ $Th19$：定义$A\\vee B =_ {df}\\neg A\\rightarrow B$，$\\vdash_{PC}A\\rightarrow A\\vee B$\n$A\\rightarrow(\\neg A\\rightarrow B)$,$Th8$ $Th20$：$\\vdash_{PC}A\\rightarrow B\\vee A$\n$A\\rightarrow(\\neg B\\rightarrow A)$,$A1$ $Th21$：如果$\\vdash_{PC}P\\rightarrow Q,\\vdash_{PC}R\\rightarrow S$，那么$\\vdash_{PC}(Q\\rightarrow R)\\rightarrow(P\\rightarrow S)$\n$P\\rightarrow Q$ $(P\\rightarrow Q)\\rightarrow((Q\\rightarrow R)\\rightarrow(P\\rightarrow R))$,$Th5$ $(Q\\rightarrow R)\\rightarrow(P\\rightarrow R)$,$r_{mp}(1)(2)$ $R\\rightarrow S$ $(R\\rightarrow S)\\rightarrow((P\\rightarrow R)\\rightarrow(P\\rightarrow S))$,$Th4$ $(P\\rightarrow R)\\rightarrow(P\\rightarrow S)$,$r_{mp}(4)(5)$ $(Q\\rightarrow R)\\rightarrow(P\\rightarrow S)$,$Th6$ $Th22$：$\\vdash_{PC}(A\\rightarrow C)\\rightarrow((B\\rightarrow C)\\rightarrow((A\\vee B)\\rightarrow C))$\n$(\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow B)$,$Th1$ $\\neg A\\rightarrow((\\neg A\\rightarrow B)\\rightarrow B)$,$Th2$ $((\\neg A\\rightarrow B)\\rightarrow B)\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B))$,$Th13$ $\\neg A\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B))$,$Th6$ $(\\neg A\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B)))\\rightarrow(\\neg C\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B))))$,$A1$ $\\neg C\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B)))$,$r_{mp}(4)(5)$ $(\\neg C\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B))))\\rightarrow((\\neg C\\rightarrow\\neg A)\\rightarrow(\\neg C\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B))))$,$A2$ $(\\neg C\\rightarrow\\neg A)\\rightarrow(\\neg C\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B)))$,$r_{mp}(6)(7)$ $(\\neg C\\rightarrow(\\neg B\\rightarrow\\neg(\\neg A\\rightarrow B)))\\rightarrow((\\neg C\\rightarrow\\neg B)\\rightarrow(\\neg C\\rightarrow\\neg(\\neg A\\rightarrow B)))$,$A2$ $(\\neg C\\rightarrow\\neg A)\\rightarrow((\\neg C\\rightarrow\\neg B)\\rightarrow(\\neg C\\rightarrow\\neg(\\neg A\\rightarrow B)))$,$Th6$ $(A\\rightarrow C)\\rightarrow(\\neg C\\rightarrow\\neg A)$,$Th13$ $(A\\rightarrow C)\\rightarrow((\\neg C\\rightarrow\\neg B)\\rightarrow(\\neg C\\rightarrow\\neg(\\neg A\\rightarrow B)))$,$Th6$ $(B\\rightarrow C)\\rightarrow(\\neg C\\rightarrow\\neg B)$,$Th13$ $(\\neg C\\rightarrow\\neg(\\neg A\\rightarrow B))\\rightarrow((\\neg A\\rightarrow B)\\rightarrow C)$,$A3$ $((\\neg C\\rightarrow(\\neg C\\rightarrow\\neg(\\neg A\\rightarrow B)))\\rightarrow(\\neg C\\rightarrow\\neg B))\\rightarrow((B\\rightarrow C)\\rightarrow((\\neg A\\rightarrow B)\\rightarrow C))$,$Th21$ $(A\\rightarrow C)\\rightarrow((B\\rightarrow C)\\rightarrow((\\neg A\\rightarrow B)\\rightarrow C))$,$Th6$ $Th23$： 定义$A\\wedge B =_ {df} \\neg(A\\rightarrow\\neg B)$，那么$\\vdash_{PC}A\\wedge B\\rightarrow C$当且仅当$\\vdash_{PC}A\\rightarrow(B\\rightarrow C)$\n当$\\vdash_{PC}A\\wedge B\\rightarrow C$时：\n$\\neg(A\\rightarrow\\neg B)\\rightarrow C$ $(\\neg(A\\rightarrow\\neg B)\\rightarrow C)\\rightarrow(\\neg C\\rightarrow(A\\rightarrow\\neg B))$,$Th14$ $\\neg C\\rightarrow(A\\rightarrow\\neg B)$,$r_{mp}(1)(2)$ $A\\rightarrow(\\neg C\\rightarrow\\neg B)$,$Th2$ $(\\neg C\\rightarrow\\neg B)\\rightarrow(B\\rightarrow C)$,$A3$ $A\\rightarrow(B\\rightarrow C)$,$Th6$ 当$\\vdash_{PC}A\\rightarrow(B\\rightarrow C)$时：\n$A\\rightarrow(B\\rightarrow C)$ $(B\\rightarrow C)\\rightarrow(\\neg C\\rightarrow\\neg B)$,$Th13$ $A\\rightarrow(\\neg C\\rightarrow\\neg B)$,$Th6$ $\\neg C\\rightarrow(A\\rightarrow\\neg B)$,$Th2$ $(\\neg C\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow C)$,$Th14$ $\\neg(A\\rightarrow\\neg B)\\rightarrow C$,$r_{mp}(4)(5)$ $Th24$：$\\vdash_{PC}A\\wedge B\\rightarrow A$\n$\\neg A\\rightarrow(A\\rightarrow\\neg B)$,$Th7$ $(\\neg A\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow A)$,$Th14$ $\\neg(A\\rightarrow\\neg B)\\rightarrow A$,$r_{mp}(1)(2)$ $Th25$：$\\vdash_{PC}B\\wedge A\\rightarrow A$\n$\\neg B\\rightarrow(A\\rightarrow\\neg B)$,$A1$ $(\\neg B\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow B)$,$Th14$ $\\neg(A\\rightarrow\\neg B)\\rightarrow B$,$r_{mp}(1)(2)$ $Th26$：$\\vdash_{PC}A\\rightarrow(B\\rightarrow A\\wedge B)$\n$A\\wedge B\\rightarrow A\\wedge B$,$Th1$ $A\\rightarrow(B\\rightarrow A\\wedge B)$,$Th23$ $Th27$：$\\vdash_{PC}(A\\rightarrow B)\\rightarrow((A\\rightarrow C)\\rightarrow(A\\rightarrow B\\wedge C))$\n$B\\rightarrow(C\\rightarrow B\\wedge C)$,$Th26$ $(B\\rightarrow(C\\rightarrow B\\wedge C))\\rightarrow(A\\rightarrow(B\\rightarrow(C\\rightarrow B\\wedge C)))$,$A1$ $A\\rightarrow(B\\rightarrow(C\\rightarrow B\\wedge C))$,$r_{mp}(1)(2)$ $(A\\rightarrow(B\\rightarrow(C\\rightarrow B\\wedge C)))\\rightarrow((A\\rightarrow B)\\rightarrow(A\\rightarrow(C\\rightarrow B\\wedge C)))$,$A2$ $(A\\rightarrow B)\\rightarrow(A\\rightarrow(C\\rightarrow B\\wedge C))$,$r_{mp}(3)(4)$ $A\\rightarrow((A\\rightarrow B)\\rightarrow(C\\rightarrow B\\wedge C))$,$Th2$ $((A\\rightarrow B)\\rightarrow(C\\rightarrow B\\wedge C))\\rightarrow((A\\rightarrow C)\\rightarrow(A\\rightarrow B\\wedge C))$,$A2$ $A\\rightarrow((A\\rightarrow C)\\rightarrow(A\\rightarrow B\\wedge C))$,$Th6$ $Th28$：我们将$\\vdash_{PC}P\\rightarrow Q,\\vdash_{PC}Q\\rightarrow P$记作$\\vdash_{PC}P\\leftrightarrow Q$，那么有$\\vdash_{PC}A\\vee B\\leftrightarrow B\\vee A$\n$(\\neg A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow A)$,$Th14$ $(\\neg B\\rightarrow A)\\rightarrow(\\neg A\\rightarrow B)$,$Th14$ $Th29$：$\\vdash_{PC}A\\wedge B\\leftrightarrow B\\wedge A$\n$(A\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg A)$,$Th15$ $(B\\rightarrow\\neg A)\\rightarrow(A\\rightarrow\\neg B)$,$Th15$ $Th30$：$\\vdash_{PC}(A\\vee B)\\vee C\\leftrightarrow A\\vee(B\\vee C)$\n$B\\rightarrow(\\neg B\\rightarrow C)$,$Th8$ $(B\\rightarrow(\\neg B\\rightarrow C))\\rightarrow((\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow C)))$,$A2$ $(\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow C))$,$r_{mp}(1)(2)$ $\\neg\\neg(\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow B)$,$Th10$ $\\neg\\neg(\\neg A\\rightarrow B)\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow C))$,$Th6$ $C\\rightarrow(\\neg B\\rightarrow C)$,$A1$ $(C\\rightarrow(\\neg B\\rightarrow C))\\rightarrow(\\neg A\\rightarrow(C\\rightarrow(\\neg B\\rightarrow C)))$,$A1$ $\\neg A\\rightarrow(C\\rightarrow(\\neg B\\rightarrow C))$,$r_{mp}(6)(7)$ $C\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow C))$,$Th2$ $(\\neg(\\neg A\\rightarrow B)\\rightarrow C)\\rightarrow(\\neg A\\rightarrow(\\neg B\\rightarrow C))$,$Th18$ $B\\rightarrow(\\neg A\\rightarrow B)$,$A1$ $(B\\rightarrow(\\neg A\\rightarrow B))\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg B)$,$Th13$ $\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg B$,$r_{mp}(11)(12)$ $(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg B)\\rightarrow((\\neg B\\rightarrow C)\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow C))$,$Th5$ $(\\neg B\\rightarrow C)\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow C)$,$r_{mp}(13)(14)$ $\\neg A\\rightarrow(A\\rightarrow C)$,$Th7$ $A\\rightarrow(\\neg A\\rightarrow B)$,$Th8$ $(A\\rightarrow(\\neg A\\rightarrow B))\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A)$,$Th13$ $\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A$,$r_{mp}(17)(18)$ $(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A)\\rightarrow(A\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A))$,$A1$ $A\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A)$,$r_{mp}(19)(20)$ $\\neg\\neg A\\rightarrow A$,$Th10$ $\\neg\\neg A\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A)$,$Th6$ $(\\neg A\\rightarrow(\\neg B\\rightarrow C))\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow C)$,$Th18$ $Th31$：$\\vdash_{PC}(A\\wedge B)\\wedge C\\leftrightarrow A\\wedge(B\\wedge C)$\n$(B\\rightarrow\\neg C)\\rightarrow(C\\rightarrow\\neg B)$,$Th15$ $((B\\rightarrow\\neg C)\\rightarrow(C\\rightarrow\\neg B))\\rightarrow((A\\rightarrow(B\\rightarrow\\neg C))\\rightarrow(A\\rightarrow(C\\rightarrow\\neg B)))$,$Th4$ $(A\\rightarrow(B\\rightarrow\\neg C))\\rightarrow(A\\rightarrow(C\\rightarrow\\neg B))$,$r_{mp}(1)(2)$ $(A\\rightarrow(C\\rightarrow\\neg B))\\rightarrow(C\\rightarrow(A\\rightarrow\\neg B))$,$Th3$ $(A\\rightarrow(B\\rightarrow\\neg C))\\rightarrow(C\\rightarrow(A\\rightarrow\\neg B))$,$Th6$ $\\neg\\neg(B\\rightarrow\\neg C)\\rightarrow(B\\rightarrow\\neg C)$,$Th10$ $(\\neg\\neg(B\\rightarrow\\neg C)\\rightarrow(B\\rightarrow\\neg C))\\rightarrow((A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow(A\\rightarrow(B\\rightarrow\\neg C)))$,$Th4$ $(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow(A\\rightarrow(B\\rightarrow\\neg C))$,$r_{mp}(6)(7)$ $(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow(C\\rightarrow(A\\rightarrow\\neg B))$,$Th6$ $(C\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)$,$Th13$ $(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)$,$Th6$ $((A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C))\\rightarrow(\\neg(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)\\rightarrow\\neg(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C)))$,$Th13$ $\\neg(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)\\rightarrow\\neg(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))$,$r_{mp}(11)(12)$ $(C\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg C)$,$Th15$ $((C\\rightarrow\\neg B)\\rightarrow(B\\rightarrow\\neg C))\\rightarrow((A\\rightarrow(C\\rightarrow\\neg B))\\rightarrow(A\\rightarrow(B\\rightarrow\\neg C)))$,$Th4$ $(A\\rightarrow(C\\rightarrow\\neg B))\\rightarrow(A\\rightarrow(B\\rightarrow\\neg C))$,$r_{mp}(14)(15)$ $(C\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(A\\rightarrow(C\\rightarrow\\neg B))$,$Th3$ $(C\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(A\\rightarrow(B\\rightarrow\\neg C))$,$Th6$ $(B\\rightarrow\\neg C)\\rightarrow\\neg\\neg(B\\rightarrow\\neg C)$,$Th12$ $((B\\rightarrow\\neg C)\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow((A\\rightarrow(B\\rightarrow\\neg C))\\rightarrow(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C)))$,$Th4$ $(A\\rightarrow(B\\rightarrow\\neg C))\\rightarrow(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))$,$r_{mp}(19)(20)$ $(C\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))$,$Th6$ $(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)\\rightarrow(C\\rightarrow(A\\rightarrow\\neg B))$,$A3$ $(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)\\rightarrow(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))$,$Th6$ $((\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)\\rightarrow(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C)))\\rightarrow(\\neg(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow\\neg(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C))$,$Th13$ $\\neg(A\\rightarrow\\neg\\neg(B\\rightarrow\\neg C))\\rightarrow\\neg(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg C)$,$r_{mp}(24)(25)$ $Th32$：$\\vdash_{PC}A\\wedge(A\\vee B)\\leftrightarrow A$\n$A\\rightarrow(A\\vee B\\rightarrow A)$,$A1$ $A\\wedge(A \\vee B)\\rightarrow A$,$Th23$ $\\neg A\\rightarrow\\neg A$,$Th1$ $A\\rightarrow(\\neg A\\rightarrow B)$,$Th8$ $(A\\rightarrow(\\neg A\\rightarrow B))\\rightarrow(\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A)$,$Th13$ $\\neg(\\neg A\\rightarrow B)\\rightarrow\\neg A$,$r_{mp}(4)(5)$ $((\\neg A\\rightarrow B)\\rightarrow\\neg A)\\rightarrow\\neg A$,$Th18$ $(A\\rightarrow\\neg(\\neg A\\rightarrow B))\\rightarrow((\\neg A\\rightarrow B)\\rightarrow\\neg A)$,$Th15$ $(A\\rightarrow\\neg(\\neg A\\rightarrow B))\\rightarrow\\neg A$,$Th6$ $((A\\rightarrow\\neg(\\neg A\\rightarrow B))\\rightarrow\\neg A)\\rightarrow(A\\rightarrow\\neg(A\\rightarrow\\neg(\\neg A\\rightarrow B)))$,$Th15$ $A\\rightarrow\\neg(A\\rightarrow\\neg(\\neg A\\rightarrow B))$,$r_{mp}(9)(10)$ $Th33$：$\\vdash_{PC}A\\vee(A\\wedge B)\\leftrightarrow A$\n$A\\rightarrow(\\neg A\\rightarrow(A\\wedge B))$,$Th8$ $A\\wedge B\\rightarrow A$,$Th24$ $(A\\wedge B\\rightarrow A)\\rightarrow((\\neg A\\rightarrow(A\\wedge B))\\rightarrow(\\neg A\\rightarrow A))$,$Th4$ $(\\neg A\\rightarrow(A\\wedge B))\\rightarrow(\\neg A\\rightarrow A)$,$r_{mp}(2)(3)$ $(\\neg A\\rightarrow A)\\rightarrow A$,$Th9$ $(\\neg A\\rightarrow(A\\wedge B))\\rightarrow A$,$Th6$ $Th34$：$\\vdash_{PC}A\\wedge(B\\vee C)\\leftrightarrow(A\\wedge B)\\vee(A\\wedge C)$\n$B\\rightarrow(\\neg B\\rightarrow C)$,$Th8$ $(B\\rightarrow(\\neg B\\rightarrow C))\\rightarrow(\\neg(\\neg B\\rightarrow C)\\rightarrow\\neg B)$,$Th13$ $\\neg(\\neg B\\rightarrow C)\\rightarrow\\neg B$,$r_{mp}(1)(2)$ $(\\neg(\\neg B\\rightarrow C)\\rightarrow\\neg B)\\rightarrow((A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(A\\rightarrow\\neg B))$,$Th4$ $(A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(A\\rightarrow\\neg B)$,$r_{mp}(3)(4)$ $((A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C)))$,$Th13$ $\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))$,$r_{mp}(5)(6)$ $C\\rightarrow(\\neg B\\rightarrow C)$,$A1$ $(C\\rightarrow(\\neg B\\rightarrow C))\\rightarrow(\\neg(\\neg B\\rightarrow C)\\rightarrow\\neg C)$,$Th13$ $\\neg(\\neg B\\rightarrow C)\\rightarrow\\neg C$,$r_{mp}(8)(9)$ $(\\neg(\\neg B\\rightarrow C)\\rightarrow\\neg C)\\rightarrow((A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(A\\rightarrow\\neg C))$,$Th4$ $(A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(A\\rightarrow\\neg C)$,$r_{mp}(10)(11)$ $((A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(A\\rightarrow\\neg C))\\rightarrow(\\neg(A\\rightarrow\\neg C)\\rightarrow\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C)))$,$Th13$ $\\neg(A\\rightarrow\\neg C)\\rightarrow\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))$,$r_{mp}(12)(13)$ $((A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))\\rightarrow\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))$,$Th18$ $(A\\rightarrow\\neg B)\\rightarrow\\neg\\neg(A\\rightarrow\\neg B)$,$Th12$ $((A\\rightarrow\\neg B)\\rightarrow\\neg\\neg(A\\rightarrow\\neg B))\\rightarrow((\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C)))$,$Th5$ $(\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))$,$r_{mp}(16)(17)$ $(\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))\\rightarrow\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))$,$Th6$ $(A\\rightarrow\\neg B)\\rightarrow((A\\rightarrow\\neg C)\\rightarrow(A\\rightarrow\\neg(\\neg B\\rightarrow C)))$,$Th23$ $((A\\rightarrow\\neg C)\\rightarrow(A\\rightarrow\\neg(\\neg B\\rightarrow C)))\\rightarrow(\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow\\neg(A\\rightarrow\\neg C))$,$Th13$ $(A\\rightarrow\\neg B)\\rightarrow(\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow\\neg(A\\rightarrow\\neg C))$,$Th6$ $\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow((A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))$,$Th2$ $\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow(A\\rightarrow\\neg B)$,$Th10$ $(\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow(A\\rightarrow\\neg B))\\rightarrow(((A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))\\rightarrow(\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C)))$,$Th5$ $((A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))\\rightarrow(\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))$,$r_{mp}(24)(25)$ $\\neg(A\\rightarrow\\neg(\\neg B\\rightarrow C))\\rightarrow(\\neg\\neg(A\\rightarrow\\neg B)\\rightarrow\\neg(A\\rightarrow\\neg C))$,$Th6$ $Th35$：$\\vdash_{PC}A\\vee(B\\wedge C)\\leftrightarrow(A\\vee B)\\wedge(A\\vee C)$\n$B\\wedge C\\rightarrow B$,$Th24$ $(B\\wedge C\\rightarrow B)\\rightarrow((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow B))$,$Th4$ $(\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow B)$,$r_{mp}(1)(2)$ $((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow B))\\rightarrow(((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow C))\\rightarrow((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow B)\\wedge(\\neg A\\rightarrow C)))$ $((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow C))\\rightarrow((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow B)\\wedge(\\neg A\\rightarrow C))$,$r_{mp}(3)(4)$ $B\\wedge C\\rightarrow C$,$Th25$ $(B\\wedge C\\rightarrow C)\\rightarrow((\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow C))$,$Th4$ $(\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow C)$,$r_{mp}(6)(7)$ $(\\neg A\\rightarrow(B\\wedge C))\\rightarrow(\\neg A\\rightarrow B)\\wedge(\\neg A\\rightarrow C)$,$r_{mp}(5)(8)$ $(\\neg A\\rightarrow B)\\rightarrow((\\neg A\\rightarrow C)\\rightarrow(\\neg A\\rightarrow B\\wedge C))$,$Th27$ $(\\neg A\\rightarrow B)\\wedge(\\neg A\\rightarrow C)\\rightarrow(\\neg A\\rightarrow B\\wedge C)$,$Th23$ 上述的35个PC的定理都是十分重要和有用的，其中定理$Th16$（反证法）和$Th18$（→拆分法）可以帮助我们将定理更加系统地证明，下面我们举两个例子进行说明。\nPC的基本定理的运用 运用$Th16$证明：$\\vdash_{PC}((A\\rightarrow B)\\rightarrow A)\\rightarrow A$\n如果我们要运用$Th16$，我们就需要假设这个定理不成立从而推出矛盾，不妨证明：\n$\\vdash_{PC}\\neg(((A\\rightarrow B)\\rightarrow A)\\rightarrow A)\\rightarrow(A\\rightarrow B)$\n$\\vdash_{PC}\\neg(((A\\rightarrow B)\\rightarrow A)\\rightarrow A)\\rightarrow\\neg(A\\rightarrow B)$\n后者即证：$\\vdash_{PC}((A\\rightarrow B)\\rightarrow A)\\rightarrow((A\\rightarrow B)\\rightarrow A)$，结论是显然的。\n前者即证：$\\vdash_{PC}((A\\rightarrow B)\\rightarrow A)\\rightarrow(\\neg(A\\rightarrow B)\\rightarrow A)$\n后件可以由$\\neg A\\rightarrow(A\\rightarrow B)$变形得到，所以得证。\n运用$Th18$证明：$\\vdash_{PC}(A\\rightarrow C)\\rightarrow((B\\rightarrow C)\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n运用$Th18$证明这个定理等价于证明：\n$\\vdash_{PC}\\neg A\\rightarrow((B\\rightarrow C)\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n$\\vdash_{PC}C\\rightarrow((B\\rightarrow C)\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n后者即证：$\\vdash_{PC}(B\\rightarrow C)\\rightarrow(C\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n其后件是$A1$，故结论是显然的。\n现在我们只需要证明：$\\vdash_{PC}\\neg A\\rightarrow((B\\rightarrow C)\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n即证：$\\vdash_{PC}(B\\rightarrow C)\\rightarrow(\\neg A\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n再次运用$Th18$，即证：\n$\\vdash_{PC}\\neg B\\rightarrow(\\neg A\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n$\\vdash_{PC}C\\rightarrow(\\neg A\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n后者即证$\\vdash_{PC}\\neg A\\rightarrow(C\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n其后件是$A1$，故结论是显然的。\n现在我们只需要证明：$\\vdash_{PC}\\neg B\\rightarrow(\\neg A\\rightarrow(((A\\rightarrow B)\\rightarrow B)\\rightarrow C))$\n即证：$\\vdash_{PC}((A\\rightarrow B)\\rightarrow B)\\rightarrow(\\neg B\\rightarrow(\\neg A\\rightarrow C))$\n再次运用$Th18$，即证：\n$\\vdash_{PC}\\neg(A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow(\\neg A\\rightarrow C))$\n$\\vdash_{PC}B\\rightarrow(\\neg B\\rightarrow(\\neg A\\rightarrow C))$\n后者是$Th8$，故结论是显然的。\n现在我们只需要证明：$\\vdash_{PC}\\neg(A\\rightarrow B)\\rightarrow(\\neg B\\rightarrow(\\neg A\\rightarrow C))$\n即证：$\\vdash_{PC}\\neg B\\rightarrow(\\neg A\\rightarrow(\\neg C\\rightarrow (A\\rightarrow B)))$\n不妨证：$\\vdash_{PC}\\neg A\\rightarrow(\\neg C\\rightarrow (A\\rightarrow B))$\n可知有：\n$\\vdash_{PC}\\neg A\\rightarrow(A\\rightarrow B)$\n$\\vdash_{PC}(A\\rightarrow B)\\rightarrow(\\neg C\\rightarrow(A\\rightarrow B))$\n按照上述思路将对应的证明序列写出即可证明该定理。\n演绎定理 证明：$\\vdash_{PC}(A\\rightarrow(B\\rightarrow C))\\rightarrow((C\\rightarrow D)\\rightarrow(A\\rightarrow(B\\rightarrow D)))$\n$(C\\rightarrow D)\\rightarrow((B\\rightarrow C)\\rightarrow(B\\rightarrow D))$,$Th4$ $((B\\rightarrow C)\\rightarrow(B\\rightarrow D))\\rightarrow((A\\rightarrow(B\\rightarrow C))\\rightarrow(A\\rightarrow(B\\rightarrow D)))$,$Th4$ $(C\\rightarrow D)\\rightarrow((A\\rightarrow(B\\rightarrow C))\\rightarrow(A\\rightarrow(B\\rightarrow D)))$,$Th6$ $(A\\rightarrow(B\\rightarrow C))\\rightarrow((C\\rightarrow D)\\rightarrow(A\\rightarrow(B\\rightarrow D)))$,$Th2$ 上面这个例子表明，在PC中证明定理的这个过程中的公式序列的公式长度通常较长，为了缩短公式序列的长度，我们现在给出PC中一个重要方便的定理：演绎定理。\n演绎定理：对PC中任意公式集合$\\Gamma$和公式$A,B$，$\\Gamma\\cup${$A$}$\\vdash_{PC}B$（或记为$\\Gamma;A\\vdash_{PC}B$）当且仅当$\\Gamma\\vdash_{PC}A\\rightarrow B$。\n证明：（充分性）\n已知$\\Gamma\\vdash_{PC}A\\rightarrow B$\n从$\\Gamma$出发在PC可以得到一个$A\\rightarrow B$的演绎序列$A_1,A_2,\\cdots,A_n(=A\\rightarrow B)$\n从$\\Gamma\\cup${$A$}出发在PC也可以得到一个$A\\rightarrow B$的演绎序列$A_1,A_2,\\cdots,A_n(=A\\rightarrow B)$\n从$\\Gamma\\cup${$A$}出发在PC中可以得到$B$的一个演绎序列$A_1,A_2,\\cdots,A_n(=A\\rightarrow B),A,B$\n也就是说有$\\Gamma;A\\vdash_{PC}B$。 证明：（必要性）\n已知$\\Gamma\\cup${$A$}$\\vdash_{PC}B$\n从$\\Gamma\\cup${$A$}出发在PC可以得到一个$B$的演绎序列$B_1,B_2,\\cdots,B_k(=B)$，我们对演绎序列的长度$k$使用数学归纳法：\n当$k=1$时可知$B$或是公理、或有$B\\in\\Gamma\\cup${$A$}：\n当$B$是公理时，$A\\rightarrow B$有演绎序列$B,B\\rightarrow(A\\rightarrow B),A\\rightarrow B$。\n当$B\\in\\Gamma$时，$A\\rightarrow B$有演绎序列$B,B\\rightarrow(A\\rightarrow B),A\\rightarrow B$。\n当$B=A$时，$A\\rightarrow B$也即$A\\rightarrow A$，也就是$Th1$，那么有$\\Gamma\\vdash_{PC}A\\rightarrow B$。\n假设$k\u0026lt; n$时原命题成立，那么对于$B$的演绎序列中的公式有$\\Gamma\\vdash_{PC}A\\rightarrow B_i,i\u0026lt; n$。\n那么$k=n$时$B$或为公理、或有$B\\in\\Gamma\\cup${$A$}，或由$B_i,B_j(i,j\u0026lt; n)$通过$r_{mp}$得到。\n当$B$是公理时，$A\\rightarrow B$有演绎序列$B,B\\rightarrow(A\\rightarrow B),A\\rightarrow B$。\n当$B\\in\\Gamma$时，$A\\rightarrow B$有演绎序列$B,B\\rightarrow(A\\rightarrow B),A\\rightarrow B$。\n当$B=A$时，$A\\rightarrow B$也即$A\\rightarrow A$，也就是$Th1$，那么有$\\Gamma\\vdash_{PC}A\\rightarrow B$。\n当$B$由$B_i,B_j(i,j\u0026lt; n)$通过$r_{mp}$得到时，我们设$B_j=B_i\\rightarrow B$。\n那么有：$\\Gamma\\vdash_{PC}A\\rightarrow B_i,\\Gamma\\vdash_{PC}A\\rightarrow B_j$\n也就是说：$\\Gamma\\vdash_{PC}A\\rightarrow B_i,\\Gamma\\vdash_{PC}A\\rightarrow(B_i\\rightarrow B)$\n由$A2$知：$(A\\rightarrow(B_i\\rightarrow B))\\rightarrow((A\\rightarrow B_i)\\rightarrow(A\\rightarrow B))$\n故：$\\vdash_{PC}(A\\rightarrow B_i)\\rightarrow(A\\rightarrow B)$，则$\\Gamma\\vdash_{PC}A\\rightarrow B$\n我们现在回到上面那个例子，现在使用演绎定理解决这个问题。\n证明：$\\vdash_{PC}(A\\rightarrow(B\\rightarrow C))\\rightarrow((C\\rightarrow D)\\rightarrow(A\\rightarrow(B\\rightarrow D)))$\n即证：$A\\rightarrow(B\\rightarrow C)\\vdash_{PC}(C\\rightarrow D)\\rightarrow(A\\rightarrow(B\\rightarrow D))$\n即证：$A\\rightarrow(B\\rightarrow C),C\\rightarrow D\\vdash_{PC}A\\rightarrow(B\\rightarrow D)$\n即证：$A\\rightarrow(B\\rightarrow C),C\\rightarrow D,A\\vdash_{PC}B\\rightarrow D$\n即证：$A\\rightarrow(B\\rightarrow C),C\\rightarrow D,A,B\\vdash_{PC}D$\n$A$ $A\\rightarrow(B\\rightarrow C)$ $B\\rightarrow C$,$r_{mp}(1)(2)$ $B$ $C$,$r_{mp}(3)(4)$ $C\\rightarrow D$ $D$,$r_{mp}(5)(6)$ 不难发现，在使用了演绎定理之后，我们的证明过程中涉及的公式变得更加简单了。\nPC定理证明习题选 下面给出了六道PC定理习题供读者练习使用：\n证明：$\\vdash_{PC}(A\\rightarrow(B\\rightarrow C))\\rightarrow((A\\rightarrow(D\\rightarrow B))\\rightarrow(A\\rightarrow(D\\rightarrow C)))$ 证明：$\\vdash_{PC}(((A\\rightarrow B)\\rightarrow C)\\rightarrow D)\\rightarrow((B\\rightarrow D)\\rightarrow(A\\rightarrow D))$ 证明：$\\vdash_{PC}(A\\rightarrow(\\neg B\\rightarrow(\\neg D\\rightarrow C)))\\rightarrow((B\\rightarrow\\neg A)\\rightarrow((C\\rightarrow\\neg A)\\rightarrow(A\\rightarrow D)))$ 证明：$\\vdash_{PC}((D\\rightarrow B)\\rightarrow((C\\rightarrow G)\\rightarrow A))\\rightarrow((E\\rightarrow((C\\rightarrow G)\\rightarrow A))\\rightarrow((D\\rightarrow E)\\rightarrow(G\\rightarrow A)))$ 证明：$\\vdash_{PC}(C\\rightarrow(\\neg A\\rightarrow(\\neg D\\rightarrow A)))\\rightarrow((B\\rightarrow A)\\rightarrow((\\neg B\\rightarrow C)\\rightarrow(\\neg A\\rightarrow D)))$ 证明：$\\vdash_{PC}((B\\rightarrow C)\\rightarrow(D\\rightarrow E))\\rightarrow(((B\\rightarrow C)\\rightarrow(G\\rightarrow H))\\rightarrow(((A\\rightarrow B)\\rightarrow C)\\rightarrow\\neg(((E\\rightarrow G)\\rightarrow(D\\rightarrow H))\\rightarrow\\neg((G\\rightarrow\\neg H)\\rightarrow\\neg G))))$ ","date":"2023-12-18T00:00:00Z","image":"https://0x3a0x29.github.io/p/propositionalcalculus/23_hu8007231486806173450.png","permalink":"https://0x3a0x29.github.io/p/propositionalcalculus/","title":"PC(命题逻辑演算形式系统)及其相关定理"}]